<!-- wp:html -->
<style>
    :root {
      color-scheme: dark;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      min-height: 100%;
    }

    body {
      font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(ellipse at center, #070b1a 0%, #02040a 100%);
      color: #f5f9ff;
      overflow: hidden;
    }

    body.page-template-supercluster-ai-constellation-login,
    body.page-template-supercluster-ai-constellation-login .wp-site-blocks {
      margin: 0 !important;
      min-height: 100vh;
    }

    body.page-template-supercluster-ai-constellation-login #wpadminbar {
      display: none !important;
    }

    body.page-template-supercluster-ai-constellation-login.admin-bar {
      padding-top: 0 !important;
    }

    #vlSuperclusterLogin {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: clamp(1.5rem, 6vw, 3rem);
      isolation: isolate;
      overflow: hidden;
    }

    #vlSuperclusterLogin::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(120% 120% at 10% 10%, rgba(61, 102, 186, 0.24), transparent 48%),
        radial-gradient(120% 120% at 80% 20%, rgba(147, 89, 255, 0.18), transparent 55%),
        radial-gradient(120% 140% at 50% 120%, rgba(61, 122, 255, 0.32), transparent 62%);
      z-index: 1;
      pointer-events: none;
    }

    #vlSuperclusterLogin::after {
      content: "";
      position: absolute;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg width='160' height='160' viewBox='0 0 160 160' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='rgba(136,192,255,0.08)'%3E%3Ccircle cx='10' cy='10' r='1.2'/%3E%3Ccircle cx='80' cy='40' r='0.9'/%3E%3Ccircle cx='130' cy='70' r='1.1'/%3E%3Ccircle cx='40' cy='110' r='0.8'/%3E%3Ccircle cx='120' cy='140' r='1.4'/%3E%3Ccircle cx='70' cy='150' r='0.7'/%3E%3Ccircle cx='20' cy='70' r='1'/%3E%3Ccircle cx='150' cy='30' r='0.6'/%3E%3C/g%3E%3C/svg%3E");
      background-size: 160px 160px;
      opacity: 0.65;
      mix-blend-mode: screen;
      z-index: 1;
      pointer-events: none;
    }

    #vlSuperclusterLogin .login-surface {
      position: relative;
      z-index: 2;
      width: min(520px, 100%);
      padding: clamp(2.25rem, 6vw, 3rem);
      background: rgba(6, 10, 24, 0.76);
      border-radius: 24px;
      border: 1px solid rgba(122, 180, 255, 0.22);
      backdrop-filter: blur(22px);
      box-shadow: 0 48px 140px rgba(5, 11, 29, 0.75);
    }

    #vlSuperclusterLogin .login-icon {
      position: relative;
      width: 96px;
      height: 96px;
      margin: 0 auto 1.75rem;
      display: grid;
      place-items: center;
      filter: drop-shadow(0 0 32px rgba(114, 178, 255, 0.45));
    }

    #vlSuperclusterLogin .login-icon .core {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: radial-gradient(circle at 32% 32%, #ffffff 0%, #7ec4ff 35%, #435fff 100%);
      box-shadow: 0 0 32px rgba(114, 178, 255, 0.5), 0 0 68px rgba(114, 178, 255, 0.3);
      animation: loginCorePulse 2s ease-in-out infinite;
    }

    #vlSuperclusterLogin .login-icon .ring {
      position: absolute;
      width: 84px;
      height: 84px;
      border-radius: 50%;
      border: 2px solid rgba(126, 192, 255, 0.38);
      box-shadow: 0 0 26px rgba(126, 192, 255, 0.35), inset 0 0 26px rgba(126, 192, 255, 0.24);
      animation: loginRingPulse 2.4s ease-in-out infinite;
    }

    #vlSuperclusterLogin .login-icon .node {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.9), rgba(126, 192, 255, 0.9));
      box-shadow: 0 0 18px rgba(126, 192, 255, 0.45);
      transform: translate(calc(-50% + var(--offset-x)), calc(-50% + var(--offset-y))) scale(0.25);
      opacity: 0;
      animation: loginNodeSpawn 1.8s ease-in-out infinite;
    }

    #vlSuperclusterLogin .login-icon .node::after {
      content: "";
      position: absolute;
      inset: -40%;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(126, 192, 255, 0.45), rgba(126, 192, 255, 0));
    }

    #vlSuperclusterLogin .login-icon .node:nth-child(3) {
      --offset-x: 28px;
      --offset-y: -10px;
      animation-delay: 0s;
    }

    #vlSuperclusterLogin .login-icon .node:nth-child(4) {
      --offset-x: -32px;
      --offset-y: -6px;
      animation-delay: 0.28s;
    }

    #vlSuperclusterLogin .login-icon .node:nth-child(5) {
      --offset-x: 18px;
      --offset-y: 30px;
      animation-delay: 0.56s;
    }

    #vlSuperclusterLogin .login-icon .node:nth-child(6) {
      --offset-x: -14px;
      --offset-y: 32px;
      animation-delay: 0.84s;
    }

    #vlSuperclusterLogin .login-icon .node:nth-child(7) {
      --offset-x: 34px;
      --offset-y: -28px;
      animation-delay: 1.1s;
    }

    #vlSuperclusterLogin h1 {
      margin: 0 0 0.35rem;
      text-align: center;
      font-size: clamp(1.7rem, 3vw, 2.1rem);
      letter-spacing: 0.04em;
    }

    #vlSuperclusterLogin p.subtitle {
      margin: 0 0 2.5rem;
      text-align: center;
      font-size: clamp(0.95rem, 1.8vw, 1.05rem);
      color: rgba(223, 239, 255, 0.8);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    #vlSuperclusterLogin form {
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
    }

    #vlSuperclusterLogin label {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-size: 0.78rem;
      color: rgba(207, 229, 255, 0.78);
    }

    #vlSuperclusterLogin input {
      appearance: none;
      border: 1px solid rgba(124, 188, 255, 0.28);
      border-radius: 14px;
      padding: 0.85rem 1rem;
      background: rgba(8, 14, 32, 0.72);
      color: #f5f9ff;
      font-size: 1rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    #vlSuperclusterLogin input:focus {
      outline: none;
      border-color: rgba(164, 212, 255, 0.8);
      box-shadow: 0 0 0 3px rgba(116, 184, 255, 0.25);
      background: rgba(8, 14, 32, 0.72);
      color: #f5f9ff;
    }

    /* Override browser default validation styling */
    #vlSuperclusterLogin input:valid,
    #vlSuperclusterLogin input:invalid,
    #vlSuperclusterLogin input:focus:valid,
    #vlSuperclusterLogin input:focus:invalid {
      background: rgba(8, 14, 32, 0.72) !important;
      color: #f5f9ff !important;
      border-color: rgba(124, 188, 255, 0.28);
    }

    #vlSuperclusterLogin input:focus:valid,
    #vlSuperclusterLogin input:focus:invalid {
      border-color: rgba(164, 212, 255, 0.8);
      box-shadow: 0 0 0 3px rgba(116, 184, 255, 0.25);
    }

    #vlSuperclusterLogin button[type="submit"] {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      border: none;
      border-radius: 999px;
      padding: 0.95rem 1.35rem;
      background: linear-gradient(135deg, #6fc5ff 0%, #3d6aff 100%);
      color: #020410;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, filter 0.18s ease;
    }

    #vlSuperclusterLogin button[type="submit"]:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 42px rgba(90, 162, 255, 0.45);
      filter: brightness(1.05);
    }

    #vlSuperclusterLogin button[type="submit"]:disabled {
      cursor: wait;
      filter: saturate(0.6);
    }

    #vlSuperclusterLogin .button-spinner {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 2px solid rgba(3, 5, 12, 0.35);
      border-top-color: rgba(3, 5, 12, 0.95);
      display: none;
    }

    #vlSuperclusterLogin.is-busy .button-spinner {
      display: inline-block;
      animation: loginSpinner 0.8s linear infinite;
    }

    #vlSuperclusterLogin.is-busy button[type="submit"] {
      pointer-events: none;
    }

    #vlSuperclusterLogin .vl-login-status {
      margin: 1.25rem 0 0;
      min-height: 1.5rem;
      font-size: 0.9rem;
      letter-spacing: 0.03em;
      text-align: center;
      color: rgba(212, 232, 255, 0.85);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #vlSuperclusterLogin .vl-login-status.is-visible {
      opacity: 1;
    }

    #vlSuperclusterLogin .vl-login-status[data-state="error"] {
      color: #ff98b0;
    }

    #vlSuperclusterLogin .vl-login-status[data-state="success"] {
      color: #8af7d0;
    }

    #vlSuperclusterLogin .fine-print {
      margin: 2rem 0 0;
      font-size: 0.8rem;
      text-align: center;
      color: rgba(198, 218, 255, 0.65);
      line-height: 1.6;
    }

    @media (max-width: 640px) {
      #vlSuperclusterLogin {
        padding: 1.5rem;
      }
      #vlSuperclusterLogin .login-surface {
        padding: 2rem 1.5rem;
        border-radius: 20px;
      }
    }

    @keyframes loginCorePulse {
      0%,
      100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.08);
      }
    }

    @keyframes loginRingPulse {
      0%,
      100% {
        transform: scale(1);
        opacity: 0.9;
      }
      50% {
        transform: scale(1.06);
        opacity: 0.65;
      }
    }

    @keyframes loginNodeSpawn {
      0% {
        opacity: 0;
        transform: translate(calc(-50% + var(--offset-x)), calc(-50% + var(--offset-y))) scale(0.25);
      }
      30% {
        opacity: 1;
        transform: translate(calc(-50% + var(--offset-x)), calc(-50% + var(--offset-y))) scale(1.05);
      }
      55% {
        opacity: 1;
        transform: translate(calc(-50% + var(--offset-x)), calc(-50% + var(--offset-y))) scale(0.94);
      }
      100% {
        opacity: 0;
        transform: translate(calc(-50% + var(--offset-x)), calc(-50% + var(--offset-y))) scale(0.25);
      }
    }

    @keyframes loginSpinner {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
</style>

<section
  id="vlSuperclusterLogin"
  class="vl-supercluster-login"
  data-supercluster-path="https://supercluster.visiblelight.ai/"
  data-login-path="/supercluster-ai-constellation-login/"
>
  <div class="login-surface">
    <div class="login-icon" aria-hidden="true">
      <span class="ring"></span>
      <span class="core"></span>
      <span class="node"></span>
      <span class="node"></span>
      <span class="node"></span>
      <span class="node"></span>
      <span class="node"></span>
    </div>
    <h1>Get Connected</h1>
    <p class="subtitle">Visible Light AI Supercluster Access</p>
    <form id="vlSuperclusterLoginForm" method="POST" action="" novalidate>
      <label>
        Username or Email
        <input type="text" name="username" autocomplete="username" required />
      </label>
      <label>
        Password
        <input type="password" name="password" autocomplete="current-password" required />
      </label>
      <button type="submit">
        <span class="label">Connect</span>
        <span class="button-spinner" aria-hidden="true"></span>
      </button>
    </form>
    <div class="vl-login-status" id="vlLoginStatus" role="status" aria-live="polite"></div>
    <p class="fine-print">
      Sign in with your VL Client credentials to sync your Supercluster data and launch the constellation.
    </p>
  </div>
</section>

<script>
  // CRITICAL SECURITY: Strip credentials from URL immediately - before anything else runs
  (function() {
    try {
      const url = new URL(window.location.href);
      const params = url.searchParams;
      
      if (params.has('username') || params.has('password') || params.has('log') || params.has('pwd')) {
        // Remove all credential-related parameters
        params.delete('username');
        params.delete('password');
        params.delete('log');
        params.delete('pwd');
        
        // Update URL without credentials using history API (no page reload)
        const cleanUrl = url.pathname + (params.toString() ? '?' + params.toString() : '') + url.hash;
        window.history.replaceState({}, '', cleanUrl);
        
        console.warn('[SECURITY] Removed credentials from URL - credentials should never be in URLs!');
      }
    } catch (e) {
      console.error('[SECURITY] Error cleaning URL:', e);
    }
  })();

  const root = document.getElementById("vlSuperclusterLogin");
  if (!root) {
    console.warn("[Supercluster Login] Root element missing");
  } else {
    const form = document.getElementById("vlSuperclusterLoginForm");
    const statusEl = document.getElementById("vlLoginStatus");
    const submitButton = form.querySelector('button[type="submit"]');
    const inputs = Array.from(form.querySelectorAll("input"));
    const usernameField = form.querySelector('input[name="username"]');
    const passwordField = form.querySelector('input[name="password"]');

    const rawSuperclusterPath = (root.dataset.superclusterPath || "https://supercluster.visiblelight.ai/").trim();
    const rawLoginPath = (root.dataset.loginPath || "/supercluster-ai-constellation-login/").trim();
    const licenseStorageKey = "vl_supercluster_license";
    const licenseParamKeys = ["license", "lic", "vl_license", "vl_license_key"];
    let loginPrimed = false;

    const sessionEndpointTemplates = [
      "luna-license-manager.php?rest_route=/vl-hub/v1/session",
      "/wp-json/vl-hub/v1/session",
      "/?rest_route=/vl-hub/v1/session",
    ];

    function normalizePath(path) {
      if (!path) return "/";
      // If it's an absolute URL, preserve the origin and pathname
      if (/^https?:\/\//i.test(path)) {
        try {
          const u = new URL(path);
          const trailing = u.pathname.endsWith("/") ? "" : "/";
          return `${u.origin}${u.pathname}${trailing}`;
        } catch {
          // If URL parsing fails, fall back to original string with trailing slash
          return path.endsWith("/") ? path : `${path}/`;
        }
      }
      // Relative path: ensure single leading slash and trailing slash
      const p = String(path).replace(/^\/*/, "/");
      return p.endsWith("/") ? p : `${p}/`;
    }

    const superclusterPath = normalizePath(rawSuperclusterPath);
    const loginPath = normalizePath(rawLoginPath);

    function buildEndpoint(template) {
      try {
        const url = new URL(template, window.location.origin);
        return url.pathname + url.search;
      } catch (error) {
        return template;
      }
    }

    function ensureWordPressTestCookie() {
      try {
        const cookieValue = encodeURIComponent("WP Cookie check");
        const attributes = ["path=/", "SameSite=Lax"];
        if (window.location.protocol === "https:") {
          attributes.push("Secure");
        }
        document.cookie = `wordpress_test_cookie=${cookieValue}; ${attributes.join("; ")}`;
      } catch (error) {
        console.warn("[Supercluster Login] Unable to set WordPress test cookie", error);
      }
    }

    async function primeLoginSession() {
      ensureWordPressTestCookie();
      if (loginPrimed) {
        return true;
      }

      try {
        const response = await fetch(buildEndpoint("/wp-login.php"), {
          method: "GET",
          credentials: "include",
          cache: "no-store",
        });
        if (response && response.ok) {
          loginPrimed = true;
        }
      } catch (error) {
        console.warn("[Supercluster Login] Failed to prime WordPress login session", error);
      }

      return loginPrimed;
    }

    function sanitizeLicenseValue(raw) {
      if (raw === undefined || raw === null) {
        return "";
      }

      let candidate = typeof raw === "string" ? raw.trim() : String(raw).trim();
      if (!candidate) {
        return "";
      }

      try {
        candidate = decodeURIComponent(candidate);
      } catch (error) {
        // Ignore decode failures and fall back to the original value.
      }

      candidate = candidate.replace(/["'`\s]+/g, "");

      const equalsIndex = candidate.indexOf("=");
      if (equalsIndex > -1) {
        const prefix = candidate.slice(0, equalsIndex).trim();
        const suffix = candidate.slice(equalsIndex + 1).trim();
        const prefixLooksLikeLicense = /^(?:VL-|lic[_-])/i.test(prefix);
        const suffixLooksLikeLicense = /^(?:VL-|lic[_-])/i.test(suffix);

        if (prefixLooksLikeLicense && !suffixLooksLikeLicense) {
          candidate = prefix;
        } else if (suffixLooksLikeLicense && !prefixLooksLikeLicense) {
          candidate = suffix;
        } else if (prefixLooksLikeLicense && suffixLooksLikeLicense) {
          candidate = prefix.length >= suffix.length ? prefix : suffix;
        } else if (suffixLooksLikeLicense) {
          candidate = suffix;
        } else if (prefixLooksLikeLicense) {
          candidate = prefix;
        } else if (suffix) {
          candidate = suffix;
        } else if (prefix && !/^nocache$/i.test(prefix)) {
          candidate = prefix;
        }
      }

      const match = candidate.match(/(VL-[A-Z0-9-]{4,}|lic[_-][A-Za-z0-9-]{6,})/i);
      if (match) {
        const value = match[1];
        return /^VL-/i.test(value) ? value.toUpperCase() : value;
      }

      if (/^VL-[A-Z0-9-]{4,}/i.test(candidate)) {
        return candidate.toUpperCase();
      }

      if (/^lic[_-][A-Za-z0-9-]{6,}/i.test(candidate)) {
        return candidate;
      }

      return "";
    }

    function extractLicenseFromParams(params) {
      if (!params) {
        return "";
      }

      for (const key of licenseParamKeys) {
        const value = params.get(key);
        const sanitized = sanitizeLicenseValue(value);
        if (sanitized) {
          return sanitized;
        }
      }

      return "";
    }

    function keySuggestsLicense(key) {
      if (!key) {
        return false;
      }
      const normalized = key.toLowerCase();
      if (normalized.includes("license")) {
        return true;
      }
      if (normalized.includes("activation") && normalized.includes("key")) {
        return true;
      }
      return (
        normalized === "activation" ||
        normalized === "activationkey" ||
        normalized === "activation_key" ||
        normalized === "user_activation_key" ||
        normalized === "useractivationkey" ||
        normalized === "wp_activation_key" ||
        normalized === "wpactivationkey" ||
        normalized.includes("vl_license")
      );
    }

    function pushLicenseCandidate(bucket, value) {
      if (!bucket || value === undefined || value === null) {
        return;
      }

      if (Array.isArray(value)) {
        value.forEach((entry) => pushLicenseCandidate(bucket, entry));
        return;
      }

      if (typeof value === "object") {
        return;
      }

      const sanitized = sanitizeLicenseValue(value);
      if (sanitized) {
        bucket.add(sanitized);
      }
    }

    function collectLicenseCandidates(source, bucket, depth = 0, visited = new WeakSet()) {
      if (source === undefined || source === null || depth > 4) {
        return;
      }

      if (Array.isArray(source)) {
        source.forEach((entry) => collectLicenseCandidates(entry, bucket, depth + 1, visited));
        return;
      }

      if (typeof source !== "object") {
        pushLicenseCandidate(bucket, source);
        return;
      }

      if (visited.has(source)) {
        return;
      }
      visited.add(source);

      for (const [key, value] of Object.entries(source)) {
        if (value === undefined || value === null) {
          continue;
        }

        const normalizedKey = key.toLowerCase();

        if (typeof value === "string" || typeof value === "number") {
          if (keySuggestsLicense(normalizedKey)) {
            pushLicenseCandidate(bucket, value);
          } else {
            const sanitized = sanitizeLicenseValue(value);
            if (sanitized) {
              bucket.add(sanitized);
            }
          }
          continue;
        }

        if (Array.isArray(value)) {
          if (keySuggestsLicense(normalizedKey)) {
            value.forEach((entry) => pushLicenseCandidate(bucket, entry));
          }
          collectLicenseCandidates(value, bucket, depth + 1, visited);
          continue;
        }

        if (typeof value === "object") {
          collectLicenseCandidates(value, bucket, depth + 1, visited);
        }
      }
    }

    function resolveLicenseFromSession(session, providedLicense, additionalHints = []) {
      const bucket = new Set();
      pushLicenseCandidate(bucket, providedLicense);
      additionalHints.forEach((hint) => pushLicenseCandidate(bucket, hint));

      collectLicenseCandidates(session, bucket);

      const candidates = Array.from(bucket);
      if (!candidates.length) {
        return "";
      }

      // Prioritize session license keys (wp_activation_key or license_key) if they exist and look like VL licenses
      const wpActivationKey = session.wp_activation_key;
      const sessionLicenseKey = session.license_key;
      
      // First priority: wp_activation_key from session
      if (wpActivationKey && wpActivationKey.toUpperCase().startsWith("VL-")) {
        console.log('Using wp_activation_key from session:', wpActivationKey);
        return wpActivationKey;
      }
      
      // Second priority: license_key from session
      if (sessionLicenseKey && sessionLicenseKey.toUpperCase().startsWith("VL-")) {
        console.log('Using license_key from session:', sessionLicenseKey);
        return sessionLicenseKey;
      }

      // Fallback to other candidates (but they should not be used if session has no license)
      const preferred = candidates.find((candidate) => candidate.toUpperCase().startsWith("VL-"));
      if (preferred) {
        console.log('Using preferred candidate:', preferred);
        return preferred;
      }
      
      // Last resort - return first candidate (but log a warning)
      if (candidates.length > 0) {
        console.warn('No VL license found in session, using fallback candidate:', candidates[0]);
        return candidates[0];
      }
      
      return "";
    }

    function gatherAdditionalLicenseHints(exclude) {
      const hints = [];
      const sanitizedExclude = sanitizeLicenseValue(exclude);

      const pushHint = (value) => {
        const sanitized = sanitizeLicenseValue(value);
        if (!sanitized) {
          return;
        }
        if (sanitizedExclude && sanitized === sanitizedExclude) {
          return;
        }
        hints.push(sanitized);
      };

      pushHint(storedLicense());
      pushHint(initialLicenseHint);

      if (typeof window !== "undefined") {
        try {
          const params = new URLSearchParams(window.location.search);
          pushHint(extractLicenseFromParams(params));
        } catch (error) {
          // Ignore query parsing errors.
        }
      }

      return hints;
    }

    async function tryFetchJson(endpoint, options = {}) {
      try {
        const response = await fetch(endpoint, {
          credentials: "include",
          cache: "no-store",
          ...options,
        });
        if (!response.ok) {
          return { ok: false, status: response.status };
        }
        const data = await response.json();
        return { ok: true, data };
      } catch (error) {
        return { ok: false, error };
      }
    }

    async function fetchSessionInfo() {
      console.log('Fetching session info...');
      
      // First try the VL Hub session endpoints - this should return license key for authenticated users
      for (const template of sessionEndpointTemplates) {
        const endpoint = buildEndpoint(template);
        console.log('Trying session endpoint:', endpoint);
        const result = await tryFetchJson(endpoint);
        console.log('Session endpoint result:', result);
        if (result.ok && result.data) {
          if (result.data.authenticated === true) {
            console.log('Session data received:', result.data);
            console.log('License key from session:', result.data.license_key || result.data.wp_activation_key);
            // Return session data - license key should be in license_key or wp_activation_key
            return result.data;
          }
        }
      }
      
      // Fallback: Try WordPress REST API to check if user is logged in
      console.log('Trying WordPress REST API fallback...');
      try {
        // First try a simple endpoint to check if we're logged in
        const testResponse = await fetch('/wp-json/wp/v2/users/me', {
          credentials: 'include',
          cache: 'no-store'
        });
        console.log('WordPress REST API test response status:', testResponse.status);
        
        if (testResponse.status === 401) {
          console.log('WordPress REST API returned 401 - not logged in');
          // Try to check if we can access admin area
          try {
            const adminResponse = await fetch('/wp-admin/admin-ajax.php', {
              method: 'POST',
              credentials: 'include',
              headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
              },
              body: 'action=heartbeat&_wpnonce=test'
            });
            console.log('Admin AJAX response status:', adminResponse.status);
            if (adminResponse.status === 200) {
              console.log('Admin area accessible - user is logged in');
              // User is logged in but REST API isn't working, try alternative approach
              // Try to get the session from Luna License Manager directly
              try {
                const lunaResponse = await fetch('/luna-license-manager.php?rest_route=/vl-hub/v1/session', {
                  credentials: 'include',
                  cache: 'no-store'
                });
                console.log('Luna License Manager session response status:', lunaResponse.status);
                if (lunaResponse.status === 200) {
                  const lunaData = await lunaResponse.json();
                  console.log('Luna License Manager session data:', lunaData);
                  console.log('Luna session wp_activation_key:', lunaData.wp_activation_key);
                  console.log('Luna session license_key:', lunaData.license_key);
                  if (lunaData && lunaData.authenticated === true) {
                    return lunaData;
                  }
                }
              } catch (lunaError) {
                console.log('Luna License Manager session check failed:', lunaError);
              }
              // Fallback: assume user is logged in and has VL Client role
              // Since we know this is a VL Client, we need to get their license key
              // Try to get it from the database directly via a custom endpoint
              try {
                const licenseResponse = await fetch('/luna-license-manager.php?rest_route=/vl-hub/v1/user-license', {
                  credentials: 'include',
                  cache: 'no-store'
                });
                if (licenseResponse.status === 200) {
                  const licenseData = await licenseResponse.json();
                  console.log('User license data:', licenseData);
                  if (licenseData && licenseData.license_key) {
                    return { 
                      authenticated: true, 
                      is_vl_client: true, 
                      user: { roles: ['vl_client'] },
                      wp_activation_key: licenseData.license_key,
                      license_key: licenseData.license_key
                    };
                  }
                }
              } catch (licenseError) {
                console.log('License fetch failed:', licenseError);
              }
              // If we can't fetch the license, don't use a fallback - return unauthenticated
              // This ensures users are properly associated with their own license keys
              console.log('Could not determine license key for user - returning unauthenticated');
              return { authenticated: false };
            }
          } catch (adminError) {
            console.log('Admin area check failed:', adminError);
          }
          return { authenticated: false };
        }
        
        const response = testResponse;
        
        if (response.ok) {
          const userData = await response.json();
          console.log('WordPress user data:', userData);
          console.log('User roles:', userData.roles);
          
          // User is authenticated - try to get license key from VL Hub endpoint
          // Don't check for specific role - any authenticated user with a license key should have access
          try {
            // Try VL Hub session endpoint one more time after confirming WordPress auth
            const vlSessionResponse = await fetch('/wp-json/vl-hub/v1/session', {
              credentials: 'include',
              cache: 'no-store'
            });
            
            if (vlSessionResponse.ok) {
              const vlSessionData = await vlSessionResponse.json();
              console.log('VL Hub session data after WordPress auth:', vlSessionData);
              
              if (vlSessionData && vlSessionData.authenticated === true) {
                // Return VL Hub session data which should have the license key
                return vlSessionData;
              }
            }
          } catch (vlError) {
            console.log('VL Hub session fetch failed:', vlError);
          }
          
          // Fallback: return authenticated session without license key
          // The license resolution logic will try to find it
          return {
            authenticated: true,
            user: {
              id: userData.id,
              display_name: userData.name,
              roles: userData.roles
            }
          };
        }
      } catch (error) {
        console.log('WordPress REST API fallback failed:', error);
      }
      
      console.log('No valid session found, returning unauthenticated');
      return { authenticated: false };
    }

    async function attemptLogin(username, password) {
      // Use VL Client authentication endpoint instead of WordPress login
      // This authenticates using VL Client email + password, not WP Admin credentials
      
      console.log('Attempting VL Client authentication for:', username);
      // SECURITY: Never log credentials or payload containing password

      const response = await fetch(buildEndpoint("/wp-json/vl-hub/v1/vl-client-auth"), {
        method: "POST",
        credentials: "include",
        headers: { 
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          email: username, // Username should be the VL Client email
          password: password
        }),
      });

      console.log('VL Client auth response status:', response.status);

      if (!response.ok) {
        const networkError = new Error(`Authentication failed with status ${response.status}`);
        networkError.code = "network";
        throw networkError;
      }

      const authData = await response.json();
      console.log('VL Client auth response:', authData);
      
      if (!authData || authData.authenticated !== true) {
        const message = authData && authData.error ? authData.error : "Invalid email or password.";
        const authError = new Error(message);
        authError.code = "login_failed";
        authError.userMessage = message;
        throw authError;
      }

      console.log('VL Client authentication successful');
      return { ok: true, license_key: authData.license_key };
    }

    function showStatus(message, type = "info") {
      if (!statusEl) {
        return;
      }
      statusEl.dataset.state = type;
      statusEl.textContent = message;
      statusEl.classList.remove("is-visible");
      requestAnimationFrame(() => {
        statusEl.classList.add("is-visible");
      });
    }

    function clearStatus() {
      if (statusEl) {
        statusEl.classList.remove("is-visible");
        statusEl.textContent = "";
      }
    }

    function setBusy(isBusy) {
      root.classList.toggle("is-busy", Boolean(isBusy));
      submitButton.disabled = Boolean(isBusy);
      inputs.forEach((input) => {
        input.disabled = Boolean(isBusy);
      });
    }

    function persistLicense(value) {
      const sanitized = sanitizeLicenseValue(value);
      if (!sanitized) {
        return;
      }

      try {
        window.localStorage.setItem(licenseStorageKey, sanitized);
      } catch (error) {
        // Ignore storage exceptions.
      }
    }

    function storedLicense() {
      try {
        const stored = window.localStorage.getItem(licenseStorageKey);
        const sanitized = sanitizeLicenseValue(stored);
        if (sanitized && stored && sanitized !== stored) {
          window.localStorage.setItem(licenseStorageKey, sanitized);
        }
        return sanitized;
      } catch (error) {
        return "";
      }
    }

    function captureLicenseHintFromUrl() {
      if (typeof window === "undefined") {
        return "";
      }

      const params = new URLSearchParams(window.location.search);
      const extracted = extractLicenseFromParams(params);
      if (extracted) {
        try {
          persistLicense(extracted);
        } catch (error) {
          // Ignore storage issues.
        }
      }
      return extracted;
    }

    const initialLicenseHint = captureLicenseHintFromUrl();

    function redirectToSupercluster(license) {
      const SANDBOX_HOST = "supercluster.visiblelight.ai";

      let target;
      if (/^https?:\/\//i.test(superclusterPath)) {
        // superclusterPath is absolute (and now preserved by normalizePath)
        target = new URL(superclusterPath);
      } else {
        // Relative fallback: force the correct subdomain
        target = new URL(superclusterPath.replace(/^\//, ""), `https://${SANDBOX_HOST}/`);
      }

      const sanitized = sanitizeLicenseValue(license);
      if (sanitized) target.searchParams.set("license", sanitized);
      target.searchParams.set("from", "vl-client-login");

      // As a final guardrail, ensure host is the subdomain
      if (target.hostname !== SANDBOX_HOST) {
        target = new URL(target.pathname + target.search, `https://${SANDBOX_HOST}`);
      }

      window.location.href = target.toString();
    }

    async function handleAuthenticatedSession(session, providedLicense) {
      console.log('Handling authenticated session:', session);
      
      if (!session || session.authenticated !== true) {
        console.log('Session not authenticated');
        return { status: "unauthenticated" };
      }

      // No role check - if user is authenticated and has a license key, allow access
      // WordPress admins with VL license keys should be able to access Supercluster

      showStatus("Verifying your Visible Light access…", "info");

      const sanitizedProvided = sanitizeLicenseValue(providedLicense);
      const additionalHints = gatherAdditionalLicenseHints(sanitizedProvided);
      const licenseToUse = resolveLicenseFromSession(session, sanitizedProvided, additionalHints);

      console.log('License resolution:', {
        providedLicense: sanitizedProvided,
        additionalHints: additionalHints,
        licenseToUse: licenseToUse,
        sessionKeys: Object.keys(session),
        sessionWpActivationKey: session.wp_activation_key,
        sessionLicenseKey: session.license_key
      });

      if (!licenseToUse) {
        setBusy(false);
        showStatus(
          "We couldn't find an active Visible Light license for this account. Please sync your client profile and try again.",
          "error"
        );
        return { status: "license-missing" };
      }

      persistLicense(licenseToUse);
      showStatus("Success! Connecting to your Supercluster…", "success");
      
      // Check if we're already on the subdomain
      if (window.location.hostname === 'supercluster.visiblelight.ai') {
        console.log('Already on subdomain, no redirect needed');
        return { status: "success", license: licenseToUse };
      }
      
      setTimeout(() => {
        redirectToSupercluster(licenseToUse);
      }, 900);
      return { status: "success", license: licenseToUse };
    }

    // Removed hydrateExistingSession() - users must manually log in every time
    // No automatic session checking on page load

    // Prevent any form submission that might bypass our handler
    form.addEventListener("submit", function(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      return false;
    }, true); // Use capture phase to catch it early

    form.addEventListener("submit", async (event) => {
      // CRITICAL SECURITY: Always prevent default form submission to avoid credentials in URL
      event.preventDefault();
      event.stopPropagation();
      event.stopImmediatePropagation();
      
      clearStatus();

      const username = usernameField.value.trim();
      const password = passwordField.value;

      if (!username) {
        showStatus("Enter your username to continue.", "error");
        usernameField.focus();
        return;
      }
      if (!password) {
        showStatus("Enter your password to continue.", "error");
        passwordField.focus();
        return;
      }

      // Only prime session when form is actually submitted
      await primeLoginSession();

      // Clear any stored licenses to ensure we get the correct one from the user's account
      try {
        window.localStorage.removeItem(licenseStorageKey);
      } catch (e) {
        console.warn('Could not clear stored license:', e);
      }

      try {
        setBusy(true);
        showStatus("Authenticating your Visible Light account…", "info");
        await attemptLogin(username, password);
      } catch (error) {
        setBusy(false);
        if (error) {
          if (error.code === "login_failed") {
            showStatus(error.userMessage || "Your username or password is incorrect. Please try again.", "error");
          } else {
            showStatus("We couldn't reach the login service. Try again in a moment.", "error");
          }
        } else {
          showStatus("We couldn't reach the login service. Try again in a moment.", "error");
        }
        return;
      }

          // Wait a moment for the session to be established
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Fetch session info to get license key (VL Client auth already returned it)
          let session = await fetchSessionInfo();
          console.log('Session after VL Client auth:', session);
          
          if (!session || session.authenticated !== true) {
            setBusy(false);
            showStatus("Authentication failed. Please check your credentials and try again.", "error");
            return;
          }
          
          // Use license key from session (VL Client auth endpoint already provides it)
          const outcome = await handleAuthenticatedSession(session, "");
          console.log('Session outcome:', outcome);
          
          if (!outcome || outcome.status === "unauthenticated" || outcome.status === "forbidden") {
            setBusy(false);
            if (outcome && outcome.status === "license-missing") {
              showStatus("We couldn't find an active Visible Light license for this account. Please sync your client profile and try again.", "error");
            } else {
              showStatus("Authentication failed. Please check your credentials and try again.", "error");
            }
          }
    });

    // Only prime login session when form is submitted, not on page load
    // Users must manually enter credentials every time
  }
</script>
<!-- /wp:html -->