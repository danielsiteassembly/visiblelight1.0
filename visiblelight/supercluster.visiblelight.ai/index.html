<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visible Light AI Supercluster</title>
    <link rel="stylesheet" type="text/css" href="https://supercluster.visiblelight.ai/styles.css" />
</head>
<body>
    <div
        id="vlSuperclusterRoot"
        class="vl-supercluster-root vl-supercluster"
        data-login-path="/supercluster-ai-constellation-login/"
        style="background:#000000 !important;"
    >


        <!-- Visible Light Supercluster Overlay -->
        <div class="vl-supercluster-overlay">
            <!-- Top Left: Logo and Client Info -->
            <div class="vl-header">
                <div class="vl-logo">
                    <img src="https://visiblelight.ai/wp-content/uploads/2025/10/visible-light-icon-logo.svg" alt="Visible Light Icon Logo" />
                </div>
                <div class="vl-client-greeting">
                    <h2>Hello, <span id="clientName">Client</span><span class="dropdown-arrow" id="clientDropdownArrow" style="cursor: pointer; display: inline-block;"><img src="https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg" alt="dropdown arrow" style="pointer-events: auto;"></span></h2>
                </div>
            </div>

            <!-- Main Navigation Menu -->
            <nav class="vl-main-menu">
                <ul>
                    <li class="active">
                        <a href="#" data-section="supercluster">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-loader.svg" alt="Supercluster Icon" /></span>
                            <span class="label">Supercluster</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="web-infra">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/web-and-infra-icon.svg" alt="Web & Infra Icon" /></span>
                            <span class="label">Web & Infra</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="content">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/content-manegement-and-structure-icon.svg" alt="content icon" /></span>
                            <span class="label">Content</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="search-intel">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-search-icon-1.svg" alt="search intel icon" /></span>
                            <span class="label">Search Intel</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="reporting">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-reporting-icon.svg" alt="reporting icon" /></span>
                            <span class="label">Reporting</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="marketing-ads">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/web-infra-icon-2.svg" alt="marketing and campaigns icon" /></span>
                            <span class="label">Marketing & Ads</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="ecommerce">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/e-commerce-icon.svg" alt="e-commerce and conversions icon" /></span>
                            <span class="label">Sales & Conversions</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="security-compliance">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/security-icon.svg" alt="security and compliance icon" /></span>
                            <span class="label">Security</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="cloudops">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/cloudops-icon.svg" alt="cloudops icon" /></span>
                            <span class="label">CloudOps</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="user-identity">
                            <span class="icon"><img width="49" height="46" decoding="async" src="https://visiblelight.ai/wp-content/uploads/2025/07/seamless-collaboration-icon.svg" alt="user identity icon" class="wp-image-541" style="aspect-ratio:1.0606060606060606;object-fit:cover;width:35px;height:auto"></span>
                            <span class="label">Users & Identity</span>
                        </a>
                    </li>
                    <li>
                        <a href="#" data-section="competitive">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/competitive-icon.svg" alt="competitive icon" /></span>
                            <span class="label">Competitive</span>
                        </a>
                    </li>
                </ul>
            </nav>

            <!-- Bottom Left: License Key, Connection Status and Luna Chat -->
            <div class="vl-bottom-left">
                <div class="vl-license-key">
                    <div class="license-label">License Key</div>
                    <div class="license-container" id="licenseKeyContainer">
                        <span class="license-value" id="licenseKeyDisplay">Loading...</span>
                        <button class="copy-license-btn" id="copyLicenseBtn" title="Copy full license key">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="vl-connection-status" style="display: none;">
                    <div class="status-indicator">
                        <span class="status-icon" id="connectionIcon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/checkmark.svg" alt="check mark" /></span>
                    </div>
                    <div class="status-text">
                        <p><span class="status-label">Hub Status: </span>
                        <span class="status-value" id="connectionStatus">Active</span></p>
                    </div>
                </div>
                <!-- Luna Chat Widget will be injected here if plugin is installed and licensed -->
                <div class="vl-luna-chat" id="vlLunaChatContainer"></div>
            </div>

            <!-- Bottom Right: Controls -->
            <div class="vl-controls">
                <button class="control-btn" id="controlLeft" title="Move Left">
                    <span class="icon">←</span>
                </button>
                <button class="control-btn" id="controlRight" title="Move Right">
                    <span class="icon">→</span>
                </button>
                <button class="control-btn" id="controlZoomIn" title="Zoom In">
                    <span class="icon">+</span>
                </button>
                <button class="control-btn" id="controlZoomOut" title="Zoom Out">
                    <span class="icon">−</span>
                </button>
            </div>

            <!-- Right Sidebar: Your Supercluster + Recent Activity -->
            <aside class="vl-right-sidebar">
                <div class="vl-widget vl-widget-supercluster" id="yourSuperclusterWidget">
                    <div class="vl-widget-header">
                        <h3>Omniscient</h3>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span class="vl-status-icon-wrap" title="VL Hub Status">
                            <img id="superclusterStatusIcon" src="https://visiblelight.ai/wp-content/uploads/2025/10/checkmark.svg" alt="Connected" />
                        </span>
                            <button class="vl-widget-toggle" data-widget="yourSuperclusterWidget" aria-label="Hide widget">
                                <img src="https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg" alt="Hide" class="vl-toggle-icon" />
                            </button>
                        </div>
                    </div>
                    <div class="vl-widget-body">
                        <p id="superclusterSummary">Loading your Observatory…</p>
                    </div>
                </div>

                <div class="vl-widget vl-widget-activity" id="recentActivityWidget">
                    <div class="vl-widget-header">
                        <h3>Stream Activity</h3>
                        <button class="vl-widget-toggle" data-widget="recentActivityWidget" aria-label="Hide widget">
                            <img src="https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg" alt="Hide" class="vl-toggle-icon" />
                        </button>
                    </div>
                    <div class="vl-widget-body">
                        <ul id="recentActivityList" class="vl-activity-list">
                            <li class="vl-activity-empty">No recent activity.</li>
                        </ul>
                    </div>
                </div>
            </aside>

            <!-- Page Content Container (for category/stream pages) -->
            <div class="vl-page-content" id="vlPageContent" style="display: none;">
                <!-- Category/Stream content will be inserted here -->
            </div>
        </div>

        <!-- Client Dropdown Lightbox -->
        <div class="client-dropdown-lightbox" id="clientDropdownLightbox" style="display: none; position: fixed; z-index: 10000; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
            <div class="client-dropdown-content" id="clientDropdownContent" style="pointer-events: auto; position: absolute; background: #fff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 8px 0; min-width: 150px;">
                <div class="client-dropdown-item" id="accountSettings" style="cursor: pointer; padding: 10px 15px;">
                    <span class="dropdown-text">Account Settings</span>
                </div>
                <div class="client-dropdown-item" id="logoutOption" style="cursor: pointer; padding: 10px 15px;">
                    <span class="dropdown-text">Log Out</span>
                </div>
            </div>
        </div>

        <!-- Logout Confirmation Modal -->
        <div class="logout-modal" id="logoutModal" style="display: none; position: fixed; z-index: 10001; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); pointer-events: auto;">
            <div class="logout-modal-content" style="pointer-events: auto;">
                <h3>Log Out</h3>
                <p>Are you sure you want to log out of Visible Light?</p>
                <div class="logout-modal-buttons">
                    <button class="logout-cancel" id="logoutCancel">No, stay logged in</button>
                    <button class="logout-confirm" id="logoutConfirm">Yes, log out now</button>
                </div>
            </div>
        </div>

        <!-- Tutorial Overlay -->
        <div class="tutorial-overlay" id="tutorialOverlay" style="display: none;">
            <div class="tutorial-backdrop" id="tutorialBackdrop"></div>
            <div class="tutorial-highlight" id="tutorialHighlight"></div>
            <div class="tutorial-content" id="tutorialContent">
                <button class="tutorial-close" id="tutorialClose" title="Close Tutorial">×</button>
                <div class="tutorial-step-content" id="tutorialStepContent">
                    <!-- Step content will be inserted here -->
                </div>
                <div class="tutorial-options" id="tutorialOptions" style="display: none;">
                    <label>
                        <input type="checkbox" id="tutorialNeverShow">
                        <span id="tutorialNeverShowLabel">Never show this tutorial again</span>
                    </label>
                </div>
                <div class="tutorial-navigation">
                    <button class="tutorial-btn tutorial-prev" id="tutorialPrev" style="display: none;">Previous</button>
                    <div class="tutorial-progress" id="tutorialProgress"></div>
                    <button class="tutorial-btn tutorial-next" id="tutorialNext">Next</button>
                </div>
            </div>
        </div>

    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
                "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

        // CRITICAL SECURITY: Verify authentication before allowing dashboard access
        const LOGIN_PAGE_URL = 'https://visiblelight.ai/auth/';
        
        // Check if we're on the Omniscient App Observatory page
        const currentParams = new URLSearchParams(window.location.search);
        const currentLicense = currentParams.get('license') || '';
        const isOmniscientPage = currentLicense.includes('/omniscient-app-observatory/');
        const isLunaComposePage = currentLicense.includes('/luna-compose') || currentLicense.includes('/luna/compose/');
        const isLunaReportPage = currentLicense.includes('/luna/report/');
        const isLunaAutomatePage = currentLicense.includes('/luna/automate/');
        
        // Check if we're on a shared document page (invite_from)
        const currentPath = window.location.pathname;
        const isSharedComposePage = currentPath.includes('/invite_from/luna/compose/');
        let sharedDocumentId = null;
        if (isSharedComposePage) {
            const match = currentPath.match(/\/invite_from\/luna\/compose\/([^\/]+)/);
            if (match && match[1]) {
                sharedDocumentId = match[1];
            }
        }
        
        // Only load the loading animation script on the main Supercluster dashboard page
        // NOT on internal pages like /luna/compose/, /luna/report/, /luna/automate/, or /omniscient-app-observatory/
        const isMainDashboardPage = !isOmniscientPage && !isLunaComposePage && !isLunaReportPage && !isLunaAutomatePage;
        
        if (isMainDashboardPage) {
            const script = document.createElement('script');
            script.src = 'https://supercluster.visiblelight.ai/assets/js/supercluster-load-animation.js';
            script.async = true;
            document.head.appendChild(script);
        }
        
        // Helper function to hide/remove galaxy labels
        // Only hides labels on internal pages (stream pages, category pages, etc.), NOT on main dashboard
        function hideSuperclusterLabels() {
            // Check if we're on the main Supercluster dashboard page
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            const currentPath = window.location.pathname;
            
            // Check if we're on an internal page (stream page, category page, etc.)
            const isStreamPage = currentLicense.includes('/content/data-stream/') || currentPath.includes('/content/data-stream/');
            const isCategoryPage = currentLicense.includes('/content/category/') || currentPath.includes('/content/category/');
            const isOmniscientPage = currentLicense.includes('/omniscient-app-observatory/');
            const isLunaComposePage = currentLicense.includes('/luna-compose') || currentLicense.includes('/luna/compose/');
            const isLunaReportPage = currentLicense.includes('/luna/report/');
            const isLunaAutomatePage = currentLicense.includes('/luna/automate/');
            
            // If we're on the main dashboard page, DON'T hide the labels
            const isMainDashboardPage = !isStreamPage && !isCategoryPage && !isOmniscientPage && 
                                       !isLunaComposePage && !isLunaReportPage && !isLunaAutomatePage;
            
            if (isMainDashboardPage) {
                // On main dashboard, ensure labels are visible
                const labelsContainer = document.querySelector('.vl-supercluster-labels');
                if (labelsContainer) {
                    labelsContainer.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                return; // Don't hide labels on main dashboard
            }
            
            // On internal pages, hide/remove the labels
            const labelsContainer = document.querySelector('.vl-supercluster-labels');
            if (labelsContainer) {
                labelsContainer.remove();
            }
        }
        
        // Helper function to hide only the Three.js canvas while keeping the container visible
        // Only hides canvas on internal pages (stream pages, category pages, etc.), NOT on main dashboard
        function hideThreeJSCanvas() {
            // Check if we're on the main Supercluster dashboard page
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            const currentPath = window.location.pathname;
            
            // Check if we're on an internal page (stream page, category page, etc.)
            const isStreamPage = currentLicense.includes('/content/data-stream/') || currentPath.includes('/content/data-stream/');
            const isCategoryPage = currentLicense.includes('/content/category/') || currentPath.includes('/content/category/');
            const isOmniscientPage = currentLicense.includes('/omniscient-app-observatory/');
            const isLunaComposePage = currentLicense.includes('/luna-compose') || currentLicense.includes('/luna/compose/');
            const isLunaReportPage = currentLicense.includes('/luna/report/');
            const isLunaAutomatePage = currentLicense.includes('/luna/automate/');
            
            // If we're on the main dashboard page, DON'T hide the canvas
            const isMainDashboardPage = !isStreamPage && !isCategoryPage && !isOmniscientPage && 
                                       !isLunaComposePage && !isLunaReportPage && !isLunaAutomatePage;
            
            if (isMainDashboardPage) {
                // On main dashboard, ensure canvas is visible
            const rootContainer = document.getElementById('vlSuperclusterRoot');
            if (rootContainer) {
                    const canvasElements = rootContainer.querySelectorAll('canvas');
                    canvasElements.forEach(canvas => {
                        const isThreeJSCanvas = canvas.getAttribute('data-engine') === 'three.js r180' || 
                                               canvas.getAttribute('data-engine')?.includes('three.js') ||
                                               (!canvas.getAttribute('data-engine') && canvasElements.length === 1);
                        if (isThreeJSCanvas) {
                            // Ensure canvas is visible on main dashboard
                            canvas.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; z-index: auto !important;';
                        }
                    });
                }
                return; // Don't hide canvas on main dashboard
            }
            
            // On internal pages, hide the canvas
            const rootContainer = document.getElementById('vlSuperclusterRoot');
            if (rootContainer) {
                // Keep the container visible
                rootContainer.style.setProperty('display', 'block', 'important');
                rootContainer.style.setProperty('visibility', 'visible', 'important');
                rootContainer.style.setProperty('opacity', '1', 'important');
                rootContainer.style.setProperty('pointer-events', 'auto', 'important');
                
                // Hide only the canvas element(s) inside the container
                const canvasElements = rootContainer.querySelectorAll('canvas');
                canvasElements.forEach(canvas => {
                    // Check if it's the Three.js canvas (has data-engine="three.js r180" or is the main canvas)
                    const isThreeJSCanvas = canvas.getAttribute('data-engine') === 'three.js r180' || 
                                           canvas.getAttribute('data-engine')?.includes('three.js') ||
                                           (!canvas.getAttribute('data-engine') && canvasElements.length === 1); // If only one canvas, assume it's Three.js
                    if (isThreeJSCanvas) {
                        canvas.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important; z-index: -1 !important;';
                    }
                });
            }
        }
        
        // Render Omniscient App Observatory page
        async function renderOmniscientAppObservatory() {
            console.log('[Omniscient App Observatory] Rendering page...');
            
            // CRITICAL: Neutralize the Supercluster visualization canvas immediately
            hideThreeJSCanvas();
            
            // Ensure body background is transparent, not black
            document.body.style.cssText = 'background: transparent !important; background-color: transparent !important;';
            
            // Ensure overlays and menus remain visible
            const overlay = document.querySelector('.vl-supercluster-overlay');
            const header = document.querySelector('.vl-header');
            const mainMenu = document.querySelector('.vl-main-menu');
            const rightSidebar = document.querySelector('.vl-right-sidebar');
            
            if (overlay) {
                overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (header) {
                header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (mainMenu) {
                mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (rightSidebar) {
                rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            
            // Show the page content container
            const pageContent = document.getElementById('vlPageContent');
            if (!pageContent) {
                console.error('[Omniscient App Observatory] Page content element not found!');
                return;
            }
            
            const escapeAttr = (value) => {
                if (value === undefined || value === null) {
                    return '';
                }
                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
            };

            const resolveObservatoryImage = (site) => {
                if (!site || typeof site !== 'object') {
                    return '';
                }

                const candidates = [];
                const pushCandidate = (candidate) => {
                    if (!candidate) {
                        return;
                    }
                    if (Array.isArray(candidate)) {
                        candidate.forEach(pushCandidate);
                        return;
                    }
                    if (typeof candidate === 'string') {
                        const trimmed = candidate.trim();
                        if (trimmed !== '') {
                            candidates.push(trimmed);
                        }
                    }
                };

                pushCandidate(site.og_image);
                pushCandidate(site.ogImage);
                pushCandidate(site.og_image_url);
                pushCandidate(site.ogImageUrl);
                pushCandidate(site.open_graph_image);
                pushCandidate(site.openGraphImage);
                pushCandidate(site.opengraph_image);
                pushCandidate(site.social_image);
                pushCandidate(site.socialImage);
                pushCandidate(site.image);
                pushCandidate(site.preview_image);
                pushCandidate(site.screenshot);

                if (site.opengraph && typeof site.opengraph === 'object') {
                    pushCandidate(site.opengraph.image);
                    pushCandidate(site.opengraph.og_image);
                    pushCandidate(site.opengraph.images);
                }

                if (site.social && typeof site.social === 'object') {
                    pushCandidate(site.social.image);
                    if (site.social.opengraph && typeof site.social.opengraph === 'object') {
                        pushCandidate(site.social.opengraph.image);
                    }
                }

                if (site.meta && typeof site.meta === 'object') {
                    pushCandidate(site.meta.og_image);
                    pushCandidate(site.meta.ogImage);
                }

                if (site.meta_tags && typeof site.meta_tags === 'object') {
                    pushCandidate(site.meta_tags['og:image']);
                    pushCandidate(site.meta_tags['og_image']);
                }

                const unique = candidates.filter((value, index, array) => array.indexOf(value) === index);
                return unique.length > 0 ? unique[0] : '';
            };
            
            // Get license key from URL
            const urlParams = new URLSearchParams(window.location.search);
            const urlLicense = urlParams.get('license') || '';
            let licenseKey = '';
            if (urlLicense) {
                const licenseMatch = urlLicense.match(/^([^/]+)/);
                if (licenseMatch) {
                    licenseKey = licenseMatch[1];
                } else {
                    licenseKey = urlLicense;
                }
            }
            
            if (!licenseKey) {
                pageContent.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>License key not found.</p></div>';
                return;
            }
            
            try {
                console.log('[Omniscient App Observatory] Fetching sites for license:', licenseKey);
                
                // Fetch all sites for this client
                const response = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/client-sites?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                console.log('[Omniscient App Observatory] Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[Omniscient App Observatory] API error:', response.status, errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('[Omniscient App Observatory] Response data:', data);
                
                if (!data.ok) {
                    throw new Error(data.error || 'Invalid response from server');
                }
                
                const sites = data.sites || [];
                const rawTotalSites = Number(data.total);
                const totalSites = Number.isFinite(rawTotalSites) ? rawTotalSites : (Array.isArray(sites) ? sites.length : 0);
                const observedLabel = totalSites === 1 ? 'app observed' : 'apps observed';
                
                console.log('[Omniscient App Observatory] Sites found:', totalSites, sites);
                
                // Build HTML with explicit background
                let html = '<div class="omniscient-observatory" style="min-height: 100vh; color: #fff4e9; padding: 40px 0; width: 55%; max-width:100%; margin: 0 auto; position: relative; z-index: 1000;">';
                
                // Header with total count
                html += '<div style="margin-bottom: 30px;">';
                html += '<h1 class="TypeGradient" style="margin-bottom: 10px; font-size: 1.5rem; margin-top:0 !important;">Omniscient App Observatory</h1>';
                html += '<div class="observatory-subtitle" style="color: #9A9793; font-size: 0.875rem; margin: 0 0 20px 0;">' + totalSites + ' ' + observedLabel + '</div>';
                
                // Search and View Toggle
                html += '<div style="display: flex; align-items: center; gap: 20px; margin-bottom: 30px; flex-wrap: wrap;">';
                html += '<div style="flex: 1; min-width: 300px;">';
                html += '<input type="text" id="observatory-search" placeholder="Search sites/apps..." style="width: 100%; padding: 10px 16px; background: rgba(0,0,0,.1); border: 1px solid #1f1d1a; border-radius: 6px; color: #fff4e9; font-size: 0.875rem; outline: none;" />';
                html += '</div>';
                html += '<div style="display: flex; align-items: center; gap: 10px;">';
                html += '<span style="color: #9A9793; font-size: 0.875rem;">View:</span>';
                html += '<button id="view-list-btn" class="view-toggle-btn active" data-view="list" style="padding: 8px 16px; background: #2E2C2A; border: 1px solid #5A575335; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">List</button>';
                html += '<button id="view-block-btn" class="view-toggle-btn" data-view="block" style="padding: 8px 16px; background: #2E2C2A50; border: 1px solid #5A575335; color: #9A9793; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">Block</button>';
                html += '</div>';
                html += '</div>';
                
                // Sites Container
                html += '<div id="observatory-sites-container" class="observatory-list-view" style="display: grid; gap: 20px;">';
                
                if (sites.length === 0) {
                    html += '<div style="text-align: center; padding: 60px 20px; color: #9A9793;"><p>No sites/apps found. Assign sites to this client in WP Admin > VL Clients > VL Hub Profile > Client Syncing.</p></div>';
                } else {
                    sites.forEach((site, index) => {
                        const siteId = 'site-' + index;
                        const ogImageUrl = resolveObservatoryImage(site);
                        const hasOgImage = ogImageUrl !== '';
                        const safeOgImage = escapeAttr(ogImageUrl);
                        const safeImageAlt = escapeAttr(site.title || site.domain || 'Site');
                        const fallbackSharedStyles = 'width: 100%; height: 100%; align-items: center; justify-content: center; color: #9A9793; font-size: 0.75rem;';
                        const fallbackShownStyles = 'display: flex; ' + fallbackSharedStyles;
                        const fallbackHiddenStyles = 'display: none; ' + fallbackSharedStyles;
                        const imageErrorHandler = escapeAttr("this.remove(); const fallback = this.nextElementSibling; if (fallback) { fallback.style.display = 'flex'; }");
                        html += '<div class="observatory-site-item" data-site-url="' + (site.url || '').toLowerCase() + '" data-site-title="' + (site.title || '').toLowerCase() + '" data-site-domain="' + (site.domain || '').toLowerCase() + '" style="background: #000000; border: 1px solid #1f1d1a; border-radius: 8px; padding: 20px; transition: all 0.2s ease; cursor: pointer;" onmouseover="this.style.borderColor=\'#5A5753\';" onmouseout="this.style.borderColor=\'#2E2C2A\';" onclick="window.open(\'' + (site.url || '#') + '\', \'_blank\');">';
                        
                        // Block view layout
                        html += '<div class="observatory-site-block" style="display: grid; grid-template-columns: 120px 1fr auto; gap: 20px; align-items: start;">';
                        
                        // OG Image
                        html += '<div style="width: 120px; height: 120px; background: #2E2C2A; border-radius: 6px; overflow: hidden; flex-shrink: 0;">';
                        if (hasOgImage) {
                            html += '<img src="' + safeOgImage + '" alt="' + safeImageAlt + '" style="width: 100%; height: 100%; object-fit: cover;" onerror="' + imageErrorHandler + '" />';
                            html += '<div class="observatory-no-image" style="' + fallbackHiddenStyles + '">No Image</div>';
                        } else {
                            html += '<div class="observatory-no-image" style="' + fallbackShownStyles + '">No Image</div>';
                        }
                        html += '</div>';
                        
                        // Site Info
                        html += '<div style="flex: 1;">';
                        html += '<h3 style="color: #fff4e9; margin: 0 0 8px 0; font-size: 1.2rem; font-weight: 400;">' + (site.title || site.domain || site.url || 'Untitled Site') + '</h3>';
                        html += '<p style="color: #9A9793; margin: 0 0 12px 0; font-size: 0.875rem; word-break: break-all;">' + (site.url || '') + '</p>';
                        
                        // Status badges
                        html += '<div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 12px;">';
                        
                        // Ping Status
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + (site.ping_color || '#9A9793') + '; color: #fff4e9;">' + (site.ping_label || 'Unknown') + '</span>';
                        
                        // SSL/TLS Status
                        let sslLabel = 'Unknown';
                        let sslColor = '#9A9793';
                        if (site.ssl_status === 'valid') {
                            sslLabel = 'HTTPS';
                            sslColor = '#0F9900';
                        } else if (site.ssl_status === 'expiring_soon') {
                            sslLabel = 'SSL Expiring Soon';
                            sslColor = '#dba617';
                        } else if (site.ssl_status === 'expired') {
                            sslLabel = 'SSL Expired';
                            sslColor = '#d63638';
                        } else if (site.ssl_status === 'not_https') {
                            sslLabel = 'Not HTTPS';
                            sslColor = '#9A9793';
                        }
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + sslColor + '; color: #fff4e9;">' + sslLabel + '</span>';
                        
                        html += '</div>';
                        
                        // New Metrics Section
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-top: 12px; padding-top: 12px; border-top: 1px solid #1f1d1a;">';
                        
                        // Uptime Percentage
                        if (site.uptime_percent !== null && site.uptime_percent !== undefined) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">Uptime (30d)</span>';
                            html += '<span style="color: #fff4e9; font-size: 0.875rem; font-weight: 600;">' + parseFloat(site.uptime_percent).toFixed(1) + '%</span>';
                            html += '</div>';
                        }
                        
                        // Total Visitors (GA4 Active Users)
                        if (site.total_visitors !== null && site.total_visitors !== undefined) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">Total Visitors</span>';
                            html += '<span style="color: #fff4e9; font-size: 0.875rem; font-weight: 600;">' + parseInt(site.total_visitors).toLocaleString() + '</span>';
                            html += '</div>';
                        }
                        
                        // New Visits (GA4 New Users)
                        if (site.new_visits !== null && site.new_visits !== undefined) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">New Visits</span>';
                            html += '<span style="color: #fff4e9; font-size: 0.875rem; font-weight: 600;">' + parseInt(site.new_visits).toLocaleString() + '</span>';
                            html += '</div>';
                        }
                        
                        // WordPress Admin Login URL
                        if (site.wp_admin_url) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">WP Admin</span>';
                            html += '<a href="' + escapeAttr(site.wp_admin_url) + '" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation();" style="color: #58a6ff; font-size: 0.875rem; text-decoration: none; word-break: break-all;">Login →</a>';
                            html += '</div>';
                        }
                        
                        // SEO Score (placeholder)
                        if (site.seo_score !== null && site.seo_score !== undefined) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">SEO Score</span>';
                            html += '<span style="color: #fff4e9; font-size: 0.875rem; font-weight: 600;">' + (site.seo_score !== null ? site.seo_score : 'N/A') + '</span>';
                            html += '</div>';
                        }
                        
                        html += '</div>';
                        html += '</div>';
                        
                        html += '</div>';
                        
                        // List view layout (hidden by default)
                        html += '<div class="observatory-site-list" style="display: none; grid-template-columns: 80px 1fr auto auto auto; gap: 16px; align-items: center;">';
                        html += '<div style="width: 80px; height: 80px; background: #2E2C2A; border-radius: 6px; overflow: hidden; flex-shrink: 0; border: 1px solid #1f1d1a;">';
                        if (hasOgImage) {
                            html += '<img src="' + safeOgImage + '" alt="' + safeImageAlt + '" style="width: 100%; height: 100%; object-fit: cover;" onerror="' + imageErrorHandler + '" />';
                            html += '<div class="observatory-no-image" style="' + fallbackHiddenStyles + '">No Image</div>';
                        } else {
                            html += '<div class="observatory-no-image" style="' + fallbackShownStyles + '">No Image</div>';
                        }
                        html += '</div>';
                        html += '<div style="flex: 1; min-width: 0;">';
                        html += '<h3 style="color: #fff4e9; margin: 0 0 4px 0; font-size: 1rem; font-weight: 400; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (site.title || site.domain || site.url || 'Untitled Site') + '</h3>';
                        html += '<p style="color: #9A9793; margin: 0; font-size: 0.875rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (site.url || '') + '</p>';
                        // Add metrics in list view (compact)
                        html += '<div style="display: flex; gap: 12px; margin-top: 4px; flex-wrap: wrap;">';
                        if (site.uptime_percent !== null && site.uptime_percent !== undefined) {
                            html += '<span style="color: #9A9793; font-size: 0.7rem;">Uptime: <span style="color: #fff4e9;">' + parseFloat(site.uptime_percent).toFixed(1) + '%</span></span>';
                        }
                        if (site.total_visitors !== null && site.total_visitors !== undefined) {
                            html += '<span style="color: #9A9793; font-size: 0.7rem;">Visitors: <span style="color: #fff4e9;">' + parseInt(site.total_visitors).toLocaleString() + '</span></span>';
                        }
                        if (site.new_visits !== null && site.new_visits !== undefined) {
                            html += '<span style="color: #9A9793; font-size: 0.7rem;">New: <span style="color: #fff4e9;">' + parseInt(site.new_visits).toLocaleString() + '</span></span>';
                        }
                        if (site.wp_admin_url) {
                            html += '<a href="' + escapeAttr(site.wp_admin_url) + '" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation();" style="color: #58a6ff; font-size: 0.7rem; text-decoration: none;">WP Admin →</a>';
                        }
                        html += '</div>';
                        html += '</div>';
                        html += '<div style="display: flex; gap: 8px; flex-direction: column;">';
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + (site.ping_color || '#9A9793') + '; color: #fff4e9;">' + (site.ping_label || 'Unknown') + '</span>';
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + sslColor + '; color: #fff4e9;">' + sslLabel + '</span>';
                        html += '</div>';
                        html += '</div>';
                        
                        html += '</div>';
                    });
                }
                
                html += '</div>';
                html += '</div>';
                
                // Add CSS
                html += '<style>';
                html += '.observatory-list-view .observatory-site-item > .observatory-site-list { display: grid !important; }';
                html += '.observatory-list-view .observatory-site-item > .observatory-site-block { display: none !important; }';
                html += '.observatory-block-view .observatory-site-item > .observatory-site-block { display: grid !important; }';
                html += '.observatory-block-view .observatory-site-item > .observatory-site-list { display: none !important; }';
                html += '.view-toggle-btn.active { background: linear-gradient(90deg, #1f1d1a 0%, #974C00 75.51%) !important; color: #fff4e9 !important; border:none !important;}';
                html += '.view-toggle-btn:not(.active) { background: #2E2C2A50 !important; color: #9A9793 !important; }';
                html += '</style>';
                
                pageContent.innerHTML = html;
                
                // CRITICAL: Force page content to be visible with !important styles
                pageContent.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 1000 !important; background: #000000 !important; min-height: 100vh !important;';
                
                // Ensure body and html background doesn't cover content
                document.body.style.cssText = 'background: transparent !important; background-color: transparent !important;';
                if (document.documentElement) {
                    document.documentElement.style.cssText = 'background: transparent !important; background-color: transparent !important;';
                }
                
                // Keep the Supercluster container visible while suppressing only the Three.js canvas
                hideThreeJSCanvas();
                
                // Force overlays to remain visible
                const overlay = document.querySelector('.vl-supercluster-overlay');
                const header = document.querySelector('.vl-header');
                const mainMenu = document.querySelector('.vl-main-menu');
                const rightSidebar = document.querySelector('.vl-right-sidebar');
                
                if (overlay) {
                    overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                if (header) {
                    header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                if (mainMenu) {
                    mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                if (rightSidebar) {
                    rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                
                // Use MutationObserver to prevent content from being hidden
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                            const target = mutation.target;
                            if (target === pageContent) {
                                const display = window.getComputedStyle(target).display;
                                if (display === 'none') {
                                    console.warn('[Omniscient] Page content was hidden, forcing it visible');
                                    target.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                                }
                            }
                        }
                    });
                });
                
                observer.observe(pageContent, {
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
                
                // Also set up periodic checks to ensure content stays visible
                const visibilityCheck = setInterval(() => {
                    const computedDisplay = window.getComputedStyle(pageContent).display;
                    if (pageContent.style.display === 'none' || computedDisplay === 'none') {
                        console.warn('[Omniscient] Page content hidden, restoring visibility');
                        pageContent.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 1000 !important; background: transparent !important;';
                    }
                    
                    // Ensure the Supercluster container remains visible for UI elements
                    if (rootContainer) {
                        const rootDisplay = window.getComputedStyle(rootContainer).display;
                        if (rootDisplay === 'none') {
                            rootContainer.style.setProperty('display', 'block', 'important');
                            rootContainer.style.setProperty('visibility', 'visible', 'important');
                            rootContainer.style.setProperty('opacity', '1', 'important');
                            rootContainer.style.setProperty('pointer-events', 'auto', 'important');
                        }
                    }
                    
                    // Ensure canvas stays hidden
                    const canvasElements = document.querySelectorAll('canvas');
                    canvasElements.forEach(canvas => {
                        const canvasDisplay = window.getComputedStyle(canvas).display;
                        if (canvasDisplay !== 'none') {
                            canvas.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important; z-index: -1 !important;';
                        }
                    });
                    
                    // Ensure body/html backgrounds stay transparent
                    const bodyBg = window.getComputedStyle(document.body).backgroundColor;
                    if (bodyBg && bodyBg !== 'transparent' && bodyBg !== 'rgba(0, 0, 0, 0)') {
                        document.body.style.cssText = 'background: transparent !important; background-color: transparent !important;';
                    }
                }, 500);
                
                // Store interval ID for cleanup if needed
                window.omniscientVisibilityCheck = visibilityCheck;
                
                // Initialize search and view toggle
                const searchInput = document.getElementById('observatory-search');
                const viewListBtn = document.getElementById('view-list-btn');
                const viewBlockBtn = document.getElementById('view-block-btn');
                const sitesContainer = document.getElementById('observatory-sites-container');
                
                // Search functionality
                if (searchInput) {
                    searchInput.addEventListener('input', function(e) {
                        const searchTerm = e.target.value.toLowerCase().trim();
                        const siteItems = document.querySelectorAll('.observatory-site-item');
                        
                        siteItems.forEach(item => {
                            const url = item.getAttribute('data-site-url') || '';
                            const title = item.getAttribute('data-site-title') || '';
                            const domain = item.getAttribute('data-site-domain') || '';
                            
                            if (!searchTerm || url.includes(searchTerm) || title.includes(searchTerm) || domain.includes(searchTerm)) {
                                item.style.display = '';
                            } else {
                                item.style.display = 'none';
                            }
                        });
                    });
                }
                
                // View toggle functionality
                if (viewListBtn && viewBlockBtn && sitesContainer) {
                    viewListBtn.addEventListener('click', function() {
                        sitesContainer.className = 'observatory-list-view';
                        viewListBtn.classList.add('active');
                        viewBlockBtn.classList.remove('active');
                    });
                    
                    viewBlockBtn.addEventListener('click', function() {
                        sitesContainer.className = 'observatory-block-view';
                        viewBlockBtn.classList.add('active');
                        viewListBtn.classList.remove('active');
                    });
                }
                
            } catch (error) {
                console.error('[Omniscient App Observatory] Error rendering:', error);
                pageContent.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load Omniscient App Observatory: ' + error.message + '</p></div>';
            }
        }
        
        // Render shared Luna Composer page (public access without license key)
        // Define this function early so it can be called for shared documents
        async function renderSharedLunaComposer(shareId) {
            try {
                console.log('[Luna Composer] Rendering shared document:', shareId);
                
                // Fetch shared document from WordPress
                let docData = null;
                try {
                    const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/shared?share_id=${encodeURIComponent(shareId)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.document) {
                            docData = data.document;
                            console.log('[Luna Composer] Shared document loaded:', docData);
                        } else {
                            console.error('[Luna Composer] Document not found');
                            const pageContentEl = document.getElementById('vlPageContent');
                            if (pageContentEl) {
                                pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Document Not Found</h1><p>The shared document could not be found or has been removed.</p></div>';
                            }
                            return;
                        }
                    } else {
                        console.error('[Luna Composer] Failed to load shared document:', response.status);
                        const pageContentEl = document.getElementById('vlPageContent');
                        if (pageContentEl) {
                            pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document.</p></div>';
                        }
                        return;
                    }
                } catch (e) {
                    console.error('[Luna Composer] Error loading shared document:', e);
                    const pageContentEl = document.getElementById('vlPageContent');
                    if (pageContentEl) {
                        pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document.</p></div>';
                    }
                    return;
                }
                
                // Hide only the Three.js canvas, keep container visible
                hideThreeJSCanvas();
                
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.style.display = 'block';
                }
                
                // Remove three.js and other Supercluster elements
                const controls = document.querySelector('.vl-controls');
                if (controls) controls.remove();
                // Use helper function to hide labels (only hides on internal pages)
                hideSuperclusterLabels();
                const canvas = document.querySelector('canvas');
                if (canvas) canvas.style.display = 'none';
                
                // Build shared document viewer (read-only)
                let html = '<style>@media (min-width: 991px) { .luna-composer-page { max-width: 55% !important; } }</style>';
                html += '<div class="luna-composer-page" style="min-height: 100vh; background: transparent; color: #fff4e9; padding: 40px 0; max-width: 1200px; margin: 0 auto; position: relative; z-index: 2;">';
                html += '<div class="luna-composer__editor" style="margin-bottom: 0; min-width: 100%;">';
                html += '<h1 class="TypeGradient" style="margin-bottom: 20px; font-size: 1.5rem; margin-top: 0;">Shared Document</h1>';
                html += '<div id="luna-composer-shared-editor" style="min-height: 400px; padding: 20px; background: #000; border: 1px solid #1f1d1a; border-radius: 8px; color: #fff4e9; font-size: 1rem; line-height: 1.6;">';
                html += docData.content || '<p>No content available.</p>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    pageContentEl.innerHTML = html;
                    pageContentEl.style.display = 'block';
                }
            } catch (error) {
                console.error('[Luna Composer] Error rendering shared document:', error);
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document: ' + error.message + '</p></div>';
                }
            }
        }
        
        // Authentication check function
        async function verifyAuthenticationAndLicense() {
            try {
                // First, verify user is authenticated by checking VL Hub session
                // Include license in session check to allow cookie-less fallback
                const sessionUrl = new URL('https://visiblelight.ai/wp-json/vl-hub/v1/session');
                const currentParams = new URLSearchParams(window.location.search);
                const currentUrlLicenseParam = currentParams.get('license');
                
                // Extract just the license key (before first /) if URL contains path segments
                let extractedLicenseKey = '';
                if (currentUrlLicenseParam) {
                    // Check if license param contains path segments (e.g., "VL-XXX/category/data-stream/...")
                    const licenseMatch = currentUrlLicenseParam.match(/^([^/]+)/);
                    if (licenseMatch) {
                        extractedLicenseKey = licenseMatch[1];
                    } else {
                        extractedLicenseKey = currentUrlLicenseParam;
                    }
                }
                
                // Send only the license key (not the full path) to the session endpoint
                if (extractedLicenseKey) {
                    sessionUrl.searchParams.set('license', extractedLicenseKey);
                }

                const sessionResponse = await fetch(sessionUrl.toString(), {
                    method: 'GET',
                    credentials: 'include', // Send cookies
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (!sessionResponse.ok) {
                    console.log('Session check failed - redirecting to login');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }

                const sessionData = await sessionResponse.json();
                
                if (!sessionData || sessionData.authenticated !== true) {
                    console.log('User not authenticated - redirecting to login');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }
                
                // Get user's actual license key from session
                const userLicenseKey = sessionData.license_key || sessionData.wp_activation_key || '';
                
                console.log('Extracted license key from URL:', extractedLicenseKey);
                console.log('User license key from session:', userLicenseKey);

                // SECURITY: Verify URL license key matches authenticated user's license key
                if (!userLicenseKey) {
                    console.log('No license key found for authenticated user - redirecting to login');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }

                // If URL has a license key, it MUST match the user's actual license key
                // Compare only the extracted license key (not the full path)
                if (extractedLicenseKey && extractedLicenseKey.toUpperCase() !== userLicenseKey.toUpperCase()) {
                    console.error('SECURITY VIOLATION: URL license key does not match authenticated user license key');
                    console.error('URL License:', extractedLicenseKey);
                    console.error('User License:', userLicenseKey);
                    alert('Access denied: License key mismatch. Redirecting to login...');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }

                // Use the authenticated user's license key (not from URL)
                console.log('Authentication verified. Using license key:', userLicenseKey);
                
                // SECURITY: Update URL license parameter only if it doesn't match user's license key
                // But preserve the full path if it exists (for stream data pages)
                const currentUrl = new URL(window.location.href);
                const currentLicenseParam = currentUrl.searchParams.get('license');
                
                // If license param doesn't start with user's license key, update it
                // But preserve path segments if they exist
                if (currentLicenseParam && !currentLicenseParam.startsWith(userLicenseKey)) {
                    // If there's a path after the license key, preserve it
                    const pathMatch = currentLicenseParam.match(/^[^/]+(\/.+)$/);
                    if (pathMatch) {
                        // This shouldn't happen if we extracted correctly, but handle it
                        currentUrl.searchParams.set('license', userLicenseKey + pathMatch[1]);
                    } else {
                    currentUrl.searchParams.set('license', userLicenseKey);
                    }
                    // Update URL without page reload (for security - ensures URL matches user)
                    window.history.replaceState({}, '', currentUrl.toString());
                }
                
                return userLicenseKey;

            } catch (error) {
                console.error('Authentication verification failed:', error);
                window.location.href = LOGIN_PAGE_URL;
                return null;
            }
        }

        // For shared documents, skip authentication and render directly
        if (isSharedComposePage && sharedDocumentId) {
            console.log('[Supercluster] Shared document detected, bypassing authentication');
            // Render shared document without authentication
            async function renderSharedDocumentDirectly() {
                try {
                    // Hide only the Three.js canvas, keep container visible
                    hideThreeJSCanvas();
                    
                    const pageContent = document.getElementById('vlPageContent');
                    if (pageContent) {
                        pageContent.style.display = 'block';
                    }
                    
                    // Remove three.js and other Supercluster elements
                    const controls = document.querySelector('.vl-controls');
                    if (controls) controls.remove();
                    const labelsContainer = document.querySelector('.vl-supercluster-labels');
                    if (labelsContainer) labelsContainer.remove();
                    const canvas = document.querySelector('canvas');
                    if (canvas) canvas.style.display = 'none';
                    
                    // Fetch and render shared document
                    await renderSharedLunaComposer(sharedDocumentId);
                } catch (error) {
                    console.error('[Supercluster] Error rendering shared document:', error);
                    const pageContentEl = document.getElementById('vlPageContent');
                    if (pageContentEl) {
                        pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document: ' + error.message + '</p></div>';
                    }
                }
            }
            
            // Render immediately without authentication
            renderSharedDocumentDirectly();
        } else {
            // Verify authentication BEFORE doing anything else (for non-shared pages)
            var licenseKey = await verifyAuthenticationAndLicense();
        
        if (!licenseKey) {
            // Authentication failed - page will redirect, but prevent further execution
            // Show loading message while redirect happens
            document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#fff4e9;font-family:Inter,sans-serif">Verifying authentication...</div>';
            // Stop execution - user is being redirected
            throw new Error('Authentication required');
        }

        // Data fetching from VL Hub
        let constellationData = null;
        let dataFetchError = null;

        // Inactivity timeout - 1 hour
        let inactivityTimeout = null;
        const INACTIVITY_TIMEOUT_MS = 60 * 60 * 1000; // 1 hour in milliseconds

        // Track user activity and reset timeout
        function resetInactivityTimer() {
            if (inactivityTimeout) {
                clearTimeout(inactivityTimeout);
            }
            
            inactivityTimeout = setTimeout(() => {
                console.log('Inactivity timeout reached - logging out');
                // Clear any stored data
                try {
                    localStorage.removeItem('vl-cms-data');
                    sessionStorage.clear();
                } catch (e) {
                    console.warn('Error clearing storage:', e);
                }
                
                // Redirect to login page (LOGIN_PAGE_URL is defined at top of script)
                window.location.href = LOGIN_PAGE_URL;
            }, INACTIVITY_TIMEOUT_MS);
        }

        // Listen for user activity events
        const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
        activityEvents.forEach(event => {
            document.addEventListener(event, resetInactivityTimer, { passive: true });
        });

        // Initialize inactivity timer on page load
        resetInactivityTimer();

        async function fetchConstellationData() {
            try {
                const endpoint = 'https://visiblelight.ai/wp-json/vl-hub/v1/constellation';
                const url = licenseKey ? `${endpoint}?license=${encodeURIComponent(licenseKey)}` : endpoint;
                
                console.log('Fetching constellation data from:', url);
                
                // Update debug info
                updateDebugInfo(`Fetching: ${url}`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    credentials: 'include', // Send cookies for CORS
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response body:', errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}\nResponse: ${errorText}`);
                }

                const data = await response.json();
                console.log('Constellation data received:', data);
                updateDebugInfo(`Success: ${data.total_clients || 0} clients found`);
                return data;
            } catch (error) {
                console.error('Failed to fetch constellation data:', error);
                dataFetchError = error.message;
                updateDebugInfo(`Error: ${error.message}`);
                return null;
            }
        }

        function updateDebugInfo(message) {
            const debugEl = document.getElementById('debugInfo');
            if (debugEl) {
                const timestamp = new Date().toLocaleTimeString();
                debugEl.innerHTML = `[${timestamp}] ${message}`;
            }
        }

        // Function to update galaxy data with real VL Hub data
        function updateGalaxyDataWithRealData(clientData) {
            console.log('Updating galaxy data with real data:', clientData);
            
            // Check if galaxyData is defined
            if (typeof galaxyData === 'undefined' || !galaxyData || !Array.isArray(galaxyData)) {
                console.warn('[Supercluster] galaxyData not yet initialized, skipping update');
                return;
            }
            
            // Update galaxy data with real metrics
            galaxyData.forEach(galaxy => {
                const matchingCategory = clientData.categories?.find(cat => 
                    galaxy.datasetSlugs.some(slug => 
                        cat.name.toLowerCase().includes(slug.toLowerCase()) ||
                        cat.name.toLowerCase().includes('infrastructure') && slug === 'infrastructure' ||
                        cat.name.toLowerCase().includes('content') && slug === 'content' ||
                        cat.name.toLowerCase().includes('security') && slug === 'security' ||
                        cat.name.toLowerCase().includes('plugins') && slug === 'plugins' ||
                        cat.name.toLowerCase().includes('users') && slug === 'users' ||
                        cat.name.toLowerCase().includes('ai') && slug === 'ai' ||
                        cat.name.toLowerCase().includes('sessions') && slug === 'sessions' ||
                        cat.name.toLowerCase().includes('integrations') && slug === 'integrations'
                    )
                );

                if (matchingCategory) {
                    galaxy.metrics = {
                        categoryName: matchingCategory.name,
                        clientName: clientData.client,
                        nodesCount: matchingCategory.nodes?.length || 0,
                        topNodes: matchingCategory.nodes?.slice(0, 4).map(node => ({
                            label: node.label,
                            detail: node.detail
                        })) || []
                    };
                    galaxy.description = `Real-time data from ${clientData.client}: ${matchingCategory.nodes?.length || 0} active signals`;
                }
            });
        }

        // Update verification panel with data
        function updateVerificationPanel(data, error = null) {
            const licenseEl = document.getElementById('verificationLicense');
            const endpointEl = document.getElementById('verificationEndpoint');
            const statusEl = document.getElementById('verificationStatus');
            const clientsEl = document.getElementById('verificationClients');
            const lastUpdateEl = document.getElementById('verificationLastUpdate');
            const dataEl = document.getElementById('verificationData');

            if (licenseEl) licenseEl.textContent = licenseKey || 'No license key';
            if (endpointEl) endpointEl.textContent = '/wp-json/vl-hub/v1/constellation';
            
            if (error) {
                if (statusEl) statusEl.textContent = `Error: ${error}`;
                if (statusEl) statusEl.style.color = '#f85149';
                if (clientsEl) clientsEl.textContent = 'Failed';
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                if (dataEl) dataEl.textContent = `Error: ${error}`;
            } else if (data) {
                if (statusEl) statusEl.textContent = 'Connected';
                if (statusEl) statusEl.style.color = '#56d364';
                if (clientsEl) clientsEl.textContent = data.total_clients || 0;
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                if (dataEl) dataEl.textContent = JSON.stringify(data, null, 2);
            } else {
                if (statusEl) statusEl.textContent = 'No data';
                if (statusEl) statusEl.style.color = '#f2cc60';
                if (clientsEl) clientsEl.textContent = '0';
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                if (dataEl) dataEl.textContent = 'No data received';
            }
        }

        // Toggle verification panel
        function toggleVerificationPanel() {
            const content = document.getElementById('verificationContent');
            const button = document.getElementById('toggleVerification');
            if (content && button) {
                const isVisible = content.style.display !== 'none';
                content.style.display = isVisible ? 'none' : 'block';
                content.classList.toggle('show', !isVisible);
                button.textContent = isVisible ? 'Show Details' : 'Hide Details';
            }
        }

        // Manual sync function
        async function syncFromHub() {
            const syncBtn = document.getElementById('syncFromHub');
            if (syncBtn) {
                syncBtn.disabled = true;
                syncBtn.textContent = 'Syncing...';
            }

            updateDebugInfo('Manual sync initiated...');
            updateVerificationPanel(null, 'Syncing...');

            try {
                const data = await fetchConstellationData();
                constellationData = data;
                updateVerificationPanel(data, dataFetchError);
                
                if (data && data.clients && data.clients.length > 0) {
                    updateGalaxyDataWithRealData(data.clients[0]);
                    updateDebugInfo(`Sync complete: ${data.total_clients} clients loaded`);
                    // Refresh client name after constellation data is loaded
                    await updateClientName();
                } else {
                    updateDebugInfo('Sync complete: No client data found');
                }
            } catch (error) {
                updateDebugInfo(`Sync failed: ${error.message}`);
                updateVerificationPanel(null, error.message);
            } finally {
                if (syncBtn) {
                    syncBtn.disabled = false;
                    syncBtn.textContent = 'Sync From Hub';
                }
            }
        }

        // Add event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const toggleBtn = document.getElementById('toggleVerification');
            const syncBtn = document.getElementById('syncFromHub');
            
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleVerificationPanel);
            }
            
            if (syncBtn) {
                syncBtn.addEventListener('click', syncFromHub);
            }

            // Initialize Visible Light overlay
            initializeVLOverlay();
            
            // Also refresh client name after a delay to ensure constellation data is loaded
            setTimeout(async () => {
                console.log('Delayed client name refresh...');
                await refreshClientName();
            }, 2000);
        });

        // Initialize Visible Light overlay functionality
        async function initializeVLOverlay() {
            // Update client name from license key
            await updateClientName();
            
            // Update license key display
            updateLicenseKeyDisplay();
            
            // Setup menu navigation
            setupMenuNavigation();
            
            // Setup connection status
            setupConnectionStatus();
            
            // Setup control buttons
            setupControlButtons();
            
            // Setup client dropdown - retry if needed
            setupClientDropdown();
            
            // Retry dropdown setup after a delay if elements weren't found
            setTimeout(() => {
                const arrow = document.getElementById('clientDropdownArrow');
                const lightbox = document.getElementById('clientDropdownLightbox');
                if (!arrow || !lightbox) {
                    console.log('Retrying dropdown setup...');
            setupClientDropdown();
                }
            }, 1000);
            
            // Setup tutorial event listeners
            setupTutorial();
            
            // Check if user is first-time and show tutorial
            checkAndShowTutorial();
        }

        // Update client name from license key
        async function updateClientName() {
            const clientNameEl = document.getElementById('clientName');
            if (clientNameEl) {
                console.log('Starting client name update process...');
                
                // First priority: Use tutorialUsername (same source as tutorial checkbox)
                // This ensures consistency - same username shown in greeting and tutorial
                if (tutorialUsername) {
                    console.log('Using tutorialUsername from tutorial-status endpoint:', tutorialUsername);
                    clientNameEl.textContent = tutorialUsername;
                    return;
                }
                
                // Second priority: Try to get user data from constellation data
                if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
                    const clientData = constellationData.clients[0];
                    console.log('Checking constellation data for user info:', clientData);
                    
                    // Try to get client name from constellation client field first
                    console.log('clientData.client value:', clientData.client);
                    if (clientData.client && clientData.client !== 'Unassigned Client') {
                        const firstName = clientData.client.split(' ')[0];
                        console.log('Using first name from constellation client field:', firstName);
                        console.log('Setting clientNameEl.textContent to:', firstName);
                        clientNameEl.textContent = firstName;
                        return;
                    }
                    
                    // Check if there's user data in the constellation response
                    if (clientData.user_data && clientData.user_data.display_name) {
                        const firstName = clientData.user_data.display_name.split(' ')[0];
                        console.log('Using first name from constellation user_data:', firstName);
                        clientNameEl.textContent = firstName;
                        return;
                    }
                    
                    // Check if there's a user_id in the constellation data
                    if (clientData.user_id) {
                        try {
                            console.log('Trying to get user data by user_id:', clientData.user_id);
                            const response = await fetch(`/wp-json/wp/v2/users/${clientData.user_id}`, {
                                method: 'GET',
                                credentials: 'same-origin'
                            });
                            
                            if (response.ok) {
                                const userData = await response.json();
                                console.log('User data by user_id:', userData);
                                if (userData && userData.name) {
                                    const firstName = userData.name.split(' ')[0];
                                    console.log('Using first name from user_id lookup:', firstName);
                                    clientNameEl.textContent = firstName;
                                    return;
                                }
                            }
                        } catch (error) {
                            console.log('User_id lookup error:', error);
                        }
                    }
                }

                // Second priority: Try to get current user's display name using custom endpoint
                try {
                    console.log('Trying custom endpoint: /wp-json/myplugin/v1/current-user');
                    const response = await fetch('/wp-json/myplugin/v1/current-user', {
                        method: 'GET',
                        credentials: 'same-origin'
                    });
                    
                    console.log('Custom endpoint response status:', response.status);
                    if (response.ok) {
                        const userData = await response.json();
                        console.log('Custom endpoint user data:', userData);
                        if (userData && userData.display_name) {
                            // Extract first name from display_name
                            const firstName = userData.display_name.split(' ')[0];
                            console.log('Using first name from custom endpoint:', firstName);
                            clientNameEl.textContent = firstName;
                            return;
                        }
                    }
                } catch (error) {
                    console.log('Custom endpoint error:', error);
                }

                // Second priority: Try default WordPress users endpoint
                try {
                    console.log('Trying WordPress API: /wp-json/wp/v2/users/me');
                    const response = await fetch('/wp-json/wp/v2/users/me', {
                        method: 'GET',
                        credentials: 'same-origin'
                    });
                    
                    console.log('WordPress API response status:', response.status);
                    if (response.ok) {
                        const userData = await response.json();
                        console.log('WordPress API user data:', userData);
                        if (userData && userData.name) {
                            // Extract first name from name field
                            const firstName = userData.name.split(' ')[0];
                            console.log('Using first name from WordPress API:', firstName);
                            clientNameEl.textContent = firstName;
                            return;
                        }
                    } else {
                        const errorText = await response.text();
                        console.log('WordPress API error response:', errorText);
                    }
                } catch (error) {
                    console.log('WordPress API error:', error);
                }

                // Third priority: Try to get display name from Luna License Manager session
                if (licenseKey) {
                    console.log('Trying Luna License Manager session...');
                    const sessionData = await fetchUserDisplayName();
                    console.log('Luna License Manager session data:', sessionData);
                    if (sessionData && sessionData.user && sessionData.user.display_name) {
                        // Extract first word from display_name
                        const firstName = sessionData.user.display_name.split(' ')[0];
                        console.log('Using first name from Luna License Manager:', firstName);
                        clientNameEl.textContent = firstName;
                        return;
                    }
                    
                    // Try to get first name from WordPress user data as fallback
                    console.log('Trying WordPress user data fallback...');
                    const userData = await fetchUserData();
                    console.log('WordPress user data fallback:', userData);
                    if (userData && userData.first_name) {
                        console.log('Using first name from WordPress user data:', userData.first_name);
                        clientNameEl.textContent = userData.first_name;
                        return;
                    }
                    
                    // Final fallback - DON'T use license key, just use default
                    console.log('No name found, using default "Client"');
                    clientNameEl.textContent = 'Client';
                } else {
                    // No license key, use default
                    console.log('No license key, using default "Client"');
                    clientNameEl.textContent = 'Client';
                }
            }
        }

        // Refresh client name when constellation data is updated
        async function refreshClientName() {
            await updateClientName();
        }

        // Fetch user data from WordPress API
        async function fetchUserData() {
            try {
                const response = await fetch('https://visiblelight.ai/wp-json/wp/v2/users/me', {
                    credentials: 'include'
                });
                if (response.ok) {
                    const userData = await response.json();
                    console.log('User data from WordPress:', userData);
                    return userData;
                }
            } catch (error) {
                console.log('Could not fetch user data:', error);
            }
            return null;
        }

        // Fetch user display name from Luna License Manager API
        async function fetchUserDisplayName() {
            try {
                const response = await fetch('https://visiblelight.ai/wp-json/vl-hub/v1/session', {
                    credentials: 'include'
                });
                if (response.ok) {
                    const sessionData = await response.json();
                    console.log('Session data from Luna License Manager:', sessionData);
                    return sessionData;
                }
            } catch (error) {
                console.log('Could not fetch session data:', error);
            }
            return null;
        }

        // Get client name from license key or VL Hub data
        function getClientNameFromLicense(license) {
            console.log('Getting client name, constellationData:', constellationData);
            
            // Try to get client name from constellation data first
            if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
                const clientData = constellationData.clients[0];
                console.log('Client data found:', clientData);
                if (clientData.client && clientData.client !== 'Unassigned Client') {
                    // Extract first name from client name
                    const firstName = clientData.client.split(' ')[0];
                    console.log('Using first name from VL Hub:', firstName);
                    return firstName;
                }
            }
            
            // For "Unassigned Client", try to get first name from user data or site URL
            if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
                const clientData = constellationData.clients[0];
                
                // Try to get first name from user data if available
                if (clientData.user_data && clientData.user_data.first_name) {
                    console.log('Using first name from user data:', clientData.user_data.first_name);
                    return clientData.user_data.first_name;
                }
                
                // Fallback to site URL extraction
                if (clientData.site) {
                    try {
                        const url = new URL(clientData.site);
                        const domain = url.hostname.replace('www.', '');
                        const siteName = domain.split('.')[0];
                        if (siteName && siteName.length > 2) {
                            console.log('Using site name as fallback:', siteName);
                            return siteName.charAt(0).toUpperCase() + siteName.slice(1);
                        }
                    } catch (e) {
                        console.log('Could not parse site URL:', e);
                    }
                }
                
                // Try to get name from display_name if available
                if (clientData.user_data && clientData.user_data.display_name) {
                    const firstName = clientData.user_data.display_name.split(' ')[0];
                    console.log('Using first name from display_name:', firstName);
                    return firstName;
                }
                
                // Try to get name from the name field if available
                if (clientData.name) {
                    const firstName = clientData.name.split(' ')[0];
                    console.log('Using first name from name field:', firstName);
                    return firstName;
                }
            }
            
            // Fallback to license key parsing - REMOVED: Don't use license key as it's sensitive
            // Instead, just return 'Client' as the default
            console.log('Using default client name');
            return 'Client';
        }

        // Update license key display
        function updateLicenseKeyDisplay() {
            console.log('updateLicenseKeyDisplay called, licenseKey:', licenseKey);
            const licenseKeyEl = document.getElementById('licenseKeyDisplay');
            const copyBtn = document.getElementById('copyLicenseBtn');
            console.log('licenseKeyEl:', licenseKeyEl, 'copyBtn:', copyBtn);
            
            if (licenseKeyEl) {
                if (licenseKey) {
                    // Only show "VL-" plus first four characters, then blurred fake text
                    const prefix = licenseKey.startsWith('VL-') ? 'VL-' : 'VL-';
                    const firstFourChars = licenseKey.substring(licenseKey.indexOf('-') + 1, licenseKey.indexOf('-') + 5);
                    const blurredText = '<span class="blurred-text">-XXXX</span>';
                    console.log('Displaying license:', prefix + firstFourChars + blurredText);
                    licenseKeyEl.innerHTML = prefix + firstFourChars + blurredText;
                    
                    // Setup copy button if it exists
                    if (copyBtn) {
                        console.log('Setting up copy button click handler');
                        copyBtn.onclick = async function() {
                            console.log('Copy button clicked, copying:', licenseKey);
                            try {
                                await navigator.clipboard.writeText(licenseKey);
                                console.log('License key copied to clipboard');
                                // Show feedback
                                const originalHTML = copyBtn.innerHTML;
                                copyBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"></path></svg>';
                                setTimeout(() => {
                                    copyBtn.innerHTML = originalHTML;
                                }, 2000);
                            } catch (err) {
                                console.error('Failed to copy license key:', err);
                                // Fallback for older browsers
                                const textArea = document.createElement('textarea');
                                textArea.value = licenseKey;
                                document.body.appendChild(textArea);
                                textArea.select();
                                document.execCommand('copy');
                                document.body.removeChild(textArea);
                            }
                        };
                    } else {
                        console.error('Copy button not found!');
                    }
                } else {
                    licenseKeyEl.textContent = 'No license key';
                    console.log('No license key found');
                }
            } else {
                console.error('License key element not found!');
            }
        }

        // Setup menu navigation - simplified and more reliable
        function setupMenuNavigation() {
            console.log('Setting up menu navigation...');
            const menuItems = document.querySelectorAll('.vl-main-menu a');
            console.log('Found menu items:', menuItems.length);
            
            if (menuItems.length === 0) {
                console.error('No menu items found!');
                return;
            }
            
            menuItems.forEach((item, index) => {
                    const section = item.getAttribute('data-section');
                console.log(`Setting up menu item ${index}: ${section}`);
                
                // Remove href="#" to prevent hash navigation
                item.removeAttribute('href');
                
                // Add click handler directly
                item.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Menu item clicked:', section);
                    console.log('Current license key:', licenseKey);
                    
                    if (!section) {
                        console.error('No data-section attribute found on menu item');
                        return false;
                    }
                    
                    // Remove active class from all items
                    document.querySelectorAll('.vl-main-menu li').forEach(li => {
                        li.classList.remove('active');
                    });
                    
                    // Add active class to clicked item
                    item.parentElement.classList.add('active');
                    
                    // Handle section navigation
                    handleSectionNavigation(section);
                    return false;
                };
            });
        }

        // Handle section navigation
        function handleSectionNavigation(section) {
            console.log('Navigating to section:', section);
            
            // If it's the supercluster section, stay on current page
            if (section === 'supercluster') {
                // Revert to default - no highlighted galaxies
                if (typeof highlightGalaxy === 'function') {
                highlightGalaxy(null);
                }
                // Clear any URL path and show main Supercluster view
                if (licenseKey) {
                    const baseUrl = new URL(window.location.href);
                    baseUrl.searchParams.set('license', licenseKey);
                    window.history.replaceState({}, '', baseUrl.toString());
                    // Reload to show main Supercluster view
                    window.location.reload();
                }
                return;
            }
            
            // Map menu sections to galaxy names (from galaxyData)
            const sectionToGalaxyMap = {
                'web-infra': 'Website Infrastructure & Performance',
                'content': 'Content Management & Structure',
                'search-intel': 'Search Engine Intelligence',
                'reporting': 'Analytics & Engagement',
                'marketing-ads': 'Marketing & Campaign Data',
                'ecommerce': 'E-Commerce & Conversion Data',
                'security-compliance': 'Security & Compliance Data',
                'cloudops': 'CloudOps & Infrastructure Metrics',
                'user-identity': 'User & Identity Layer',
                'competitive': 'Competitive & Market Data'
            };
            
            // Get the galaxy name from the section
            const galaxyName = sectionToGalaxyMap[section];
            if (!galaxyName) {
                console.warn('Unknown section:', section);
                return;
            }
            
            if (!licenseKey) {
                console.warn('No license key available for navigation');
                return;
            }
            
            // Convert galaxy name to URL slug format (lowercase, spaces to hyphens, remove special chars)
            const slug = galaxyName
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric with hyphens
                .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens
            
            // Build full URL with license parameter and slug path
            // Format: ?license=VL-H59W-PDC8-ZT5W/website-infrastructure-performance/
            const baseUrl = window.location.origin + window.location.pathname;
            const newUrl = `${baseUrl}?license=${encodeURIComponent(licenseKey)}/${slug}/`;
            
            console.log('Navigating to:', newUrl);
            console.log('License key:', licenseKey);
            console.log('Slug:', slug);
            
            // Navigate to the new page
            window.location.href = newUrl;
        }

        // Highlight specific galaxy
        function highlightGalaxy(galaxyName) {
            // Remove existing highlights
            if (window.galaxyObjects) {
                window.galaxyObjects.forEach(galaxy => {
                    if (galaxy.mesh) {
                        galaxy.mesh.material.emissive.setHex(0x000000);
                        galaxy.mesh.material.opacity = 0.8;
                    }
                });
            }
            
            // Highlight the specified galaxy
            if (galaxyName && window.galaxyObjects) {
                const targetGalaxy = window.galaxyObjects.find(galaxy => 
                    galaxy.name === galaxyName
                );
                
                if (targetGalaxy && targetGalaxy.mesh) {
                    targetGalaxy.mesh.material.emissive.setHex(0x2B6AFF);
                    targetGalaxy.mesh.material.opacity = 1.0;
                }
            }
        }


        // Setup connection status
        function setupConnectionStatus() {
            const superIconImg = document.getElementById('superclusterStatusIcon');
            const connectionIcon = document.getElementById('connectionIcon');
            const connectionStatus = document.getElementById('connectionStatus');
            
            // Check VL Hub connection status
            async function checkConnectionStatus() {
                try {
                    // Try to verify authentication and license
                    const licenseKey = await verifyAuthenticationAndLicense();
                    if (!licenseKey) {
                        updateConnectionStatus(false, 'Authentication failed');
                        return;
                    }
                    
                    // Use a lightweight endpoint check instead of full data fetch
                    const endpoint = 'https://visiblelight.ai/wp-json/vl-hub/v1/constellation';
                    const url = licenseKey ? `${endpoint}?license=${encodeURIComponent(licenseKey)}` : endpoint;
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        credentials: 'include',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                    });
                    
                    const isConnected = response.ok;
                    updateConnectionStatus(isConnected, isConnected ? null : `HTTP ${response.status}`);
                } catch (error) {
                    console.error('Connection check failed:', error);
                    updateConnectionStatus(false, error.message);
                }
            }
            
            // Update connection status for both widget icon and hidden status section
            function updateConnectionStatus(isConnected, error = null) {
                const checkmarkUrl = 'https://visiblelight.ai/wp-content/uploads/2025/10/checkmark.svg';
                const xIconUrl = 'https://visiblelight.ai/wp-content/uploads/2025/10/x-close-icon.svg';
                
                if (isConnected) {
                    // Update widget icon (green checkmark)
                    if (superIconImg) {
                        superIconImg.src = checkmarkUrl;
                        superIconImg.alt = 'Connected';
                        superIconImg.className = 'status-icon';
                        // Set green background on the img element itself
                        superIconImg.style.background = '#0F9900';
                        superIconImg.style.borderRadius = '50%';
                        superIconImg.style.padding = '3px';
                    }
                    
                    // Update hidden connection status section
                    if (connectionIcon) {
                        const iconImg = connectionIcon.querySelector('img');
                        if (iconImg) {
                            iconImg.src = checkmarkUrl;
                            iconImg.alt = 'check mark';
                        }
                        connectionIcon.className = 'status-icon';
                    }
                    if (connectionStatus) {
                        connectionStatus.textContent = 'Active';
                    }
                } else {
                    // Update widget icon (red X)
                    if (superIconImg) {
                        superIconImg.src = xIconUrl;
                        superIconImg.alt = 'Disconnected';
                        superIconImg.className = 'status-icon error';
                        // Set red background on the img element itself
                        superIconImg.style.background = '#f85149';
                        superIconImg.style.borderRadius = '50%';
                        superIconImg.style.padding = '3px';
                    }
                    
                    // Update hidden connection status section
                    if (connectionIcon) {
                        const iconImg = connectionIcon.querySelector('img');
                        if (iconImg) {
                            iconImg.src = xIconUrl;
                            iconImg.alt = 'error mark';
                        }
                        connectionIcon.className = 'status-icon error';
                    }
                    if (connectionStatus) {
                        connectionStatus.textContent = 'Inactive';
                    }
                }
            }

            // Check connection status immediately
            checkConnectionStatus();
            
            // Check connection status once per hour (3600000 ms)
            setInterval(checkConnectionStatus, 3600000);
        }

        const INACTIVE_STREAM_STATUSES = ['inactive', 'disabled', 'offline', 'terminated', 'cancelled', 'canceled', 'archived', 'deleted', 'removed', 'suspended', 'paused', 'disconnected', 'decommissioned', 'retired'];

        function isStreamInactive(stream) {
            if (!stream || typeof stream !== 'object') return false;

            const directStatus = typeof stream.status === 'string' ? stream.status.toLowerCase().trim() : '';
            if (directStatus) {
                if (INACTIVE_STREAM_STATUSES.some(status => directStatus.includes(status))) {
                    return true;
                }
            }

            const metadataStatus = typeof stream.metadata?.status === 'string' ? stream.metadata.status.toLowerCase().trim() : '';
            if (metadataStatus && INACTIVE_STREAM_STATUSES.some(status => metadataStatus.includes(status))) {
                return true;
            }

            if (typeof stream.active !== 'undefined') {
                const activeValue = stream.active;
                if (typeof activeValue === 'boolean') {
                    return activeValue === false;
                }
                if (typeof activeValue === 'string') {
                    const normalized = activeValue.toLowerCase().trim();
                    if (['false', '0', 'no'].includes(normalized)) {
                        return true;
                    }
                }
            }

            if (typeof stream.connected !== 'undefined') {
                const connectedValue = stream.connected;
                if (typeof connectedValue === 'boolean') {
                    return connectedValue === false;
                }
                if (typeof connectedValue === 'string') {
                    const normalized = connectedValue.toLowerCase().trim();
                    if (['false', '0', 'no', 'disconnected'].includes(normalized)) {
                        return true;
                    }
                }
            }

            return false;
        }

        function extractActiveStreams(streams) {
            const values = Array.isArray(streams) ? streams : Object.values(streams || {});
            return values.filter(stream => !isStreamInactive(stream));
        }

        function getActiveStreamCountFromResponse(streamsData) {
            if (!streamsData) return 0;
            if (typeof streamsData.active_count === 'number') {
                return streamsData.active_count;
            }
            if (typeof streamsData.count === 'number') {
                return streamsData.count;
            }
            // Use client_streams instead of streams (unified naming)
            return extractActiveStreams(streamsData.client_streams || streamsData.streams || []).length;
        }

        function getInactiveStreamCountFromResponse(streamsData, activeCount) {
            if (!streamsData) return 0;
            if (typeof streamsData.inactive_count === 'number') {
                return streamsData.inactive_count;
            }
            if (typeof streamsData.total === 'number') {
                return Math.max(streamsData.total - activeCount, 0);
            }
            // Use client_streams instead of streams (unified naming)
            const streamsObj = streamsData.client_streams || streamsData.streams || {};
            const totalStreams = Array.isArray(streamsObj)
                ? streamsObj.length
                : Object.keys(streamsObj).length;
            return Math.max(totalStreams - activeCount, 0);
        }

        // Build "Your Supercluster" summary sentence with links
        // Track last known counts for polling-based updates
        let lastStreamCount = null;
        let lastConnectionCount = null;
        
        async function updateSuperclusterSummary() {
            try {
                const summaryEl = document.getElementById('superclusterSummary');
                if (!summaryEl) return;

                // Sites count from constellationData
                const sitesCount = (constellationData && typeof constellationData.total_clients === 'number')
                    ? constellationData.total_clients
                    : 0;

                // Streams and data source counts from VL Hub all-connections endpoint for current license
                // Using all-connections endpoint (same as Luna) instead of data-streams
                let streamsCount = 0;
                let sourcesCount = 0;
                if (licenseKey) {
                    // Fetch all connections for stream count (with cache-busting)
                    const connectionsResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}&_t=${Date.now()}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (connectionsResp.ok) {
                        const connectionsResponse = await connectionsResp.json();
                        // all-connections returns {ok: true, data: {...}} structure
                        // Extract data from response
                        const connectionsData = connectionsResponse?.ok && connectionsResponse?.data ? connectionsResponse.data : connectionsResponse;
                        
                        // all-connections returns client_streams and stream_count in the data object
                        // Use stream_count from response (this is the count of valid streams matching categories)
                        const activeCount = connectionsData?.stream_count || (connectionsData?.client_streams ? Object.keys(connectionsData.client_streams).length : 0);
                        streamsCount = activeCount;
                        if (lastStreamCount === null) {
                            lastStreamCount = activeCount;
                        }

                        console.log('[Supercluster] Streams count from all-connections:', {
                            active: activeCount,
                            stream_count: connectionsData?.stream_count,
                            client_streams_count: connectionsData?.client_streams ? Object.keys(connectionsData.client_streams).length : 0,
                            response: connectionsData
                        });
                        
                        // Use the same all-connections response to count all connections
                        // This endpoint returns structured connection data by category
                        console.log('[Supercluster] All-connections response:', connectionsData);
                        console.log('[Supercluster] Connections data keys:', Object.keys(connectionsData || {}));
                        
                        // Count all actual connections from all-connections endpoint
                        let connectionCount = 0;
                        const connectionDetails = {};
                        
                        // Cloudflare connection (from security category)
                        if (connectionsData.cloudflare && connectionsData.cloudflare.connected === true) {
                            connectionCount += 1;
                            connectionDetails.cloudflare = true;
                        }
                        
                        // SSL/TLS Status connection (from security category)
                        if (connectionsData.ssl_tls && (connectionsData.ssl_tls.connected === true || connectionsData.ssl_tls.certificate)) {
                            connectionCount += 1;
                            connectionDetails.ssl_tls = true;
                        }
                        
                        // Liquid Web connection (from cloudops/infrastructure category)
                        if (connectionsData.liquidweb && connectionsData.liquidweb.connected === true) {
                            connectionCount += 1;
                            connectionDetails.liquidweb = true;
                        }
                        
                        // AWS S3 connection (from cloudops/infrastructure category)
                        if (connectionsData.aws_s3 && connectionsData.aws_s3.connected === true) {
                            connectionCount += 1;
                            connectionDetails.aws_s3 = true;
                        }
                        
                        // GA4 connection (from analytics category)
                        if (connectionsData.ga4 && (connectionsData.ga4.property_id || connectionsData.ga4.metrics)) {
                            connectionCount += 1;
                            connectionDetails.ga4 = true;
                        }
                        
                        // Lighthouse/PageSpeed connection - check from profile endpoint
                        // (Not included in all-connections endpoint, need to check separately)
                        
                        // Google Search Console connection (from search category)
                        if (connectionsData.gsc && connectionsData.gsc.connected === true) {
                            connectionCount += 1;
                            connectionDetails.gsc = true;
                        }
                        
                        // Competitive category connection (from competitive category)
                        // Count as 1 connection if either competitor_reports OR vldr_metrics exists
                        const hasCompetitorReports = connectionsData.competitor_reports && Array.isArray(connectionsData.competitor_reports) && connectionsData.competitor_reports.length > 0;
                        const hasVldrMetrics = connectionsData.vldr_metrics && Object.keys(connectionsData.vldr_metrics).length > 0;
                        if (hasCompetitorReports || hasVldrMetrics) {
                            connectionCount += 1;
                            connectionDetails.competitive = true;
                            if (hasCompetitorReports) connectionDetails.competitor_reports = true;
                            if (hasVldrMetrics) connectionDetails.vldr = true;
                        }
                        
                        // WordPress Users connection (from identity category)
                        if (connectionsData.wordpress_users && connectionsData.wordpress_users.total > 0) {
                            connectionCount += 1;
                            connectionDetails.wordpress_users = true;
                        }
                        
                        // WordPress Content connection (from content category in all-connections)
                        if (connectionsData.wordpress_content && (connectionsData.wordpress_content.total_posts > 0 || connectionsData.wordpress_content.total_pages > 0 || (connectionsData.wordpress_content.posts && connectionsData.wordpress_content.posts.length > 0) || (connectionsData.wordpress_content.pages && connectionsData.wordpress_content.pages.length > 0))) {
                                connectionCount += 1;
                                connectionDetails.wordpress_content = true;
                            }
                            
                        // Lighthouse/PageSpeed connection (from analytics category in all-connections)
                        if (connectionsData.pagespeed && connectionsData.pagespeed.connected === true) {
                            connectionCount += 1;
                            connectionDetails.pagespeed = true;
                        }
                        
                        sourcesCount = connectionCount;
                        console.log('[Supercluster] Cloud Connections count:', sourcesCount, 'Connection details:', connectionDetails);
                        console.log('[Supercluster] Full connections data sample:', {
                            cloudflare: connectionsData.cloudflare,
                            ssl_tls: connectionsData.ssl_tls,
                            liquidweb: connectionsData.liquidweb,
                            aws_s3: connectionsData.aws_s3,
                            ga4: connectionsData.ga4,
                            pagespeed: connectionsData.pagespeed,
                            gsc: connectionsData.gsc,
                            competitor_reports: connectionsData.competitor_reports,
                            vldr_metrics: connectionsData.vldr_metrics,
                            wordpress_users: connectionsData.wordpress_users,
                            wordpress_content: connectionsData.wordpress_content
                        });
                        console.log('[Supercluster] Content connection check:', {
                            hasWordpressContent: !!connectionsData.wordpress_content,
                            totalPosts: connectionsData.wordpress_content?.total_posts,
                            totalPages: connectionsData.wordpress_content?.total_pages,
                            postsArray: connectionsData.wordpress_content?.posts?.length,
                            pagesArray: connectionsData.wordpress_content?.pages?.length
                        });
                        console.log('[Supercluster] Competitive connection check:', {
                            hasCompetitorReports: hasCompetitorReports,
                            hasVldrMetrics: hasVldrMetrics,
                            competitorReportsCount: connectionsData.competitor_reports?.length,
                            vldrMetricsKeys: connectionsData.vldr_metrics ? Object.keys(connectionsData.vldr_metrics).length : 0
                        });
                    } else {
                        console.error('[Supercluster] All-connections fetch failed:', connectionsResp.status, connectionsResp.statusText);
                    }
                }

                // Get license key from URL for redirect
                const currentParams = new URLSearchParams(window.location.search);
                const currentLicense = currentParams.get('license') || '';
                const licenseKeyForUrl = currentLicense.split('/')[0]; // Get just the license key, not the path
                const sitesLinkHref = licenseKeyForUrl ? `?license=${encodeURIComponent(licenseKeyForUrl)}/omniscient-app-observatory/` : '#';
                const sitesLink = `<a id="sitesLink" href="${sitesLinkHref}">${sitesCount}</a>`;
                const sourcesLink = `<a id="sourcesLink" href="#">${sourcesCount}</a>`;
                const streamsLink = `<a id="streamsLink" href="#">${streamsCount}</a>`;

                // Dynamic pluralization for "Web App(s)"
                const webAppText = sitesCount === 1 ? 'Web App' : 'Web Apps';
                const galaxyText = 'Cloud Connections';
                const streamText = 'Data Streams';

                summaryEl.innerHTML = `Observing ${sitesLink} ${webAppText} spawning ${sourcesLink} ${galaxyText}, totaling ${streamsLink} ${streamText}.`;
            } catch (e) {
                console.error('[Supercluster] Error updating summary:', e);
                const summaryEl = document.getElementById('superclusterSummary');
                if (summaryEl) {
                    // Show error details in console but don't break the UI
                    summaryEl.textContent = 'Supercluster summary unavailable.';
                }
            }
        }

        // Listen for real-time stream count updates from VL Hub admin
        if (typeof BroadcastChannel !== 'undefined') {
            const streamUpdateChannel = new BroadcastChannel('vl_streams_updates');
            streamUpdateChannel.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'streams_updated') {
                    console.log('[Supercluster] Streams updated, refreshing summary...');
                    updateSuperclusterSummary();
                }
            });
        }

        // Also listen for storage events (fallback for cross-tab communication)
        window.addEventListener('storage', (e) => {
            if (e.key === 'vl_streams_updated' && e.newValue) {
                console.log('[Supercluster] Streams updated via storage event, refreshing summary...');
                updateSuperclusterSummary();
            }
        });

        // Poll for updates every 30 seconds to ensure real-time accuracy
        // This ensures updates even if BroadcastChannel fails
        setInterval(async () => {
            if (!licenseKey) return;
            
            try {
                // Check stream count using all-connections endpoint (with cache-busting)
                const connectionsResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}&_t=${Date.now()}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                if (connectionsResp.ok) {
                    const connectionsResponse = await connectionsResp.json();
                    // all-connections returns {ok: true, data: {...}} structure
                    const connectionsData = connectionsResponse?.ok && connectionsResponse?.data ? connectionsResponse.data : connectionsResponse;
                    // all-connections returns stream_count in the data object
                    const currentCount = connectionsData?.stream_count || (connectionsData?.client_streams ? Object.keys(connectionsData.client_streams).length : 0);

                    if (currentCount !== lastStreamCount) {
                        console.log('[Supercluster] Stream count changed from', lastStreamCount, 'to', currentCount, '- updating summary');
                        lastStreamCount = currentCount;
                        updateSuperclusterSummary();
                    }
                }
            } catch (e) {
                console.error('[Supercluster] Error polling for updates:', e);
            }
        }, 30000); // Poll every 30 seconds

        // Populate Recent Activity from VL Hub data
        async function loadRecentActivity() {
            const listEl = document.getElementById('recentActivityList');
            if (!listEl) return;

            const items = [];
            const now = Date.now();
            const withinDays = (ts, days = 7) => {
                const t = Date.parse(ts);
                return !isNaN(t) && (now - t) <= days * 24 * 60 * 60 * 1000;
            };

            // New Site Connected from constellation last_seen
            if (constellationData && Array.isArray(constellationData.clients)) {
                constellationData.clients.forEach(c => {
                    if (c.last_seen && withinDays(c.last_seen, 14)) {
                        items.push({ label: 'New Site Connected', time: c.last_seen });
                    }
                });
            }

            // Streams-based activity
            if (licenseKey) {
                try {
                    const resp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (resp.ok) {
                        const responseData = await resp.json();
                        // all-connections returns {ok: true, data: {...}} structure
                        const data = responseData?.ok && responseData?.data ? responseData.data : responseData;
                        // all-connections returns client_streams in the data object
                        const streamArray = extractActiveStreams(data && data.client_streams ? data.client_streams : {});
                        streamArray.forEach(s => {
                            if (s.connected_at && withinDays(s.connected_at, 14)) {
                                items.push({ 
                                    label: 'New Data Source Connected', 
                                    time: s.connected_at,
                                    streamName: s.name || 'Unknown Source',
                                    streamId: s.id || null,
                                    streamData: s // Store full stream data for URL building
                                });
                            }
                            if (s.last_updated && withinDays(s.last_updated, 7)) {
                                items.push({ 
                                    label: 'New Data Stream Was Synced', 
                                    time: s.last_updated,
                                    streamName: s.name || 'Unknown Stream',
                                    streamId: s.id || null,
                                    streamData: s // Store full stream data for URL building
                                });
                            }
                        });
                        
                        // Add removed streams to activity feed
                        if (data.removed_streams && typeof data.removed_streams === 'object') {
                            const removedArray = Array.isArray(data.removed_streams) ? data.removed_streams : Object.values(data.removed_streams);
                            removedArray.forEach(removed => {
                                if (removed.removed_at && withinDays(removed.removed_at, 14)) {
                                    items.push({ 
                                        label: 'Data Stream Removed', 
                                        time: removed.removed_at,
                                        streamName: removed.stream_name || removed.stream_id || 'Unknown Stream',
                                        streamId: removed.stream_id || null,
                                        isRemoved: true
                                    });
                                }
                            });
                        }
                    }
                } catch (_) {}
            }

            // Placeholder for reports (requires hub events)
            // items.push({ label: 'New Report Run', time: new Date().toISOString() });

            // Render
            listEl.innerHTML = '';
            if (items.length === 0) {
                listEl.innerHTML = '<li class="vl-activity-empty">No recent activity.</li>';
                return;
            }
            // Sort newest first
            items.sort((a, b) => Date.parse(b.time) - Date.parse(a.time));
            for (const it of items.slice(0, 10)) {
                const when = new Date(it.time);
                const pretty = isNaN(when.getTime()) ? '' : when.toLocaleString();
                const li = document.createElement('li');
                li.className = 'vl-activity-item';
                
                // Create structure: date/time above, activity label below
                if (pretty) {
                    const timeSpan = document.createElement('span');
                    timeSpan.id = 'activityTimeStamp';
                    timeSpan.textContent = pretty;
                    li.appendChild(timeSpan);
                    li.appendChild(document.createElement('br'));
                }
                
                // Build the label - just use the label text
                const labelText = it.label;
                
                // Create text node for the base label
                const labelTextNode = document.createTextNode(labelText);
                li.appendChild(labelTextNode);
                
                // If stream name exists, add a line break and then the stream name
                if (it.streamName) {
                    // Add line break
                    li.appendChild(document.createElement('br'));
                    
                    // If stream has an ID, make it clickable
                    if (it.streamId) {
                        const streamLink = document.createElement('a');
                        streamLink.href = `#stream-${it.streamId}`;
                        streamLink.textContent = it.streamName;
                        streamLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            // Navigate to data stream page with proper URL structure
                            const streamUrl = buildStreamDataUrl(licenseKey, it.streamData || it);
                            window.location.href = streamUrl;
                        });
                        li.appendChild(streamLink);
                    } else {
                        // If stream name exists but no ID, just show it as text
                        const streamNameText = document.createTextNode(it.streamName);
                        li.appendChild(streamNameText);
                    }
                }
                
                listEl.appendChild(li);
            }
        }

        // Setup client dropdown functionality - simplified and more reliable
        function setupClientDropdown() {
            console.log('Setting up client dropdown...');
            
            // Get elements
            const dropdownArrow = document.getElementById('clientDropdownArrow');
            const dropdownLightbox = document.getElementById('clientDropdownLightbox');
            const dropdownContent = document.getElementById('clientDropdownContent');
            const accountSettings = document.getElementById('accountSettings');
            const logoutOption = document.getElementById('logoutOption');
            const logoutModal = document.getElementById('logoutModal');
            const logoutCancel = document.getElementById('logoutCancel');
            const logoutConfirm = document.getElementById('logoutConfirm');
            
            console.log('Dropdown elements:', {
                arrow: !!dropdownArrow,
                lightbox: !!dropdownLightbox,
                content: !!dropdownContent,
                accountSettings: !!accountSettings,
                logoutOption: !!logoutOption,
                logoutModal: !!logoutModal
            });

            if (!dropdownArrow || !dropdownLightbox || !dropdownContent) {
                console.error('Dropdown elements not found!');
                return;
            }

            // Make arrow clickable
            dropdownArrow.style.cursor = 'pointer';
            dropdownArrow.style.userSelect = 'none';
            
            // Position dropdown content near the arrow
            function positionDropdown() {
                const arrowRect = dropdownArrow.getBoundingClientRect();
                dropdownContent.style.top = (arrowRect.bottom + 5) + 'px';
                dropdownContent.style.left = (arrowRect.left - 100) + 'px';
            }

            // Toggle dropdown
            function toggleDropdown() {
                console.log('toggleDropdown called');
                const isVisible = dropdownLightbox.style.display === 'block';
                
                if (isVisible) {
                    dropdownLightbox.style.display = 'none';
                    console.log('Hiding dropdown');
                } else {
                    positionDropdown();
                    dropdownLightbox.style.display = 'block';
                    console.log('Showing dropdown');
                }
            }

            // Close dropdown
            function closeDropdown() {
                dropdownLightbox.style.display = 'none';
            }

            // Show logout modal
            function showLogoutModal() {
                console.log('Showing logout modal');
                logoutModal.style.display = 'block';
            }

            // Hide logout modal
            function hideLogoutModal() {
                logoutModal.style.display = 'none';
            }

            // Perform logout
            function performLogout() {
                console.log('Performing logout...');
                localStorage.removeItem('vl-cms-data');
                localStorage.removeItem('vl-supercluster-tutorial-completed');
                sessionStorage.clear();
                if (inactivityTimeout) clearTimeout(inactivityTimeout);
                window.location.href = LOGIN_PAGE_URL;
            }

            // Direct onclick handler on arrow - most reliable
            dropdownArrow.onclick = function(e) {
                console.log('Dropdown arrow clicked');
                e.preventDefault();
                    e.stopPropagation();
                    toggleDropdown();
                return false;
            };
            
            // Also add to image if it exists
            const arrowImage = dropdownArrow.querySelector('img');
            if (arrowImage) {
                arrowImage.style.pointerEvents = 'auto';
                arrowImage.onclick = function(e) {
                    console.log('Arrow image clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    toggleDropdown();
                    return false;
                };
            }

            // Account Settings click
            if (accountSettings) {
                accountSettings.onclick = function(e) {
                    e.preventDefault();
                    closeDropdown();
                };
            }

            // Logout option click
            if (logoutOption) {
                logoutOption.onclick = function(e) {
                    console.log('Logout option clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    closeDropdown();
                    showLogoutModal();
                };
            }

            // Logout modal buttons
            if (logoutCancel) {
                logoutCancel.onclick = hideLogoutModal;
            }

            if (logoutConfirm) {
                logoutConfirm.onclick = performLogout;
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                const target = e.target;
                const lightbox = document.getElementById('clientDropdownLightbox');
                const arrow = document.getElementById('clientDropdownArrow');
                const modal = document.getElementById('logoutModal');
                
                if (lightbox && lightbox.style.display === 'block') {
                    if (!lightbox.contains(target) && 
                        !arrow.contains(target) && 
                        (!modal || !modal.contains(target))) {
                    closeDropdown();
                    }
                }
            });

            // Update position on resize
            window.addEventListener('resize', positionDropdown);
        }

        // Tutorial system for first-time users
        const tutorialSteps = [
            {
                title: 'Welcome to Visible Light',
                description: 'This is Supercluster - the center of your digital universe. It connects all your cloud services, data streams, and analytics into one intuitive and interactive virtual interface.',
                targetElement: null, // No specific target, show welcome message
                position: 'center'
            },
            {
                title: 'Interactive 3D Visualization',
                description: 'Explore your data universe! Click and drag to rotate, scroll to zoom, and click on any galaxy to see detailed information about that data source.',
                targetElement: '#vlSuperclusterRoot',
                position: 'center'
            },
            {
                title: 'Navigation Menu',
                description: 'Access different sections of your dashboard: Web & Infra, Content, Search Intel, Reporting, Marketing & Ads, and more. Each section shows relevant data streams.',
                targetElement: '.vl-main-menu',
                position: 'left'
            },
            {
                title: 'Your License Key',
                description: 'Your unique Visible Light license key is displayed here. Click the copy button to copy it to your clipboard when needed.',
                targetElement: '#licenseKeyContainer',
                position: 'left'
            },
            {
                title: 'Recent Activity',
                description: 'Stay updated with your latest data stream syncs, new connections, and important events. Click on any activity to view detailed information.',
                targetElement: '#recentActivityWidget',
                position: 'right'
            },
            {
                title: 'Control Buttons',
                description: 'Use these controls to navigate your Supercluster: Move left/right, zoom in/out to explore different views of your data.',
                targetElement: '.vl-controls',
                position: 'right'
            },
            {
                title: 'Client Menu',
                description: 'Click on your name or the dropdown arrow to access account settings and logout options.',
                targetElement: '#clientDropdownArrow',
                position: 'top-left'
            },
            {
                title: 'You\'re All Set!',
                description: 'You now know the basics of your Supercluster dashboard. Start exploring your data universe and discover insights across all your connected sources.',
                targetElement: null,
                position: 'center'
            }
        ];

        let currentTutorialStep = 0;
        let tutorialActive = false;

        // Store username for tutorial label
        let tutorialUsername = null;

        // Update "Never show again" label with username
        function updateNeverShowLabel() {
            const label = document.getElementById('tutorialNeverShowLabel');
            if (label) {
                if (tutorialUsername) {
                    label.textContent = `Never show this tutorial again for ${tutorialUsername}`;
                } else {
                    label.textContent = 'Never show this tutorial again';
                }
            }
        }

        // Check if user has completed tutorial before
        async function checkAndShowTutorial() {
            console.log('=== TUTORIAL CHECK START ===');
            console.log('License key:', licenseKey);
            
            // Check localStorage first (faster)
            const localCompleted = localStorage.getItem('vl-supercluster-tutorial-completed');
            console.log('LocalStorage tutorial status:', localCompleted);
            
            try {
                // Include license key in request for cookie-less fallback
                const sessionUrl = new URL('https://visiblelight.ai/wp-json/vl-hub/v1/tutorial-status');
                if (licenseKey) {
                    sessionUrl.searchParams.set('license', licenseKey);
                }
                
                console.log('Checking tutorial status from server:', sessionUrl.toString());
                
                // Check server-side (survives cache/cookie clearing)
                const response = await fetch(sessionUrl.toString(), {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                console.log('Tutorial status response:', response.status);

                if (response.ok) {
                    const data = await response.json();
                    console.log('Tutorial status data from server:', data);
                    
                    // Store username for label
                    if (data && data.username) {
                        tutorialUsername = data.username;
                        console.log('Tutorial username:', tutorialUsername);
                        // Immediately update client greeting with the same username
                        updateClientName();
                    }
                    
                    // If user has opted to never show tutorial, don't show it
                    if (data && data.never_show === true) {
                        console.log('✗ User has opted to never show tutorial - NOT SHOWING');
                        return;
                    }
                    // If tutorial was completed but not "never show", don't show it
                    if (data && data.completed === true) {
                        console.log('✗ Tutorial already completed on server - NOT SHOWING');
                        // Also set in localStorage for faster check next time
                        localStorage.setItem('vl-supercluster-tutorial-completed', 'true');
                        return;
                    }
                    
                    // If server says not completed, show tutorial (even if localStorage says completed)
                    console.log('✓ Server says tutorial not completed - WILL SHOW');
                } else {
                    console.warn('Tutorial status check failed:', response.status);
                    const errorText = await response.text();
                    console.warn('Error response:', errorText);
                    
                    // If server check fails, only trust localStorage if it exists
                    if (localCompleted) {
                        console.log('✗ Server check failed, but localStorage says completed - NOT SHOWING');
                        return;
                    }
                    console.log('✓ Server check failed, no localStorage - WILL SHOW');
                }
            } catch (error) {
                console.warn('Could not check tutorial status from server:', error);
                // If server check fails, only trust localStorage if it exists
                if (localCompleted) {
                    console.log('✗ Server check failed, but localStorage says completed - NOT SHOWING');
                    return;
                }
                console.log('✓ Server check failed, no localStorage - WILL SHOW');
            }

            // Show tutorial after a short delay to let page load
            console.log('=== SHOWING TUTORIAL ===');
            setTimeout(() => {
                showTutorial();
            }, 1500);
        }

        // Show tutorial
        function showTutorial() {
            const overlay = document.getElementById('tutorialOverlay');
            if (!overlay) return;
            
            tutorialActive = true;
            overlay.style.display = 'block';
            currentTutorialStep = 0;
            updateTutorialStep();
        }

        // Save tutorial status to server
        async function saveTutorialStatus(completed, neverShow) {
            // Mark tutorial as completed in localStorage
            if (completed) {
                localStorage.setItem('vl-supercluster-tutorial-completed', 'true');
            }
            
            // Save to server-side (survives cache/cookie clearing)
            try {
                // Include license key in request for cookie-less fallback
                const saveUrl = new URL('https://visiblelight.ai/wp-json/vl-hub/v1/tutorial-status');
                if (licenseKey) {
                    saveUrl.searchParams.set('license', licenseKey);
                }
                
                const response = await fetch(saveUrl.toString(), {
                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        completed: completed,
                        never_show: neverShow
                    }),
                });

                if (response.ok) {
                    console.log('Tutorial status saved to server');
                    return true;
                } else {
                    console.warn('Failed to save tutorial status to server');
                    return false;
                }
            } catch (error) {
                console.warn('Error saving tutorial status to server:', error);
                return false;
            }
        }

        // Hide tutorial
        async function hideTutorial() {
            const overlay = document.getElementById('tutorialOverlay');
            if (!overlay) return;
            
            tutorialActive = false;
            overlay.style.display = 'none';
            clearHighlight();
            
            // Check if "never show again" is checked
            const neverShowCheckbox = document.getElementById('tutorialNeverShow');
            const neverShow = neverShowCheckbox && neverShowCheckbox.checked;
            
            // Save tutorial as completed (only if we reached the end)
            const isCompleted = currentTutorialStep >= tutorialSteps.length - 1;
            await saveTutorialStatus(isCompleted, neverShow);
        }

        // Update tutorial step display
        function updateTutorialStep() {
            if (currentTutorialStep < 0 || currentTutorialStep >= tutorialSteps.length) {
                hideTutorial();
                return;
            }

            const step = tutorialSteps[currentTutorialStep];
            const stepContent = document.getElementById('tutorialStepContent');
            const prevBtn = document.getElementById('tutorialPrev');
            const nextBtn = document.getElementById('tutorialNext');
            const progress = document.getElementById('tutorialProgress');

            if (!stepContent || !prevBtn || !nextBtn || !progress) return;

            // Update content
            stepContent.innerHTML = `
                <h3 class="tutorial-title">${step.title}</h3>
                <p class="tutorial-description">${step.description}</p>
            `;

            // Update navigation buttons
            prevBtn.style.display = currentTutorialStep === 0 ? 'none' : 'inline-block';
            nextBtn.textContent = currentTutorialStep === tutorialSteps.length - 1 ? 'Get Started' : 'Next';

            // Show "Never show again" option on last step
            const optionsDiv = document.getElementById('tutorialOptions');
            if (optionsDiv) {
                if (currentTutorialStep === tutorialSteps.length - 1) {
                    optionsDiv.style.display = 'block';
                    // Update label with username if available
                    updateNeverShowLabel();
                } else {
                    optionsDiv.style.display = 'none';
                }
            }

            // Update progress bar
            const progressPercent = ((currentTutorialStep + 1) / tutorialSteps.length) * 100;
            progress.style.setProperty('--progress-width', `${progressPercent}%`);

            // Highlight target element if specified
            if (step.targetElement) {
                highlightElement(step.targetElement, step.position);
            } else {
                clearHighlight();
            }
        }

        // Highlight a specific element
        function highlightElement(selector, position) {
            const element = document.querySelector(selector);
            if (!element) {
                clearHighlight();
                return;
            }

            const highlight = document.getElementById('tutorialHighlight');
            const backdrop = document.getElementById('tutorialBackdrop');
            const content = document.getElementById('tutorialContent');

            if (!highlight || !backdrop || !content) return;

            const rect = element.getBoundingClientRect();
            const padding = 10;

            // Calculate highlight position and size
            highlight.style.width = (rect.width + padding * 2) + 'px';
            highlight.style.height = (rect.height + padding * 2) + 'px';
            highlight.style.left = (rect.left - padding) + 'px';
            highlight.style.top = (rect.top - padding) + 'px';
            highlight.style.display = 'block';
            highlight.style.borderRadius = '8px';

            // Position tutorial content based on position preference
            positionContent(content, rect, position);
        }

        // Position tutorial content relative to highlighted element
        function positionContent(content, rect, position) {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const contentWidth = 400;
            const contentHeight = 200;
            const margin = 20;

            let left, top;

            switch (position) {
                case 'left':
                    left = rect.left - contentWidth - margin;
                    top = rect.top + (rect.height / 2) - (contentHeight / 2);
                    break;
                case 'right':
                    left = rect.right + margin;
                    top = rect.top + (rect.height / 2) - (contentHeight / 2);
                    break;
                case 'top':
                    left = rect.left + (rect.width / 2) - (contentWidth / 2);
                    top = rect.top - contentHeight - margin;
                    break;
                case 'bottom':
                    left = rect.left + (rect.width / 2) - (contentWidth / 2);
                    top = rect.bottom + margin;
                    break;
                case 'top-left':
                    left = rect.left;
                    top = rect.top - contentHeight - margin;
                    break;
                case 'center':
                default:
                    left = (viewportWidth / 2) - (contentWidth / 2);
                    top = (viewportHeight / 2) - (contentHeight / 2);
                    break;
            }

            // Ensure content stays within viewport
            left = Math.max(margin, Math.min(left, viewportWidth - contentWidth - margin));
            top = Math.max(margin, Math.min(top, viewportHeight - contentHeight - margin));

            content.style.left = left + 'px';
            content.style.top = top + 'px';
        }

        // Clear highlight
        function clearHighlight() {
            const highlight = document.getElementById('tutorialHighlight');
            if (highlight) {
                highlight.style.display = 'none';
            }
        }

        // Setup tutorial event listeners - simplified with direct onclick handlers
        function setupTutorial() {
            console.log('Setting up tutorial event listeners...');
            const closeBtn = document.getElementById('tutorialClose');
            const prevBtn = document.getElementById('tutorialPrev');
            const nextBtn = document.getElementById('tutorialNext');
            const backdrop = document.getElementById('tutorialBackdrop');

            console.log('Tutorial elements:', {
                closeBtn: !!closeBtn,
                prevBtn: !!prevBtn,
                nextBtn: !!nextBtn,
                backdrop: !!backdrop
            });

            if (!closeBtn || !prevBtn || !nextBtn) {
                console.error('Tutorial buttons not found!');
                return;
            }

            // Close button - direct onclick handler
            closeBtn.onclick = function(e) {
                console.log('Tutorial close button clicked');
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                // Save tutorial as seen (but not completed) when closed early
                saveTutorialStatus(false, false).catch(err => console.error('Error saving tutorial status:', err));
                hideTutorial();
                return false;
            };

            // Previous button - direct onclick handler
            prevBtn.onclick = function(e) {
                console.log('Tutorial previous button clicked, current step:', currentTutorialStep);
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                if (currentTutorialStep > 0) {
                    currentTutorialStep--;
                    console.log('Moving to step:', currentTutorialStep);
                    updateTutorialStep();
                }
                return false;
            };

            // Next button - direct onclick handler
            nextBtn.onclick = function(e) {
                console.log('Tutorial next button clicked, current step:', currentTutorialStep, 'total steps:', tutorialSteps.length);
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                if (currentTutorialStep < tutorialSteps.length - 1) {
                    currentTutorialStep++;
                    console.log('Moving to step:', currentTutorialStep);
                    updateTutorialStep();
                } else {
                    console.log('Reached last step, hiding tutorial');
                    hideTutorial();
                }
                return false;
            };

            // Close on backdrop click
            if (backdrop) {
                backdrop.onclick = function(e) {
                    // Only close if clicking directly on backdrop, not on content
                    if (e.target === backdrop) {
                        console.log('Tutorial backdrop clicked');
                        hideTutorial();
                    }
                };
            }
        }

        // Update tutorial positioning on window resize
        window.addEventListener('resize', () => {
            if (tutorialActive && currentTutorialStep >= 0 && currentTutorialStep < tutorialSteps.length) {
                const step = tutorialSteps[currentTutorialStep];
                if (step.targetElement) {
                    highlightElement(step.targetElement, step.position);
                }
            }
        });

        // Setup control buttons
        function setupControlButtons() {
            // Left/Right controls
            const controlLeft = document.getElementById('controlLeft');
            const controlRight = document.getElementById('controlRight');
            
            if (controlLeft) {
                controlLeft.addEventListener('click', () => {
                    // Move supercluster left
                    if (camera) {
                        camera.position.x -= 2;
                        camera.lookAt(0, 0, 0);
                    }
                });
            }
            
            if (controlRight) {
                controlRight.addEventListener('click', () => {
                    // Move supercluster right
                    if (camera) {
                        camera.position.x += 2;
                        camera.lookAt(0, 0, 0);
                    }
                });
            }

            // Zoom controls
            const controlZoomIn = document.getElementById('controlZoomIn');
            const controlZoomOut = document.getElementById('controlZoomOut');
            
            if (controlZoomIn) {
                controlZoomIn.addEventListener('click', () => {
                    // Zoom in
                    if (camera) {
                        camera.position.multiplyScalar(0.9);
                    }
                });
            }
            
            if (controlZoomOut) {
                controlZoomOut.addEventListener('click', () => {
                    // Zoom out
                    if (camera) {
                        camera.position.multiplyScalar(1.1);
                    }
                });
            }

        }

        // Build stream data URL with proper format
        function buildStreamDataUrl(licenseKey, streamData) {
            const baseUrl = window.location.origin + window.location.pathname;
            const urlParams = new URLSearchParams(window.location.search);
            
            // Determine category from stream categories
            let category = 'competitive'; // default
            if (streamData.categories && Array.isArray(streamData.categories)) {
                // Map categories to URL segments
                const categoryMap = {
                    'competitive': 'competitive',
                    'search': 'search-intel',
                    'analytics': 'reporting',
                    'marketing': 'marketing-ads',
                    'ecommerce': 'ecommerce',
                    'security': 'security-compliance',
                    'cloudops': 'cloudops',
                    'identity': 'user-identity',
                    'content': 'content',
                    'infrastructure': 'web-infra'
                };
                
                for (const cat of streamData.categories) {
                    if (categoryMap[cat]) {
                        category = categoryMap[cat];
                        break;
                    }
                }
            }
            
            // Determine stream type (e.g., 'competitive-analysis', 'lighthouse-insights', etc.)
            let streamType = 'data-stream';
            if (streamData.id) {
                // Map stream IDs to stream types
                if (streamData.id.includes('competitor_') || streamData.id.includes('competitive')) {
                    streamType = 'competitive-analysis';
                } else if (streamData.id.includes('lighthouse_') || streamData.id.includes('pagespeed')) {
                    streamType = 'lighthouse-insights';
                } else if (streamData.id.includes('aws_s3')) {
                    streamType = 'aws-s3-storage';
                } else if (streamData.id.includes('liquidweb')) {
                    streamType = 'liquid-web-assets';
                } else if (streamData.id.includes('google_search_console')) {
                    streamType = 'google-search-console';
                        } else {
                    streamType = streamData.id.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                }
            }
            
            // Get unique identifier
            let uniqueId = streamData.id || streamData.streamId || 'unknown';
            // For competitor analysis, use the competitor URL
            if (streamData.competitor_url) {
                uniqueId = encodeURIComponent(streamData.competitor_url);
            } else if (streamData.source_url) {
                uniqueId = encodeURIComponent(streamData.source_url);
            } else if (streamData.url) {
                uniqueId = encodeURIComponent(streamData.url);
            } else {
                uniqueId = encodeURIComponent(uniqueId);
            }
            
            // Build URL: ?license=XXX/category/data-stream/stream-type/unique-id
            const pathSegments = `${category}/data-stream/${streamType}/${uniqueId}`;
            return `${baseUrl}?license=${encodeURIComponent(licenseKey)}/${pathSegments}`;
        }

        // Check for category-level page URL (e.g., ?license=XXX/website-infrastructure-performance/)
        function checkUrlForCategoryPage() {
            const urlParams = new URLSearchParams(window.location.search);
            const licenseParam = urlParams.get('license');
            
            if (!licenseParam) return false;
            
            // Check if URL contains category path: license=XXX/category-slug/
            // Pattern: license key followed by /category-slug/ (ends with /)
            const categoryMatch = licenseParam.match(/^([^/]+)\/([^/]+)\/?$/);
            if (!categoryMatch) {
                return false;
            }
            
            const [, extractedLicense, categorySlug] = categoryMatch;
            
            // Verify license matches authenticated user
            if (extractedLicense !== licenseKey) {
                console.error('License mismatch in URL');
                return false;
            }
            
            // Render the category page
            renderCategoryPage(licenseKey, categorySlug);
            return true;
        }
        
        // Check for stream data page URL and render data stream page
        function checkUrlForStreamDataPage() {
            const urlParams = new URLSearchParams(window.location.search);
            const licenseParam = urlParams.get('license');
            
            if (!licenseParam) return false;
            
            // Check if URL contains data stream path: license=XXX/category/data-stream/stream-type/unique-id
            const pathMatch = licenseParam.match(/^([^/]+)\/([^/]+)\/data-stream\/([^/]+)\/(.+)$/);
            if (!pathMatch) {
                // Old format: ?license=XXX&stream=YYY
                const streamId = urlParams.get('stream');
                if (streamId && licenseKey) {
                    // Legacy support - redirect to new format
                    return false;
                }
                return false;
            }
            
            const [, extractedLicense, category, streamType, uniqueId] = pathMatch;
            
            // Verify license matches authenticated user
            if (extractedLicense !== licenseKey) {
                console.error('License mismatch in URL');
                return false;
            }
            
            // Render the data stream page
            renderStreamDataPage(licenseKey, category, streamType, decodeURIComponent(uniqueId));
            return true;
        }
        
        // Render category page - shows all streams/data for a category
        async function renderCategoryPage(licenseKey, categorySlug) {
            console.log('Rendering category page:', { licenseKey, categorySlug });
            
            // Hide only the Three.js canvas, keep container visible
            hideThreeJSCanvas();
            // Hide labels on internal pages
            hideSuperclusterLabels();
            
            // Show the page content container
            const pageContent = document.getElementById('vlPageContent');
            if (pageContent) {
                pageContent.style.display = 'block';
            }
            
            // Ensure overlays and menus remain visible (same as initialization)
            const overlay = document.querySelector('.vl-supercluster-overlay');
            const header = document.querySelector('.vl-header');
            const mainMenu = document.querySelector('.vl-main-menu');
            const rightSidebar = document.querySelector('.vl-right-sidebar');
            
            if (overlay) {
                overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (header) {
                header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (mainMenu) {
                mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (rightSidebar) {
                rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            
            // Map category slug to galaxy name
            const slugToGalaxyMap = {
                'website-infrastructure-performance': 'Website Infrastructure & Performance',
                'content-management-structure': 'Content Management & Structure',
                'search-engine-intelligence': 'Search Engine Intelligence',
                'analytics-engagement': 'Analytics & Engagement',
                'marketing-campaign-data': 'Marketing & Campaign Data',
                'e-commerce-conversion-data': 'E-Commerce & Conversion Data',
                'security-compliance-data': 'Security & Compliance Data',
                'cloudops-infrastructure-metrics': 'CloudOps & Infrastructure Metrics',
                'user-identity-layer': 'User & Identity Layer',
                'competitive-market-data': 'Competitive & Market Data'
            };
            
            const galaxyName = slugToGalaxyMap[categorySlug] || categorySlug;
            
            // Find the galaxy data
            const galaxy = galaxyData.find(g => g.name === galaxyName);
            if (!galaxy) {
                document.body.innerHTML = '<div><h1>Category Not Found</h1><p>Unable to find category: ' + categorySlug + '</p></div>';
                return;
            }
            
            // Fetch all streams for this category
            try {
                const connectionsResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (!connectionsResponse.ok) {
                    throw new Error('Failed to fetch connections data');
                }
                
                const connectionsResponseData = await connectionsResponse.json();
                // all-connections returns {ok: true, data: {...}} structure
                const connectionsData = connectionsResponseData?.ok && connectionsResponseData?.data ? connectionsResponseData.data : connectionsResponseData;
                // all-connections returns client_streams in the data object
                const streams = connectionsData && connectionsData.client_streams ? connectionsData.client_streams : {};
                const streamArray = extractActiveStreams(streams);
                
                // Filter streams by category (match datasetSlugs)
                const categoryStreams = streamArray.filter(s => {
                    if (!s.categories || !Array.isArray(s.categories)) return false;
                    // Check if any stream category matches any galaxy dataset slug
                    return s.categories.some(cat => 
                        galaxy.datasetSlugs.some(slug => 
                            cat.toLowerCase().includes(slug.toLowerCase()) || 
                            slug.toLowerCase().includes(cat.toLowerCase())
                        )
                    );
                });
                
                // Build HTML
                let html = '<div class="category-page-content">';
                html += '<h1>' + galaxyName + '</h1>';
                html += '<p>' + (galaxy.description || galaxy.fallbackDescription || '') + '</p>';
                
                if (categoryStreams.length === 0) {
                    html += '<p>No data streams found for this category.</p>';
                } else {
                    html += '<h2>Data Streams (' + categoryStreams.length + ')</h2>';
                    html += '<div class="streams-grid">';
                    
                    categoryStreams.forEach(stream => {
                        html += '<div class="stream-card">';
                        html += '<h3>' + (stream.name || 'Unnamed Stream') + '</h3>';
                        html += '<div><strong>Stream ID:</strong> ' + (stream.id || 'N/A') + '</div>';
                        html += '<div><strong>Health Score:</strong> ' + (stream.health_score || 'N/A') + '</div>';
                        html += '<div><strong>Status:</strong> ' + (stream.status || 'N/A') + '</div>';
                        if (stream.last_updated) {
                            html += '<div><strong>Last Updated:</strong> ' + stream.last_updated + '</div>';
                        }
                        // Add link to view stream details
                        const streamUrl = buildStreamDataUrl(licenseKey, stream);
                        html += '<div class="stream-link"><a href="' + streamUrl + '">View Stream Details</a></div>';
                        html += '</div>';
                    });
                    
                    html += '</div>';
                }
                
                html += '</div>';
                
                // Insert content into page content container (preserving overlay)
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.innerHTML = html;
            } else {
                    console.error('Page content container not found');
                }
            } catch (error) {
                console.error('Error rendering category page:', error);
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.innerHTML = '<div class="error-content"><h1>Error</h1><p>Failed to load category data: ' + error.message + '</p></div>';
                }
            }
        }

        // Render stream data page - replaces Supercluster visualization with data stream view
        async function renderStreamDataPage(licenseKey, category, streamType, uniqueId) {
            console.log('Rendering stream data page:', { licenseKey, category, streamType, uniqueId });
            
            // Hide only the Three.js canvas, keep container visible
            hideThreeJSCanvas();
            // Hide labels on internal pages
            hideSuperclusterLabels();
            
            // Show the page content container
            const pageContent = document.getElementById('vlPageContent');
            if (pageContent) {
                pageContent.style.display = 'block';
            }
            
            // Ensure body has black background
            document.body.style.backgroundColor = '#000000';
            
            // Ensure overlays and menus remain visible (same as initialization)
            const overlay = document.querySelector('.vl-supercluster-overlay');
            const header = document.querySelector('.vl-header');
            const mainMenu = document.querySelector('.vl-main-menu');
            const rightSidebar = document.querySelector('.vl-right-sidebar');
            
            if (overlay) {
                overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (header) {
                header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (mainMenu) {
                mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (rightSidebar) {
                rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            
            // Fetch stream data from VL Hub
            // Try /content endpoint first for WordPress data, then fallback to /all-connections
            try {
                let streams = {};
                let connectionsData = {};
                let contentData = null;

                const mergeWordPressData = (target, source) => {
                    if (!target || !source || typeof source !== 'object') return;

                    const candidates = [
                        source,
                        source.data,
                        source.wordpress_content,
                        source.data && source.data.wordpress_content
                    ].filter(Boolean);

                    const coerceArray = (value) => Array.isArray(value) ? value : [];

                    const mergeList = (key, list) => {
                        if (Array.isArray(list) && list.length > 0 && (!target[key] || target[key].length === 0)) {
                            target[key] = list;
                        }
                    };

                    candidates.forEach(candidate => {
                        mergeList('posts_data', coerceArray(candidate.posts_data || candidate.posts || candidate.wordpress_posts || (candidate.content && candidate.content.posts)));
                        mergeList('pages_data', coerceArray(candidate.pages_data || candidate.pages || candidate.wordpress_pages || (candidate.content && candidate.content.pages)));
                        mergeList('plugins_data', coerceArray(candidate.plugins_data || candidate.plugins));
                        mergeList('themes_data', coerceArray(candidate.themes_data || candidate.themes));
                        mergeList('users_data', coerceArray(candidate.users_data || candidate.users || candidate.wordpress_users));
                        mergeList('comments_data', coerceArray(candidate.comments_data || candidate.comments));

                        if (!target.wp_core_data && candidate.wp_core_data && typeof candidate.wp_core_data === 'object') {
                            target.wp_core_data = candidate.wp_core_data;
                        }

                        const totals = [
                            ['posts_total', 'total_posts', candidate.posts_total],
                            ['pages_total', 'total_pages', candidate.pages_total],
                            ['users_total', 'total_users', candidate.users_total],
                            ['comments_total', 'total_comments', candidate.comments_total],
                            ['plugins_total', 'total_plugins', candidate.plugins_total],
                            ['plugins_active', 'active_plugins', candidate.plugins_active],
                            ['plugins_needing_update', 'plugins_needing_update', candidate.plugins_needing_update],
                            ['themes_total', 'total_themes', candidate.themes_total],
                            ['themes_needing_update', 'themes_needing_update', candidate.themes_needing_update]
                        ];

                        totals.forEach(([targetKey, altKey, directValue]) => {
                            if (target[targetKey] === undefined) {
                                if (directValue !== undefined) {
                                    target[targetKey] = directValue;
                                } else if (candidate[altKey] !== undefined) {
                                    target[targetKey] = candidate[altKey];
                                }
                            }
                        });
                    });

                    if (target.posts_total === undefined && target.posts_data && target.posts_data.length) {
                        target.posts_total = target.posts_data.length;
                    }
                    if (target.pages_total === undefined && target.pages_data && target.pages_data.length) {
                        target.pages_total = target.pages_data.length;
                    }
                    if (target.users_total === undefined && target.users_data && target.users_data.length) {
                        target.users_total = target.users_data.length;
                    }
                    if (target.plugins_total === undefined && target.plugins_data && target.plugins_data.length) {
                        target.plugins_total = target.plugins_data.length;
                    }
                    if (target.themes_total === undefined && target.themes_data && target.themes_data.length) {
                        target.themes_total = target.themes_data.length;
                    }
                };
                
                // First, try the /content endpoint which might have better WordPress data structure
                try {
                    console.log('[Stream Data] Fetching from /content endpoint...');
                    const contentResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/content?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                    if (contentResponse.ok) {
                        const contentResponseData = await contentResponse.json();
                        contentData = contentResponseData?.ok && contentResponseData?.data ? contentResponseData.data : contentResponseData;
                        console.log('[Stream Data] /content endpoint response received');
                        console.log('[Stream Data] Content data keys:', contentData ? Object.keys(contentData) : 'null');
                        
                        // Check if content endpoint has WordPress data directly
                        if (contentData && typeof contentData === 'object') {
                            // Content endpoint might have streams or client_streams
                            if (contentData.client_streams) {
                                streams = contentData.client_streams;
                                connectionsData = contentData;
                                console.log('[Stream Data] Found client_streams in /content response');
                            } else if (contentData.streams) {
                                streams = contentData.streams;
                                connectionsData = contentData;
                                console.log('[Stream Data] Found streams in /content response');
                            } else {
                                // Content might be structured differently - check for WordPress data at root level
                                console.log('[Stream Data] /content response structure:', Object.keys(contentData));
                            }
                        }
                    }
                } catch (contentError) {
                    console.warn('[Stream Data] Could not fetch from /content endpoint:', contentError);
                }
                
                // Also fetch from /all-connections as fallback/merge source
                console.log('[Stream Data] Fetching from /all-connections endpoint...');
                const connectionsResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (connectionsResponse.ok) {
                const connectionsResponseData = await connectionsResponse.json();
                // all-connections returns {ok: true, data: {...}} structure
                    const allConnectionsData = connectionsResponseData?.ok && connectionsResponseData?.data ? connectionsResponseData.data : connectionsResponseData;
                    
                    // Merge data from all-connections if we don't have it from content
                    if (!streams || Object.keys(streams).length === 0) {
                        streams = allConnectionsData && allConnectionsData.client_streams ? allConnectionsData.client_streams : {};
                        connectionsData = allConnectionsData;
                        console.log('[Stream Data] Using streams from /all-connections');
                    } else {
                        // Merge streams from both endpoints
                        const allConnectionsStreams = allConnectionsData && allConnectionsData.client_streams ? allConnectionsData.client_streams : {};
                        if (allConnectionsStreams && typeof allConnectionsStreams === 'object') {
                            // Merge streams, preferring content endpoint data
                            for (const key in allConnectionsStreams) {
                                if (!streams[key]) {
                                    streams[key] = allConnectionsStreams[key];
                                }
                            }
                            console.log('[Stream Data] Merged streams from both endpoints');
                        }
                        connectionsData = allConnectionsData;
                    }
                } else {
                    if (!streams || Object.keys(streams).length === 0) {
                        throw new Error('Failed to fetch connections data from both endpoints');
                    }
                }
                
                const streamArray = extractActiveStreams(streams);
                
                // Find the matching stream
                let stream = null;
                let streamId = null;
                
                if (streamType === 'competitive-analysis') {
                    // For competitor analysis, find by competitor_url, source_url, or name
                    stream = streamArray.find(s => {
                        // Check if stream name contains the competitor URL
                        if (s.name && s.name.includes(uniqueId)) {
                            return true;
                        }
                        // Check various URL fields
                        if (s.competitor_url === uniqueId || 
                            s.source_url === uniqueId || 
                            s.url === uniqueId) {
                            return true;
                        }
                        // Check report_data
                        if (s.report_data && (
                            s.report_data.competitor_url === uniqueId ||
                            s.report_data.url === uniqueId
                        )) {
                            return true;
                        }
                        // Check if stream ID contains competitor URL
                        if (s.id && s.id.includes(uniqueId.replace(/[^a-zA-Z0-9]/g, '_'))) {
                            return true;
                        }
                        return false;
                    });
            } else {
                    // For other streams, find by ID or URL
                    stream = streamArray.find(s => 
                        s.id === uniqueId || 
                        s.source_url === uniqueId || 
                        s.url === uniqueId ||
                        s.competitor_url === uniqueId ||
                        (s.name && s.name.includes(uniqueId))
                    );
                }
                
                if (!stream) {
                    // Try to find by stream ID pattern
                    const streamIdPattern = streamType.replace(/-/g, '_');
                    stream = streamArray.find(s => s.id && s.id.includes(streamIdPattern));
                }
                
                // If still not found and it's a competitor analysis, try to find any competitor stream
                if (!stream && streamType === 'competitive-analysis') {
                    stream = streamArray.find(s => 
                        s.id && s.id.includes('competitor') ||
                        (s.categories && s.categories.includes('competitive'))
                    );
                }
                
                if (!stream) {
                    const pageContent = document.getElementById('vlPageContent');
                    if (pageContent) {
                        pageContent.innerHTML = '<div class="error-content"><h1>Stream Data Not Found</h1><p>Unable to find stream data for: ' + uniqueId + '</p></div>';
                    }
                    return;
                }
                
                // Get the stream ID to look up full data in original streams object
                streamId = stream.id;
                
                // CRITICAL: For WordPress streams, get the FULL stream data from the original streams object
                // The extractActiveStreams might have lost nested data, so we need to get it from the original structure
                
                console.log('[Stream Data] === SEARCHING FOR WORDPRESS DATA ===');
                console.log('[Stream Data] Stream ID:', streamId);
                console.log('[Stream Data] Stream name:', stream.name);
                console.log('[Stream Data] Stream type:', streamType);
                console.log('[Stream Data] Current stream.posts_data:', !!stream.posts_data, stream.posts_data?.length);
                console.log('[Stream Data] Current stream.pages_data:', !!stream.pages_data, stream.pages_data?.length);
                console.log('[Stream Data] Current stream.plugins_data:', !!stream.plugins_data, stream.plugins_data?.length);
                console.log('[Stream Data] Current stream.themes_data:', !!stream.themes_data, stream.themes_data?.length);
                console.log('[Stream Data] Current stream.users_data:', !!stream.users_data, stream.users_data?.length);
                console.log('[Stream Data] Streams object type:', typeof streams);
                console.log('[Stream Data] Streams object keys count:', streams && typeof streams === 'object' ? Object.keys(streams).length : 0);
                
                // ALWAYS search for WordPress data in original streams object and merge it
                // This ensures we get ALL the data, not just what's in the extracted stream
                if (streams && typeof streams === 'object' && !Array.isArray(streams)) {
                    console.log('[Stream Data] Data missing, searching in original streams object...');
                    console.log('[Stream Data] streams object type:', typeof streams);
                    console.log('[Stream Data] streams keys:', Object.keys(streams).slice(0, 20));
                    
                    // Search through ALL streams to find WordPress data
                    // Don't rely on ID matching - search by content
                    console.log('[Stream Data] Searching through ALL streams for WordPress data...');
                    let foundWordPressData = false;
                    
                    for (const key in streams) {
                        if (streams.hasOwnProperty(key)) {
                            const candidateStream = streams[key];
                            if (candidateStream && typeof candidateStream === 'object') {
                                // Check if this is a WordPress stream by looking for WordPress-specific data
                                const hasWordPressData = candidateStream.wp_version || 
                                                        candidateStream.posts_data || 
                                                        candidateStream.pages_data || 
                                                        candidateStream.plugins_data || 
                                                        candidateStream.themes_data ||
                                                        candidateStream.users_data ||
                                                        (candidateStream.id && candidateStream.id.includes('wordpress')) ||
                                                        (candidateStream.categories && Array.isArray(candidateStream.categories) && candidateStream.categories.includes('cms')) ||
                                                        (candidateStream.name && candidateStream.name.toLowerCase().includes('wordpress'));
                                
                                if (hasWordPressData) {
                                    console.log('[Stream Data] ✓✓✓ FOUND WORDPRESS STREAM in streams[' + key + ']');
                                    console.log('[Stream Data] Candidate stream ID:', candidateStream.id);
                                    console.log('[Stream Data] Candidate stream name:', candidateStream.name);
                                    console.log('[Stream Data] Candidate stream ALL keys:', Object.keys(candidateStream));
                                    console.log('[Stream Data] Candidate has posts_data:', !!candidateStream.posts_data, candidateStream.posts_data?.length);
                                    console.log('[Stream Data] Candidate has pages_data:', !!candidateStream.pages_data, candidateStream.pages_data?.length);
                                    console.log('[Stream Data] Candidate has plugins_data:', !!candidateStream.plugins_data, candidateStream.plugins_data?.length);
                                    console.log('[Stream Data] Candidate has themes_data:', !!candidateStream.themes_data, candidateStream.themes_data?.length);
                                    console.log('[Stream Data] Candidate has users_data:', !!candidateStream.users_data, candidateStream.users_data?.length);
                                    
                                    // Log the full candidate stream structure to see what we're working with
                                    console.log('[Stream Data] Candidate stream FULL object (first 3000 chars):', JSON.stringify(candidateStream, null, 2).substring(0, 3000));
                                    
                                    // Check if data might be in a 'data' property
                                    if (candidateStream.data && typeof candidateStream.data === 'object') {
                                        console.log('[Stream Data] Candidate has .data property with keys:', Object.keys(candidateStream.data));
                                        if (candidateStream.data.posts_data) {
                                            console.log('[Stream Data] Found posts_data in candidateStream.data!');
                                            candidateStream.posts_data = candidateStream.data.posts_data;
                                        }
                                        if (candidateStream.data.pages_data) {
                                            console.log('[Stream Data] Found pages_data in candidateStream.data!');
                                            candidateStream.pages_data = candidateStream.data.pages_data;
                                        }
                                        if (candidateStream.data.plugins_data) {
                                            console.log('[Stream Data] Found plugins_data in candidateStream.data!');
                                            candidateStream.plugins_data = candidateStream.data.plugins_data;
                                        }
                                        if (candidateStream.data.themes_data) {
                                            console.log('[Stream Data] Found themes_data in candidateStream.data!');
                                            candidateStream.themes_data = candidateStream.data.themes_data;
                                        }
                                        if (candidateStream.data.users_data) {
                                            console.log('[Stream Data] Found users_data in candidateStream.data!');
                                            candidateStream.users_data = candidateStream.data.users_data;
                                        }
                                    }
                                    
                                    foundWordPressData = true;
                                    
                                    // FORCE MERGE ALL WordPress data - don't check if it already exists
                                    if (candidateStream.posts_data && Array.isArray(candidateStream.posts_data)) {
                                        stream.posts_data = candidateStream.posts_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED posts_data:', candidateStream.posts_data.length, 'posts');
                                    }
                                    if (candidateStream.pages_data && Array.isArray(candidateStream.pages_data)) {
                                        stream.pages_data = candidateStream.pages_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED pages_data:', candidateStream.pages_data.length, 'pages');
                                    }
                                    if (candidateStream.plugins_data && Array.isArray(candidateStream.plugins_data)) {
                                        stream.plugins_data = candidateStream.plugins_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED plugins_data:', candidateStream.plugins_data.length, 'plugins');
                                    }
                                    if (candidateStream.themes_data && Array.isArray(candidateStream.themes_data)) {
                                        stream.themes_data = candidateStream.themes_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED themes_data:', candidateStream.themes_data.length, 'themes');
                                    }
                                    if (candidateStream.users_data && Array.isArray(candidateStream.users_data)) {
                                        stream.users_data = candidateStream.users_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED users_data:', candidateStream.users_data.length, 'users');
                                    }
                                    if (candidateStream.comments_data && Array.isArray(candidateStream.comments_data)) {
                                        stream.comments_data = candidateStream.comments_data;
                                    }
                                    if (candidateStream.wp_core_data && typeof candidateStream.wp_core_data === 'object') {
                                        stream.wp_core_data = candidateStream.wp_core_data;
                                        console.log('[Stream Data] ✓✓✓ MERGED wp_core_data');
                                    }
                                    if (candidateStream.content_metrics && typeof candidateStream.content_metrics === 'object') {
                                        stream.content_metrics = candidateStream.content_metrics;
                                        console.log('[Stream Data] ✓✓✓ MERGED content_metrics');
                                    }
                                    // Merge all other WordPress-specific fields
                                    if (candidateStream.wp_version) stream.wp_version = candidateStream.wp_version;
                                    if (candidateStream.php_version) stream.php_version = candidateStream.php_version;
                                    if (candidateStream.mysql_version) stream.mysql_version = candidateStream.mysql_version;
                                    if (candidateStream.posts_total !== undefined) stream.posts_total = candidateStream.posts_total;
                                    if (candidateStream.pages_total !== undefined) stream.pages_total = candidateStream.pages_total;
                                    if (candidateStream.users_total !== undefined) stream.users_total = candidateStream.users_total;
                                    if (candidateStream.comments_total !== undefined) stream.comments_total = candidateStream.comments_total;
                                    if (candidateStream.plugins_total !== undefined) stream.plugins_total = candidateStream.plugins_total;
                                    if (candidateStream.plugins_active !== undefined) stream.plugins_active = candidateStream.plugins_active;
                                    if (candidateStream.plugins_needing_update !== undefined) stream.plugins_needing_update = candidateStream.plugins_needing_update;
                                    if (candidateStream.themes_total !== undefined) stream.themes_total = candidateStream.themes_total;
                                    if (candidateStream.themes_needing_update !== undefined) stream.themes_needing_update = candidateStream.themes_needing_update;
                                    
                                    // Break after finding first WordPress stream with data
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (!foundWordPressData) {
                        console.warn('[Stream Data] ⚠⚠⚠ NO WORDPRESS DATA FOUND IN STREAMS OBJECT');
                        console.log('[Stream Data] Available stream keys:', Object.keys(streams).slice(0, 10));
                    }
                }
                
                // Final check: Log what we have after all merging
                console.log('[Stream Data] === FINAL CHECK AFTER MERGING ===');
                console.log('[Stream Data] stream.posts_data:', !!stream.posts_data, stream.posts_data?.length);
                console.log('[Stream Data] stream.pages_data:', !!stream.pages_data, stream.pages_data?.length);
                console.log('[Stream Data] stream.plugins_data:', !!stream.plugins_data, stream.plugins_data?.length);
                console.log('[Stream Data] stream.themes_data:', !!stream.themes_data, stream.themes_data?.length);
                console.log('[Stream Data] stream.users_data:', !!stream.users_data, stream.users_data?.length);
                
                // Also check if WordPress data is nested in connectionsData directly (not in client_streams)
                if (connectionsData && typeof connectionsData === 'object') {
                    // Check for WordPress data at the connectionsData level
                    if (connectionsData.posts_data && Array.isArray(connectionsData.posts_data) && !stream.posts_data) {
                        stream.posts_data = connectionsData.posts_data;
                    }
                    if (connectionsData.pages_data && Array.isArray(connectionsData.pages_data) && !stream.pages_data) {
                        stream.pages_data = connectionsData.pages_data;
                    }
                    if (connectionsData.plugins_data && Array.isArray(connectionsData.plugins_data) && !stream.plugins_data) {
                        stream.plugins_data = connectionsData.plugins_data;
                    }
                    if (connectionsData.themes_data && Array.isArray(connectionsData.themes_data) && !stream.themes_data) {
                        stream.themes_data = connectionsData.themes_data;
                    }
                    if (connectionsData.users_data && Array.isArray(connectionsData.users_data) && !stream.users_data) {
                        stream.users_data = connectionsData.users_data;
                    }
                }
                
                // For competitor analysis, also fetch detailed report from database
                if (streamType === 'competitive-analysis' && uniqueId) {
                    try {
                        const reportResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/competitor-report?license=${encodeURIComponent(licenseKey)}&competitor_url=${encodeURIComponent(uniqueId)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (reportResponse.ok) {
                            const reportData = await reportResponse.json();
                            if (reportData && reportData.success && reportData.report) {
                                // Merge report data into stream
                                stream.report_data = reportData.report;
                            }
                        }
                    } catch (reportError) {
                        console.warn('Could not fetch detailed competitor report:', reportError);
                        // Continue with stream data anyway
                    }
                }
                
                // Debug: Log what we have in the stream object
                console.log('[Stream Data] Stream object keys:', Object.keys(stream));
                console.log('[Stream Data] Stream ID:', stream.id);
                console.log('[Stream Data] Has posts_data:', !!stream.posts_data, stream.posts_data?.length);
                console.log('[Stream Data] Has pages_data:', !!stream.pages_data, stream.pages_data?.length);
                console.log('[Stream Data] Has plugins_data:', !!stream.plugins_data, stream.plugins_data?.length);
                console.log('[Stream Data] Has themes_data:', !!stream.themes_data, stream.themes_data?.length);
                console.log('[Stream Data] Has users_data:', !!stream.users_data, stream.users_data?.length);
                console.log('[Stream Data] Original streams object keys:', streams && typeof streams === 'object' ? Object.keys(streams) : 'N/A');
                
                // Check if this is a WordPress stream before fetching additional data
                const isWordPressStream = stream.wp_version || stream.wp_core_data || stream.posts_data || stream.pages_data || 
                                          stream.plugins_data || stream.themes_data || stream.users_data ||
                                          (stream.id && stream.id.includes('wordpress')) ||
                                          streamType === 'wordpress-data';
                
                // For WordPress streams, ALWAYS try to fetch detailed data from /content endpoint first, then /all-connections
                // /content endpoint might have better WordPress data structure
                if (isWordPressStream) {
                    try {
                        // Try /content endpoint first
                        console.log('[Stream Data] Fetching additional WordPress data from /content endpoint...');
                        const contentResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/content?license=${encodeURIComponent(licenseKey)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (contentResponse.ok) {
                            const contentResponseData = await contentResponse.json();
                            const contentData = contentResponseData?.ok && contentResponseData?.data ? contentResponseData.data : contentResponseData;
                            const contentStreams = contentData && contentData.client_streams ? contentData.client_streams : (contentData && contentData.streams ? contentData.streams : {});
                            
                            console.log('[Stream Data] /content endpoint response received');
                            console.log('[Stream Data] Content streams keys:', Object.keys(contentStreams).slice(0, 10));
                            
                            // Search for WordPress data in /content response
                            if (contentStreams && typeof contentStreams === 'object' && !Array.isArray(contentStreams)) {
                                for (const key in contentStreams) {
                                    if (contentStreams.hasOwnProperty(key)) {
                                        const candidateStream = contentStreams[key];
                                        if (candidateStream && typeof candidateStream === 'object') {
                                            const hasWordPressData = candidateStream.wp_version || 
                                                                    candidateStream.posts_data || 
                                                                    candidateStream.pages_data || 
                                                                    candidateStream.plugins_data || 
                                                                    candidateStream.themes_data ||
                                                                    candidateStream.users_data ||
                                                                    (candidateStream.id && candidateStream.id.includes('wordpress')) ||
                                                                    (candidateStream.categories && Array.isArray(candidateStream.categories) && candidateStream.categories.includes('cms')) ||
                                                                    (candidateStream.name && candidateStream.name.toLowerCase().includes('wordpress'));
                                            
                                            if (hasWordPressData) {
                                                console.log('[Stream Data] ✓✓✓ FOUND WORDPRESS DATA in /content endpoint streams[' + key + ']');
                                                mergeWordPressData(stream, candidateStream);
                                                break;
                                            }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Also check if WordPress data is at the root level of /content response
                            if (contentData && typeof contentData === 'object') {
                                mergeWordPressData(stream, contentData);
                            }

                        // Try /data-streams endpoint which might have the full nested data
                        console.log('[Stream Data] Fetching from /data-streams endpoint for full stream data...');
                        try {
                            const dataStreamsResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/data-streams?license=${encodeURIComponent(licenseKey)}`, {
                                method: 'GET',
                                headers: { 'Content-Type': 'application/json' },
                                credentials: 'include'
                            });
                            
                            if (dataStreamsResponse.ok) {
                                const dataStreamsData = await dataStreamsResponse.json();
                                const dataStreams = dataStreamsData?.ok && dataStreamsData?.data ? dataStreamsData.data : dataStreamsData;
                                const dataStreamsStreams = dataStreams && dataStreams.client_streams ? dataStreams.client_streams : (dataStreams && dataStreams.streams ? dataStreams.streams : {});
                                
                                console.log('[Stream Data] /data-streams response received');
                                console.log('[Stream Data] Data streams keys:', Object.keys(dataStreamsStreams).slice(0, 10));
                                
                                // Search for WordPress stream in /data-streams
                                if (dataStreamsStreams && typeof dataStreamsStreams === 'object' && !Array.isArray(dataStreamsStreams)) {
                                    for (const key in dataStreamsStreams) {
                                        if (dataStreamsStreams.hasOwnProperty(key)) {
                                            const candidateStream = dataStreamsStreams[key];
                                            if (candidateStream && typeof candidateStream === 'object') {
                                                const isWordPress = candidateStream.wp_version || 
                                                                    candidateStream.posts_data || 
                                                                    candidateStream.pages_data || 
                                                                    candidateStream.plugins_data || 
                                                                    candidateStream.themes_data ||
                                                                    (candidateStream.id && candidateStream.id.includes('wordpress'));
                                                
                                                if (isWordPress) {
                                                    console.log('[Stream Data] ✓✓✓ FOUND WORDPRESS STREAM in /data-streams[' + key + ']');
                                                    mergeWordPressData(stream, candidateStream);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } catch (dataStreamsError) {
                            console.warn('[Stream Data] Could not fetch from /data-streams endpoint:', dataStreamsError);
                        }
                        
                        // Also try /all-connections as fallback/merge source
                        console.log('[Stream Data] Fetching additional data from /all-connections endpoint...');
                        const allConnectionsResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (allConnectionsResponse.ok) {
                            const allConnectionsData = await allConnectionsResponse.json();
                            // all-connections returns {ok: true, data: {...}} structure
                            const allConnections = allConnectionsData?.ok && allConnectionsData?.data ? allConnectionsData.data : allConnectionsData;
                            const allConnectionsStreams = allConnections && allConnections.client_streams ? allConnections.client_streams : {};
                            
                            console.log('[Stream Data] /all-connections response received');
                            
                            // Try to find WordPress data in all-connections response
                            if (allConnectionsStreams && typeof allConnectionsStreams === 'object' && !Array.isArray(allConnectionsStreams)) {
                                // Search through all streams in all-connections
                                for (const key in allConnectionsStreams) {
                                    if (allConnectionsStreams.hasOwnProperty(key)) {
                                        const candidateStream = allConnectionsStreams[key];
                                        if (candidateStream && typeof candidateStream === 'object') {
                                            // Check if this is a WordPress stream
                                            const isWordPress = candidateStream.wp_version || candidateStream.posts_data || candidateStream.pages_data || 
                                                                candidateStream.plugins_data || candidateStream.themes_data ||
                                                                (candidateStream.id && candidateStream.id.includes('wordpress')) ||
                                                                (candidateStream.categories && Array.isArray(candidateStream.categories) && candidateStream.categories.includes('cms'));
                                            
                                            if (isWordPress) {
                                                console.log('[Stream Data] Found WordPress stream in all-connections[' + key + ']');
                                                console.log('[Stream Data] All-connections candidate ALL keys:', Object.keys(candidateStream));
                                                
                                                // Check if data is nested in a 'data' property
                                                const streamData = candidateStream.data || candidateStream;
                                                console.log('[Stream Data] Checking streamData.posts_data:', !!streamData.posts_data, streamData.posts_data?.length);
                                                
                                                // Check if this matches our stream or is the WordPress stream we need
                                                if (candidateStream.id === stream.id || 
                                                    !stream.id || 
                                                    stream.id.includes('wordpress') ||
                                                    (candidateStream.id && stream.id && candidateStream.id.includes(stream.id)) ||
                                                    (stream.id && candidateStream.id && stream.id.includes(candidateStream.id))) {
                                                    
                                                    mergeWordPressData(stream, streamData);
                                                    break; // Found and merged, exit loop
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                // Also check if WordPress data is at the all-connections level (not in client_streams)
                                if (allConnections && typeof allConnections === 'object') {
                                    mergeWordPressData(stream, allConnections);
                                    if (allConnections.posts_data && Array.isArray(allConnections.posts_data) && !stream.posts_data) {
                                        stream.posts_data = allConnections.posts_data;
                                        console.log('[Stream Data] ✓ Merged posts_data from all-connections root level');
                                    }
                                    if (allConnections.pages_data && Array.isArray(allConnections.pages_data) && !stream.pages_data) {
                                        stream.pages_data = allConnections.pages_data;
                                        console.log('[Stream Data] ✓ Merged pages_data from all-connections root level');
                                    }
                                    if (allConnections.plugins_data && Array.isArray(allConnections.plugins_data) && !stream.plugins_data) {
                                        stream.plugins_data = allConnections.plugins_data;
                                        console.log('[Stream Data] ✓ Merged plugins_data from all-connections root level');
                                    }
                                    if (allConnections.themes_data && Array.isArray(allConnections.themes_data) && !stream.themes_data) {
                                        stream.themes_data = allConnections.themes_data;
                                        console.log('[Stream Data] ✓ Merged themes_data from all-connections root level');
                                    }
                                    if (allConnections.users_data && Array.isArray(allConnections.users_data) && !stream.users_data) {
                                        stream.users_data = allConnections.users_data;
                                        console.log('[Stream Data] ✓ Merged users_data from all-connections root level');
                                    }

                                    if (allConnections.wordpress_content && typeof allConnections.wordpress_content === 'object') {
                                        const wc = allConnections.wordpress_content;
                                        if (wc.posts && Array.isArray(wc.posts) && !stream.posts_data) {
                                            stream.posts_data = wc.posts;
                                            console.log('[Stream Data] ✓ Merged wordpress_content.posts from all-connections');
                                        }
                                        if (wc.pages && Array.isArray(wc.pages) && !stream.pages_data) {
                                            stream.pages_data = wc.pages;
                                            console.log('[Stream Data] ✓ Merged wordpress_content.pages from all-connections');
                                        }
                                        if (wc.total_posts !== undefined && stream.posts_total === undefined) {
                                            stream.posts_total = wc.total_posts;
                                        }
                                        if (wc.total_pages !== undefined && stream.pages_total === undefined) {
                                            stream.pages_total = wc.total_pages;
                                        }
                                        if (wc.total_comments !== undefined && stream.comments_total === undefined) {
                                            stream.comments_total = wc.total_comments;
                                        }
                                    }

                                    if (allConnections.wordpress_users && Array.isArray(allConnections.wordpress_users) && !stream.users_data) {
                                        stream.users_data = allConnections.wordpress_users;
                                        console.log('[Stream Data] ✓ Merged wordpress_users from all-connections');
                                    }
                                }
                            }
                        }
                    } catch (allConnectionsError) {
                        console.warn('Could not fetch detailed data from all-connections endpoint:', allConnectionsError);
                        // Continue with existing stream data
                    }
                }
                
                // Render the data stream page
                renderStreamDataContent(stream, uniqueId, streamType);
                
            } catch (error) {
                console.error('Error rendering stream data page:', error);
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.innerHTML = '<div class="error-content"><h1>Error Loading Stream Data</h1><p>' + error.message + '</p></div>';
                }
            }
        }
        
        // Render stream data content (all data from VL Hub)
        function renderStreamDataContent(stream, uniqueId, streamType) {
            let html = '<div class="stream-data-page" style="padding: 40px; color: #fff4e9; max-width: 1200px; margin: 0 auto; min-height: 100vh;">';
            
            // Stream Header
            html += '<h1 style="margin-bottom: 10px;">' + (stream.name || 'Data Stream') + '</h1>';
            if (stream.description) {
                html += '<p style="margin-bottom: 30px; opacity: 0.8;">' + stream.description + '</p>';
            }
            if (stream.url) {
                html += '<p style="margin-bottom: 30px;"><a href="' + stream.url + '" target="_blank" style="color: #fff4e9; text-decoration: underline;">' + stream.url + '</a></p>';
            }
            
            // Check if this is a WordPress data stream (re-check in case data was added)
            const isWordPressStream = stream.wp_version || stream.wp_core_data || stream.posts_data || stream.pages_data ||
                                      stream.plugins_data || stream.themes_data || stream.users_data || stream.wordpress_content ||
                                      stream.wordpress_users || (stream.id && stream.id.includes('wordpress')) ||
                                      streamType === 'wordpress-data';
            
            // Debug: Log stream data structure
            console.log('[Stream Data] WordPress stream detected:', isWordPressStream);
            console.log('[Stream Data] Stream keys:', Object.keys(stream));
            console.log('[Stream Data] Has posts_data:', !!stream.posts_data, stream.posts_data?.length);
            console.log('[Stream Data] Has pages_data:', !!stream.pages_data, stream.pages_data?.length);
            console.log('[Stream Data] Has plugins_data:', !!stream.plugins_data, stream.plugins_data?.length);
            console.log('[Stream Data] Has themes_data:', !!stream.themes_data, stream.themes_data?.length);
            console.log('[Stream Data] Has users_data:', !!stream.users_data, stream.users_data?.length);
            
            if (isWordPressStream) {
                const wpContent = stream.wordpress_content || {};
                if (stream.posts_total === undefined && wpContent.total_posts !== undefined) {
                    stream.posts_total = wpContent.total_posts;
                }
                if (stream.pages_total === undefined && wpContent.total_pages !== undefined) {
                    stream.pages_total = wpContent.total_pages;
                }
                if (stream.comments_total === undefined && wpContent.total_comments !== undefined) {
                    stream.comments_total = wpContent.total_comments;
                }

                const arrayFrom = (...candidates) => {
                    for (const candidate of candidates) {
                        if (Array.isArray(candidate) && candidate.length) {
                            return candidate;
                        }
                    }
                    return [];
                };

                const postsData = arrayFrom(
                    stream.posts_data,
                    stream.posts,
                    stream.data && stream.data.posts_data,
                    stream.data && stream.data.posts,
                    wpContent.posts
                );
                const pagesData = arrayFrom(
                    stream.pages_data,
                    stream.pages,
                    stream.data && stream.data.pages_data,
                    stream.data && stream.data.pages,
                    wpContent.pages
                );
                const usersData = arrayFrom(
                    stream.users_data,
                    stream.users,
                    stream.data && stream.data.users_data,
                    stream.data && stream.data.users,
                    stream.wordpress_users
                );
                const pluginsData = arrayFrom(
                    stream.plugins_data,
                    stream.plugins,
                    stream.data && stream.data.plugins_data,
                    stream.data && stream.data.plugins
                );
                const themesData = arrayFrom(
                    stream.themes_data,
                    stream.themes,
                    stream.data && stream.data.themes_data,
                    stream.data && stream.data.themes
                );

                const contentMetrics = stream.content_metrics || (stream.metrics && stream.metrics.wordpress) || {};
                const coreData = stream.wp_core_data || {};

                const summarizeCore = () => {
                    const bits = [];
                    if (stream.wp_version) bits.push(`WordPress ${stream.wp_version}`);
                    if (stream.php_version) bits.push(`PHP ${stream.php_version}`);
                    if (stream.mysql_version) bits.push(`MySQL ${stream.mysql_version}`);
                    if (coreData.core_update_available) bits.push('core updates pending');
                    const issues = [];
                    if (stream.error_count > 0) issues.push(`${stream.error_count} critical issues reported`);
                    if (stream.warning_count > 0) issues.push(`${stream.warning_count} warnings observed`);
                    const healthLine = issues.length ? issues.join(' and ') : 'no active errors or warnings detected';
                    const stack = bits.length ? bits.join(', ') : 'WordPress core details unavailable';
                    const protection = coreData.is_multisite !== undefined ? (coreData.is_multisite ? 'running as a multisite' : 'single site') : 'single site scope implied';
                    return `${stack} on ${protection}, with ${healthLine}.`;
                };

                const summarizeUpdates = () => {
                    const activePlugins = pluginsData.filter(p => (p.status || '').toLowerCase() === 'active');
                    const needsUpdate = pluginsData.filter(p => p.needs_update || p.update_version);
                    const themeUpdates = themesData.filter(t => t.needs_update || t.update_version);
                    const pluginLine = activePlugins.length
                        ? `${activePlugins.length} active plugin${activePlugins.length === 1 ? '' : 's'} including ${activePlugins.slice(0, 5).map(p => `${p.name || 'Unknown'}${p.version ? ` (${p.version})` : ''}`).join(', ')}`
                        : 'no active plugins reported';
                    const updateLine = needsUpdate.length || themeUpdates.length
                        ? `Updates available for ${needsUpdate.length} plugin${needsUpdate.length === 1 ? '' : 's'} and ${themeUpdates.length} theme${themeUpdates.length === 1 ? '' : 's'}.`
                        : 'No pending plugin or theme updates detected.';
                    const themeLine = themesData.length
                        ? `${themesData.length} installed theme${themesData.length === 1 ? '' : 's'}${themesData.find(t => t.status === 'active') ? ` (active: ${themesData.find(t => t.status === 'active').name || 'unnamed'})` : ''}`
                        : 'No themes listed in stream data.';
                    return `${pluginLine}. ${themeLine}. ${updateLine}`;
                };

                const summarizeContentAudit = () => {
                    const postCount = stream.posts_total ?? postsData.length;
                    const pageCount = stream.pages_total ?? pagesData.length;
                    const commentCount = stream.comments_total ?? 0;
                    const insights = [];
                    insights.push(`Inventory shows ${pageCount || 0} pages and ${postCount || 0} posts${commentCount ? ` with ${commentCount} comments` : ''}.`);
                    if (postCount < 5) {
                        insights.push('Blog depth is minimal; add cornerstone articles and recent updates to build authority.');
                    } else {
                        insights.push('Posts are present—extend them with refreshed data, internal links, and updated CTAs.');
                    }
                    if (pageCount > 0) {
                        insights.push('Review top pages for conversion offers, schema coverage, and multimedia to raise engagement.');
                    }
                    const tagSignals = [];
                    postsData.slice(0, 10).forEach(post => {
                        if (post.tags && post.tags.length) tagSignals.push(...post.tags.slice(0, 3));
                    });
                    if (tagSignals.length) {
                        insights.push(`Surface more content around recurring tags such as ${[...new Set(tagSignals)].slice(0, 5).join(', ')}.`);
                    }
                    return `<p>${insights[0] || 'Content totals are not available yet.'}</p><p>${insights[1] || ''}</p><p>${insights[2] || ''}</p>`;
                };

                const summarizeVulnerabilities = () => {
                    const flaggedPlugins = pluginsData.filter(p => p.needs_update || (p.status && p.status.toLowerCase() === 'inactive'));
                    const firewall = (stream.security && stream.security.firewall) || (coreData.security && coreData.security.firewall);
                    const shields = [];
                    if (firewall) shields.push(`Firewall: ${firewall}`);
                    if (stream.health_score !== undefined) shields.push(`Health score ${stream.health_score}`);
                    const updateNote = flaggedPlugins.length
                        ? `${flaggedPlugins.length} plugin${flaggedPlugins.length === 1 ? '' : 's'} require attention (updates or activation review).`
                        : 'No plugin-level vulnerabilities flagged in stream data.';
                    return `${updateNote} ${shields.join(' | ') || 'Security tooling not reported.'}`;
                };

                const summarizePerformance = () => {
                    const metrics = [];
                    if (contentMetrics.total_comments !== undefined || stream.comments_total !== undefined) {
                        metrics.push(`Comments & activity: ${(stream.comments_total ?? contentMetrics.total_comments) || 0} recorded.`);
                    }
                    if (contentMetrics.visits || contentMetrics.sessions) {
                        metrics.push(`Site visits: ${contentMetrics.visits || contentMetrics.sessions} sessions; bounce ${contentMetrics.bounce_rate ? `${contentMetrics.bounce_rate}%` : 'N/A'}.`);
                    }
                    if (contentMetrics.regions && Array.isArray(contentMetrics.regions) && contentMetrics.regions.length) {
                        const topRegions = contentMetrics.regions.slice(0, 3).map(r => r.region || r.name || r.country).filter(Boolean);
                        if (topRegions.length) metrics.push(`Core regions: ${topRegions.join(', ')}.`);
                    }
                    if (contentMetrics.top_pages && Array.isArray(contentMetrics.top_pages) && contentMetrics.top_pages.length) {
                        const topPages = contentMetrics.top_pages.slice(0, 3).map(p => p.title || p.url || p.path).filter(Boolean);
                        if (topPages.length) metrics.push(`Top visited pages/posts: ${topPages.join('; ')}.`);
                    }
                    return metrics.length ? metrics.map(line => `<p>${line}</p>`).join('') : '<p>Analytics signals are not yet available from this stream.</p>';
                };

                const summarizeLuna = () => {
                    const postCount = stream.posts_total ?? postsData.length;
                    const pageCount = stream.pages_total ?? pagesData.length;
                    const pluginHealth = pluginsData.filter(p => p.needs_update).length;
                    return `Luna sees ${pageCount || 0} pages, ${postCount || 0} posts, and ${pluginsData.length || 0} plugins. ${pluginHealth ? `${pluginHealth} plugin${pluginHealth === 1 ? '' : 's'} need updates—` : 'Plugins look up-to-date—'}let me orchestrate fixes or generate briefs based on this audit.`;
                };

                html += '<div class="wp-audit-report" style="display:flex; flex-direction:column; gap:28px;">';
                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">State of WordPress Core</h2>';
                html += '<p style="margin:0; line-height:1.6;">' + summarizeCore() + '</p>';
                html += '</section>';

                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Updates and Optimizations</h2>';
                html += '<p style="margin:0; line-height:1.6;">' + summarizeUpdates() + '</p>';
                html += '</section>';

                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Content Audit</h2>';
                html += summarizeContentAudit();
                html += '</section>';

                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Known Vulnerabilities</h2>';
                html += '<p style="margin:0; line-height:1.6;">' + summarizeVulnerabilities() + '</p>';
                html += '</section>';

                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Performance &amp; Analytics</h2>';
                html += summarizePerformance();
                html += '</section>';

                html += '<section style="background:#8D8C00; color:#000; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Luna Summary</h2>';
                html += '<p style="margin:0; line-height:1.6;">' + summarizeLuna() + '</p>';
                html += '</section>';
                html += '</div>';

            }

            // For competitor analysis, fetch and display competitor report data
            // Check if this is a competitor analysis stream (either by ID or by having report_data)
            const isCompetitorAnalysis = (stream.id && (stream.id.includes('competitor') || stream.id.includes('competitive'))) || 
                                         (stream.categories && stream.categories.includes('competitive')) ||
                                         streamType === 'competitive-analysis';
            
            if (isCompetitorAnalysis && stream.report_data) {
                const report = stream.report_data;
                
                // Lighthouse Scores
                if (report.lighthouse) {
                    html += '<h2>Lighthouse Scores</h2>';
                    html += '<div>';
                    html += '<div><strong>Performance:</strong> ' + (report.lighthouse.performance || 'N/A') + '%</div>';
                    html += '<div><strong>Accessibility:</strong> ' + (report.lighthouse.accessibility || 'N/A') + '%</div>';
                    html += '<div><strong>SEO:</strong> ' + (report.lighthouse.seo || 'N/A') + '%</div>';
                    html += '<div><strong>Best Practices:</strong> ' + (report.lighthouse.best_practices || 'N/A') + '%</div>';
                    html += '</div>';
                }
                
                // Site Information
                html += '<h2>Site Information</h2>';
                html += '<div>';
                html += '<div><strong>Public Pages:</strong> ' + (report.public_pages || 'N/A') + '</div>';
                if (report.blog) {
                    html += '<div><strong>Blog Status:</strong> ' + (report.blog.status || 'Unknown') + ' (' + (report.blog.post_count || 0) + ' posts detected)</div>';
                    html += '<div><strong>Blog URL:</strong> <a href="' + (report.blog.source_link || '#') + '" target="_blank">' + (report.blog.source_link || 'N/A') + '</a></div>';
                }
                if (report.meta_info) {
                    if (report.meta_info.title) {
                        html += '<div><strong>Title:</strong> ' + report.meta_info.title + '</div>';
                    }
                    if (report.meta_info.description) {
                        html += '<div><strong>Description:</strong> ' + report.meta_info.description + '</div>';
                    }
                    if (report.meta_info.keywords) {
                        html += '<div><strong>Keywords:</strong> ' + report.meta_info.keywords + '</div>';
                    }
                }
                html += '</div>';
                
                // Top Keywords
                if (report.top_keywords && Array.isArray(report.top_keywords) && report.top_keywords.length > 0) {
                    html += '<h2>Top 10 Keywords</h2>';
                    html += '<div>';
                    report.top_keywords.slice(0, 10).forEach(item => {
                        const keyword = item.keyword || item;
                        const frequency = item.frequency || '';
                        html += '<div>';
                        html += '<strong>' + keyword + '</strong>';
                        if (frequency) {
                            html += ' - Frequency: ' + frequency;
                        }
                        html += '</div>';
                    });
                    html += '</div>';
                }
                
                // Top Keyphrases
                if (report.top_keyphrases && Array.isArray(report.top_keyphrases) && report.top_keyphrases.length > 0) {
                    html += '<h2>Top 10 Keyphrases</h2>';
                    html += '<div>';
                    report.top_keyphrases.slice(0, 10).forEach(item => {
                        const phrase = item.phrase || item;
                        const frequency = item.frequency || '';
                        html += '<div>';
                        html += '<strong>' + phrase + '</strong>';
                        if (frequency) {
                            html += ' - Frequency: ' + frequency;
                        }
                        html += '</div>';
                    });
                    html += '</div>';
                }
            }
            
            // Generic stream data (only show if not WordPress stream, as WordPress data is shown above)
            if (!isWordPressStream) {
                html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Stream Details</h2>';
                html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px; margin-bottom: 30px;">';
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">';
            html += '<div><strong>Stream ID:</strong> ' + (stream.id || 'N/A') + '</div>';
            html += '<div><strong>Health Score:</strong> ' + (stream.health_score || 'N/A') + '</div>';
            html += '<div><strong>Status:</strong> ' + (stream.status || 'N/A') + '</div>';
            if (stream.last_updated) {
                html += '<div><strong>Last Updated:</strong> ' + stream.last_updated + '</div>';
            }
            if (stream.error_count !== undefined) {
                html += '<div><strong>Error Count:</strong> ' + stream.error_count + '</div>';
            }
            if (stream.warning_count !== undefined) {
                html += '<div><strong>Warning Count:</strong> ' + stream.warning_count + '</div>';
            }
            html += '</div>';
                html += '</div>';
            }
            
            // Display all report_data if available (for non-WordPress streams)
            if (!isWordPressStream && stream.report_data && typeof stream.report_data === 'object') {
                html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Report Data</h2>';
                html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px; margin-bottom: 30px;">';
                html += '<pre style="overflow-x: auto; font-size: 0.85em; color: #fff4e9;">' + JSON.stringify(stream.report_data, null, 2) + '</pre>';
                html += '</div>';
            }

            html += '<div id="orchestratePanel" style="margin: 30px 0 10px; padding: 18px; border: 1px solid #5A575335; border-radius: 10px; background: #111; display: flex; flex-direction: column; gap: 12px;">';
            html += '<div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">';
            html += '<span style="font-weight:700; color:#fff4e9;">Orchestrate</span>';
            html += '<button id="orchestrateTrigger" style="background:#8D8C00; color:#000; border:none; padding:10px 14px; border-radius:8px; font-weight:700; cursor:pointer;">Open Options</button>';
            html += '</div>';
            html += '<div id="orchestrateModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:1200; align-items:center; justify-content:center;">';
            html += '<div style="background:#0b0b0b; border:1px solid #5A575335; border-radius:10px; padding:20px; width:320px; box-shadow:0 10px 30px rgba(0,0,0,0.35);">';
            html += '<div style="font-weight:700; color:#fff4e9; margin-bottom:14px; display:flex; justify-content:space-between; align-items:center;">';
            html += '<span>Choose an action</span>';
            html += '<button id="orchestrateClose" aria-label="Close" style="background:none; border:none; color:#fff4e9; font-size:18px; cursor:pointer;">×</button>';
            html += '</div>';
            html += '<div style="display:flex; flex-direction:column; gap:10px;">';
            html += '<button data-orchestrate="ticket" style="text-align:left; padding:10px; border-radius:8px; border:1px solid #5A575335; background:#1f1d1a; color:#fff4e9; cursor:pointer;">New Ticket</button>';
            html += '<button data-orchestrate="ai-summary" style="text-align:left; padding:10px; border-radius:8px; border:1px solid #5A575335; background:#1f1d1a; color:#fff4e9; cursor:pointer;">AI Summary</button>';
            html += '<button data-orchestrate="send-to" style="text-align:left; padding:10px; border-radius:8px; border:1px solid #5A575335; background:#1f1d1a; color:#fff4e9; cursor:pointer;">Send to</button>';
            html += '</div>';
            html += '</div>';
            html += '</div>';

            html += '</div>';
            
            // Insert content into page content container (preserving overlay)
            const pageContent = document.getElementById('vlPageContent');
            if (pageContent) {
                // Ensure page content container allows scrolling
                pageContent.style.cssText = 'display: block !important; position: fixed !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100vh !important; overflow-y: auto !important; overflow-x: hidden !important; z-index: 1000 !important;';
                pageContent.innerHTML = html;
                try {
                    const licenseParam = (new URLSearchParams(window.location.search).get('license') || 'VL-AWJJ-8J6S-GD6R').split('/')[0];
                    const orchestrateModal = document.getElementById('orchestrateModal');
                    const orchestrateTrigger = document.getElementById('orchestrateTrigger');
                    const orchestrateClose = document.getElementById('orchestrateClose');
                    const orchestrateButtons = orchestrateModal ? orchestrateModal.querySelectorAll('button[data-orchestrate]') : [];

                    const closeModal = () => { if (orchestrateModal) orchestrateModal.style.display = 'none'; };
                    const openModal = () => { if (orchestrateModal) orchestrateModal.style.display = 'flex'; };

                    orchestrateTrigger && orchestrateTrigger.addEventListener('click', openModal);
                    orchestrateClose && orchestrateClose.addEventListener('click', closeModal);
                    if (orchestrateModal) {
                        orchestrateModal.addEventListener('click', (e) => { if (e.target === orchestrateModal) closeModal(); });
                    }

                    orchestrateButtons.forEach(btn => {
                        btn.addEventListener('click', () => {
                            const action = btn.getAttribute('data-orchestrate');
                            if (action === 'ticket') {
                                window.location.href = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseParam)}/support/tickets/`;
                            } else if (action === 'ai-summary') {
                                try {
                                    localStorage.setItem('lunaComposerFollowupPrompt', JSON.stringify({ prompt: 'Run WordPress Site Audit with Key Details About Technology and Content', license: licenseParam, created: Date.now(), type: 'ai-summary' }));
                                } catch (err) {
                                    console.warn('Could not store AI Summary prompt', err);
                                }
                                window.open(`/?license=${encodeURIComponent(licenseParam)}/luna-compose`, '_blank');
                            } else if (action === 'send-to') {
                                window.location.href = '#';
                            }
                            closeModal();
                        });
                    });
                } catch (hookError) {
                    console.warn('Failed to initialize orchestrate actions', hookError);
                }
            } else {
                console.error('Page content container not found');
            }
        }

        // NOTE: renderSharedLunaComposer is defined earlier in the file (before authentication check)
        // Duplicate definition removed
        
        // Render Luna Composer page
        async function renderLunaComposer() {
            try {
                console.log('[Luna Composer] Starting render...');
                
                // Remove yourSuperclusterWidget from Luna Composer page
                const superclusterWidget = document.getElementById('yourSuperclusterWidget');
                if (superclusterWidget) {
                    console.log('[Luna Composer] Removing yourSuperclusterWidget...');
                    superclusterWidget.remove();
                }
                
                // Replace right sidebar with History sidebar for Luna Composer
                const rightSidebar = document.querySelector('.vl-right-sidebar');
                if (rightSidebar) {
                    console.log('[Luna Composer] Replacing right sidebar with History...');
                    // Replace the Stream Activity widget with History widget
                    const activityWidget = rightSidebar.querySelector('#recentActivityWidget');
                    if (activityWidget) {
                        activityWidget.innerHTML = `
                            <div class="vl-widget-header">
                                <h3>History</h3>
                                <button class="vl-widget-toggle" data-widget="recentActivityWidget" aria-label="Hide widget">
                                    <img src="https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg" alt="Hide" class="vl-toggle-icon" />
                                </button>
                            </div>
                            <div class="vl-widget-body">
                                <ul id="lunaComposerHistoryList" class="vl-activity-list">
                                    <li class="vl-activity-empty">No saved documents.</li>
                                </ul>
                            </div>
                        `;
                    }
                }
                
                // Remove controls completely
                const controls = document.querySelector('.vl-controls');
                if (controls) {
                    console.log('[Luna Composer] Removing controls...');
                    controls.remove();
                }
                
                // Remove three.js labels if they exist (only hides on internal pages)
                console.log('[Luna Composer] Hiding labels container...');
                hideSuperclusterLabels();
                
                // Hide only the Three.js canvas, keep container visible
                hideThreeJSCanvas();
                
                const pageContent = document.getElementById('vlPageContent');
                
                // Show page content container - set z-index higher than overlay to display on top
                if (!pageContent) {
                    // Create page content container if it doesn't exist
                    const newPageContent = document.createElement('div');
                    newPageContent.id = 'vlPageContent';
                    newPageContent.className = 'vl-page-content';
                    newPageContent.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000000; z-index: 1000; overflow-y: auto; display: block !important; pointer-events: auto;';
                    document.body.appendChild(newPageContent);
                } else {
                    // Ensure page content is visible and above overlay
                    pageContent.style.display = 'block';
                    pageContent.style.position = 'fixed';
                    pageContent.style.top = '0';
                    pageContent.style.left = '0';
                    pageContent.style.width = '100%';
                    pageContent.style.height = '100%';
                    pageContent.style.zIndex = '1000';
                    pageContent.style.overflowY = 'auto';
                    pageContent.style.pointerEvents = 'auto';
                }
                
                // Extract license key from URL
                const currentParams = new URLSearchParams(window.location.search);
                const currentUrlLicenseParam = currentParams.get('license') || '';
                let extractedLicenseKey = '';
                if (currentUrlLicenseParam) {
                    const licenseMatch = currentUrlLicenseParam.match(/^([^/]+)/);
                    if (licenseMatch) {
                        extractedLicenseKey = licenseMatch[1];
                    } else {
                        extractedLicenseKey = currentUrlLicenseParam;
                    }
                }
                
                // Fetch Essentials from client's WordPress site
                let cannedResponses = [];
                let clientSiteUrl = null;
                
                // First, get client's WordPress site URL from Hub profile
                try {
                    const profileResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/profile?license=${encodeURIComponent(extractedLicenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (profileResp.ok) {
                        const profileData = await profileResp.json();
                        // Get client site URL from profile - check multiple possible locations
                        if (profileData.data?.site_info?.site) {
                            clientSiteUrl = profileData.data.site_info.site;
                        } else if (profileData.site_info?.site) {
                            clientSiteUrl = profileData.site_info.site;
                        } else if (profileData.site?.home_url) {
                            clientSiteUrl = profileData.site.home_url;
                        } else if (profileData.data?.site?.home_url) {
                            clientSiteUrl = profileData.data.site.home_url;
                        }
                    }
                } catch (e) {
                    console.warn('[Luna Composer] Could not fetch profile to get client site URL:', e);
                }
                
                // If we have client site URL, fetch Essentials from there
                if (clientSiteUrl) {
                    try {
                        const essentialsResp = await fetch(`${clientSiteUrl}/wp-json/luna_widget/v1/canned-responses?license=${encodeURIComponent(extractedLicenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                        if (essentialsResp.ok) {
                            const essentialsData = await essentialsResp.json();
                            cannedResponses = essentialsData.items || [];
                            console.log('[Luna Composer] Loaded', cannedResponses.length, 'essential commands from client WordPress site');
                        } else {
                            console.warn('[Luna Composer] Failed to fetch essentials from client site:', essentialsResp.status, essentialsResp.statusText);
                    }
                } catch (e) {
                        console.warn('[Luna Composer] Could not fetch essentials from client WordPress site:', e);
                    }
                } else {
                    console.warn('[Luna Composer] Client site URL not found, cannot fetch Essentials');
                }
                
                // Build Luna Composer UI
                // Add padding-top to account for overlay header (80px) and some spacing
                // Make the container clickable (pointer-events: auto) so it can receive events
                let html = '<style>@media (min-width: 991px) { .luna-composer-page { max-width: 55% !important; } }</style>';
                html += '<style>.luna-composer-loading-text { background: linear-gradient(to right, #fff4e9 20%, #9A9793 30%, #9A9793 70%, #fff4e9 80%); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; background-size: 200% auto; animation: textShine 7s ease-in-out infinite alternate; } @keyframes textShine { to { background-position: -200%; } } .luna-composer-loading-icon { display: inline-block; width: 20px; height: 20px; margin-right: 12px; vertical-align: middle; animation: lunaComposerSpin 1s linear infinite; color: #fff4e9; opacity: 0.8; } @keyframes lunaComposerSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>';
                html += '<div class="luna-composer-page" style="min-height: 100vh; background: transparent; color: #fff4e9; padding: 40px 0; max-width: 1200px; margin: 0 auto; position: relative; z-index: 2; pointer-events: auto;">';
                
                // Extract all unique categories from cannedResponses
                const allCategories = new Set();
                cannedResponses.forEach(item => {
                    if (item.categories && Array.isArray(item.categories)) {
                        item.categories.forEach(cat => {
                            if (cat && cat.name) {
                                allCategories.add(cat.name);
                            }
                        });
                    }
                });
                const categoriesArray = Array.from(allCategories).sort();
                
                // Store original responses for filtering
                window.lunaComposerAllResponses = cannedResponses;
                window.lunaComposerSelectedCategory = null;
                
                // Luna Composer Editor Section (Canned Prompts / Intelligent Suggestions)
                html += '<div class="luna-composer__editor" style="margin-bottom: 0; min-width: 100%;">';
                html += '<h1 class="TypeGradient" style="margin-bottom: 20px; font-size: 1.5rem;margin-top: 0 !important;">Luna Compose</h1>';
                html += '<div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">';
                html += '<div id="luna-composer-mode-toggle" data-mode="canned" style="display: flex; align-items: center; background: #2E2C2A50; border: 1px solid #5A575335; border-radius: 6px; padding: 2px; transition: all 0.2s ease;">';
                html += '<button id="luna-composer-mode-canned" onclick="window.lunaComposerToggleMode(); event.stopPropagation();" style="padding: 6px 16px; border: none; background: #2E2C2A; color: #fff4e9; border-radius: 4px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; white-space: nowrap;"></button>';
                html += '<button id="luna-composer-mode-intelligent" onclick="window.lunaComposerToggleMode(); event.stopPropagation();" style="padding: 6px 16px; border: none; background: transparent; color: #9A9793; border-radius: 4px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; white-space: nowrap;"></button>';
                html += '</div>';
                html += '<h2 id="luna-composer-section-title" style="color: #fff4e9; margin: 0; font-size: 1.2rem;">Essential Commands</h2>';
                html += '</div>';
                
                // Category Selector
                if (categoriesArray.length > 0) {
                    html += '<div id="luna-composer-category-selector" style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">';
                    html += '<span style="color: #9A9793; font-size: 0.875rem;">Filter by category:</span>';
                    html += '<div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">';
                    categoriesArray.forEach(categoryName => {
                        const escapedCategory = categoryName.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                        html += '<button class="luna-composer-category-btn" data-category="' + escapedCategory + '" onclick="window.lunaComposerFilterByCategory(\'' + escapedCategory + '\')" style="background: #2E2C2A50; border: 1px solid #5A575335; color: #9A9793; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; white-space: nowrap;">' + categoryName + '</button>';
                    });
                    html += '<button id="luna-composer-category-reset" onclick="window.lunaComposerResetCategoryFilter()" style="display: none; background: #2E2C2A50; border: 1px solid #5A575335; color: #9A9793; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; align-items: center; gap: 6px;" title="Show all categories"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/arrows-repeat-solid-full.svg" alt="reset Luna Composer commands" style="width: 14px; height: 14px; filter: brightness(0) invert(0.6);" /></button>';
                    html += '</div>';
                    html += '</div>';
                }
                
                html += '<div id="luna-composer-canned-section" style="display: block;">';
                
                if (cannedResponses.length > 0) {
                    html += '<div class="canned-prompts-wrapper" style="position: relative; width: 100%;">';
                    html += '<button class="canned-prompts-scroll-btn canned-prompts-scroll-left" style="display: none; position: absolute; left: 0; top: 44px; width: 20px; height: 20px; background: url(https://visiblelight.ai/wp-content/uploads/2025/08/left-right-arrow.svg) no-repeat center; background-size: contain; border: none; cursor: pointer; z-index: 10000; transform: rotate(180deg);" onclick="window.scrollCannedPrompts(this, -1)" aria-label="Scroll left"></button>';
                    html += '<div class="canned-prompts-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;positon:relative;">';
                    cannedResponses.forEach(item => {
                        const escapedPrompt = (item.prompt || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                        const escapedContent = (item.content || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, '\\n');
                        const escapedTitle = (item.title || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const escapedExcerpt = (item.excerpt || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        
                        // Get categories for this item
                        const itemCategories = (item.categories || []).map(cat => cat.name).filter(Boolean);
                        const categoryDataAttr = itemCategories.map(cat => cat.replace(/'/g, "\\'").replace(/"/g, '&quot;')).join(',');
                        const categoryDisplay = itemCategories.length > 0 ? itemCategories.join(', ') : '';
                        
                        html += '<div class="canned-prompt-item" data-prompt-id="' + item.id + '" data-categories="' + categoryDataAttr + '" style="background: #000000; border: 1px solid #1f1d1a; border-radius: 8px; padding: 16px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.borderColor=\'#5A5753\';" onmouseout="this.style.borderColor=\'#2E2C2A\';" onclick="window.lunaComposerUsePrompt(\'' + item.id + '\', \'' + escapedPrompt + '\', \'\')">';
                        if (categoryDisplay) {
                            html += '<div style="color: #9A9793; margin: 0 0 8px 0; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 500;">' + categoryDisplay + '</div>';
                        }
                        html += '<h3 style="color: #fff4e9; margin: 0 0 8px 0; font-size: 1rem; font-weight: 400;">' + escapedTitle + '</h3>';
                        html += '<p style="color: #9A9793; margin: 0; font-size: 0.875rem; line-height: 1.4;">' + escapedExcerpt + '</p>';
                        html += '</div>';
                    });
                    html += '</div>';
                    html += '<button class="canned-prompts-scroll-btn canned-prompts-scroll-right" style="position: absolute; right: 0; top: 44px; width: 20px; height: 20px; background: url(https://visiblelight.ai/wp-content/uploads/2025/08/left-right-arrow.svg) no-repeat center; background-size: contain; border: none; cursor: pointer; z-index: 10000;" onclick="window.scrollCannedPrompts(this, 1)" aria-label="Scroll right"></button>';
                    html += '</div>';
                } else {
                    html += '<p style="color: #9A9793; margin: 16px 0;">No essential commands found. Create a command in WP Admin > Luna Widget > Canned Responses.</p>';
                }
                html += '</div>'; // Close canned-prompts-wrapper
                html += '</div>'; // Close luna-composer-canned-section
                
                // Toolbar (sticky) with blur container
                html += '<div class="luna-composer-toolbar-container" style="position: sticky; top: 2rem; margin-bottom: 20px; z-index: 10; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">';
                html += '<div class="luna-composer-toolbar" style="position: sticky; display: flex; top:0; justify-content: space-between; align-items: center; padding: 12px 12px 12px 12px">';
                html += '<div style="display: flex; align-items: center; gap: 16px;">';
                html += '<span style="color: #fff4e9; font-weight: 400; font-size: 1rem;">Options</span>';
                html += '<button id="luna-composer-find-replace" style="background: #1f1d1a; border: 1px solid #5A575335; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerShowFindReplace()" title="Find and Replace"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/shuffle-regular-full.svg" alt="Find and Replace" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div class="luna-composer-share" style="position: relative; display: inline-block;">';
                html += '<button id="luna-composer-share-btn" style="background: #1f1d1a; border: 1px solid #5A575335; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerShowShareModal()" title="Share"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/share-regular-full.svg" alt="Share" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '</div>';
                html += '<div class="luna-composer-export" style="position: relative; display: inline-block;">';
                html += '<button id="luna-composer-export-btn" style="background: #1f1d1a; border: 1px solid #5A575335; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.background=\'#3A3836\';" onmouseout="this.style.background=\'#2E2C2A\';" onclick="window.lunaComposerToggleExportMenu()" title="Export to"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/arrow-down-to-line-solid-full.svg" alt="Export to" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div id="luna-composer-export-menu" style="display: none; position: fixed; background: rgba(0,0,0,0.85) !important; backdrop-filter: blur(12px) !important; -webkit-backdrop-filter: blur(12px) !important; border: 1px solid #2E2C2A; border-radius: 6px; padding: 8px 0; min-width: 180px; z-index: 10000 !important; box-shadow: 0 4px 12px rgba(0,0,0,0.4);">';
                html += '<button onclick="window.lunaComposerExportTo(\'google-docs\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Google Docs</button>';
                html += '<button onclick="window.lunaComposerExportTo(\'pdf\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">PDF</button>';
                html += '<button onclick="window.lunaComposerExportTo(\'mp3\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Audio file (mp3)</button>';
                html += '</div>';
                html += '</div>';
                html += '<div id="luna-composer-reimagine-wrapper" style="position: relative; display: none;">';
                html += '<button id="luna-composer-reimagine-btn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #9A9793; padding: 8px 16px; border-radius: 6px; cursor: not-allowed; font-size: 0.875rem; transition: all 0.2s ease; display: flex; pointer-events: none; align-items: center; justify-content: center; gap: 8px;" onclick="window.lunaComposerToggleReimagineMenu(event)" title="Reimagine with Luna" disabled>';
                html += '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2L10 6L14 6L11 9L12 13L8 10L4 13L5 9L2 6L6 6L8 2Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                html += '<span>Reimagine with Luna</span>';
                html += '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-left: 4px;"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                html += '</button>';
                html += '<div id="luna-composer-reimagine-menu" style="display: none; position: absolute; right: 0; top: calc(100% + 8px); background: rgba(0,0,0,0.92); border: 1px solid #2E2C2A; border-radius: 6px; min-width: 220px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.4); padding: 8px 0;">';
                html += '<button type="button" onclick="window.lunaComposerSelectReimagineMode(\'highlight\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Highlight</button>';
                html += '<button type="button" onclick="window.lunaComposerSelectReimagineMode(\'branding\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Branding</button>';
                html += '<button type="button" onclick="window.lunaComposerSelectReimagineMode(\'linguistics\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Linguistics</button>';
                html += '</div>';
                html += '</div>';
                html += '<button id="luna-composer-dictate-btn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerToggleDictate()" title="Dictate"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/microphone-regular-full-1.svg" alt="Dictate" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<button id="luna-composer-readback-btn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease;" onclick="window.lunaComposerToggleReadback()">Read Aloud</button>';
                html += '<button id="luna-composer-delete-btn" style="background: #d63638; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerShowDeleteModal()" title="Move to trash"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/trash-can-regular-full.svg" alt="Move to trash" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div id="luna-composer-auto-save-status" style="display: flex; align-items: center; gap: 8px; padding-right: 0;">';
                html += '<img src="https://visiblelight.ai/wp-content/uploads/2025/11/cloud-check-regular-full.svg" alt="Auto-save" style="width: 18px; height: 18px;" />';
                html += '<span id="luna-composer-save-message" style="color: #fff4e9; font-size: 0.6rem; opacity: 0; transition: opacity 0.3s ease;"></span>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // Text Editor (sticky) with blur container
                html += '<div class="luna-composer-editor-container" style="position: relative;">';
                html += '<div class="luna-composer-editor-toolbar-container" style="position: sticky; top: calc(0rem + 58px); z-index: 9; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background: rgba(0,0,0, 0.7); border-right: 1px solid #1f1d1a; border-left: 1px solid #1f1d1a; border-top: 1px solid #1f1d1a; border-bottom: none; border-radius: 8px 8px 0 0;">';
                html += '<div id="luna-composer-editor-toolbar" style="display: flex; gap: 8px; padding: 12px; flex-wrap: wrap; align-items: center;">';
                html += '<button onclick="document.execCommand(\'bold\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Bold">B</button>';
                html += '<button onclick="document.execCommand(\'italic\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-style: italic; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Italic">I</button>';
                html += '<button onclick="document.execCommand(\'underline\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; text-decoration: underline; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Underline">U</button>';
                html += '<button onclick="document.execCommand(\'strikeThrough\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; text-decoration: line-through; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Strikethrough">S</button>';
                html += '<div style="width: 1px; background: #1f1d1a; margin: 0 4px; height:20px;"></div>';
                html += '<button onclick="document.execCommand(\'insertUnorderedList\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(8px);" title="Bullet List"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/list-regular-full.svg" alt="Bullet List" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<button onclick="document.execCommand(\'insertOrderedList\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(8px);" title="Numbered List"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/list-ol-solid-full-1.svg" alt="Numbered List" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<button onclick="document.execCommand(\'indent\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Indent">→</button>';
                html += '<button onclick="document.execCommand(\'outdent\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Outdent">←</button>';
                html += '<div style="width: 1px; background: #1f1d1a; margin: 0 4px; height:20px;"></div>';
                html += '<button onclick="document.execCommand(\'undo\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Undo">↶</button>';
                html += '<button onclick="document.execCommand(\'redo\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Redo">↷</button>';
                html += '<div style="flex: 1;"></div>'; // Spacer to push buttons to the right
                html += '<div style="width: 1px; background: #1f1d1a; margin: 0 4px; height:20px;"></div>'; // Separator
                html += '<button id="luna-composer-editor-heart-btn" onclick="window.lunaComposerToggleHeart()" style="display: none; background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; align-items: center; justify-content: center; backdrop-filter: blur(8px);" title="Like this document"><img id="luna-composer-heart-icon" src="https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg" alt="Like" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '</div>';
                html += '</div>';
                // Check if there's a document ID in the URL
                const urlParams = new URLSearchParams(window.location.search);
                const urlLicense = urlParams.get('license') || '';
                let documentId = null;
                if (urlLicense.includes('/luna/compose/')) {
                    const match = urlLicense.match(/\/luna\/compose\/([^\/]+)/);
                    if (match && match[1]) {
                        documentId = match[1];
                    }
                }
                
                html += '<div id="luna-composer-editor-wrapper" style="position: relative;">';
                html += '<div id="luna-composer-editor" contenteditable="true" style="position: sticky; top: calc(2rem + 60px + 48px); min-height: 400px; padding: 0 12px; background: #000; border-right: 1px solid #1f1d1a;border-left: 1px solid #5A575350;border-bottom: 1px solid #5A575350; border-radius: 0 0 8px 8px; color: #fff4e9; font-size: 1rem; line-height: 1.6; outline: none; word-wrap: break-word; z-index: 8;" data-license-key="' + extractedLicenseKey + '" data-document-id="' + (documentId || '') + '"></div>';
                html += '</div>';
                html += '</div>';
                
                html += '</div>';
                
                // Delete Confirmation Modal
                html += '<div id="luna-composer-delete-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10001; align-items: center; justify-content: center;">';
                html += '<div style="background: #232120; border: 1px solid #2E2C2A; border-radius: 8px; padding: 24px; max-width: 500px; width: 90%;">';
                html += '<h3 style="color: #fff4e9; margin: 0 0 16px 0; font-size: 1.25rem; font-weight: 600;">Are you sure you want to permanently delete this document?</h3>';
                html += '<p style="color: #9A9793; margin: 0 0 20px 0; font-size: 0.875rem; line-height: 1.6;">Deleting this document can not be undone. <a href="#" id="luna-composer-delete-download-link" style="color: #1f1d1a; text-decoration: underline; cursor: pointer;" onclick="window.lunaComposerDownloadBackup(); return false;">Download a backup now</a> before continuing.</p>';
                html += '<div style="display: flex; gap: 12px; justify-content: flex-end;">';
                html += '<button id="luna-composer-delete-cancel" onclick="window.lunaComposerCloseDeleteModal()" style="background: #2E2C2A; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">Cancel</button>';
                html += '<button id="luna-composer-delete-confirm" onclick="window.lunaComposerDeleteDocument()" disabled style="background: #d63638; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: not-allowed; font-size: 0.875rem; font-weight: 600; opacity: 0.5;">Delete Permanently</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // Share Modal
                html += '<div id="luna-composer-share-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10001; align-items: center; justify-content: center;">';
                html += '<div style="background: #23212010; backdrop-filter: blur(8px); border: 1px solid #2E2C2A; border-radius: 8px; padding: 24px; max-width: 600px; width: 90%;">';
                html += '<h3 style="color: #fff4e9; margin: 0 0 20px 0; font-size: 1.25rem; font-weight: 600;">Share Document</h3>';
                
                // Main action selector (Copy Link / New Post)
                html += '<div style="margin-bottom: 20px;">';
                html += '<div style="display: flex; gap: 8px; margin-bottom: 20px;">';
                html += '<button id="luna-composer-share-action-copy" class="luna-composer-share-action-btn active" data-action="copy" onclick="window.lunaComposerSelectShareAction(\'copy\')" style="flex: 1; padding: 12px 20px; background: #2E2C2A; border: 1px solid #5A5753; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; transition: all 0.2s ease;">Copy Link</button>';
                html += '<button id="luna-composer-share-action-post" class="luna-composer-share-action-btn" data-action="post" onclick="window.lunaComposerSelectShareAction(\'post\')" style="flex: 1; padding: 12px 20px; background: #2E2C2A50; border: 1px solid #5A575335; color: #9A9793; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; transition: all 0.2s ease;">New Post</button>';
                html += '</div>';
                
                // Copy Link section (default visible)
                html += '<div id="luna-composer-share-copy-section" style="display: block;">';
                html += '<div style="margin-bottom: 16px; padding: 12px; background: #00000050; border: 1px solid #2E2C2A; border-radius: 6px;">';
                html += '<span style="color: #9A9793; font-size: 0.875rem;">Anyone with a link can view and download</span>';
                html += '</div>';
                html += '<div style="margin-bottom: 20px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 8px; font-size: 0.875rem; font-weight: 600;">Share Link:</label>';
                html += '<div style="display: flex; gap: 8px;">';
                html += '<input type="text" id="luna-composer-share-link-input" readonly style="flex: 1; padding: 10px; background: #000; border: 1px solid #2E2C2A; border-radius: 4px; color: #fff4e9; font-size: 0.875rem; box-sizing: border-box;" />';
                html += '<button id="luna-composer-share-copy-btn" onclick="window.lunaComposerCopyShareLink()" style="background: #fff4e9; border: 1px solid #5A5753; color: #000; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; font-weight: 600; white-space: nowrap;">Copy Link</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // New Post section (hidden by default)
                html += '<div id="luna-composer-share-post-section" style="display: none;">';
                html += '<div style="margin-bottom: 20px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 12px; font-size: 0.875rem; font-weight: 600;">Publish to:</label>';
                html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
                html += '<button id="luna-composer-post-wp" onclick="window.lunaComposerCreatePost(\'wp\')" style="width: 100%; padding: 12px 20px; background: #000000; border: 1px solid #1f1d1a; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; text-align: left; transition: all 0.2s ease;" onmouseover="this.style.borderColor=\'#1f1d1a\';" onmouseout="this.style.borderColor=\'#1f1d1a\';"><strong>WordPress Post (Draft)</strong><br>Creates a copy of the doc as a WordPress Post draft.</button>';
                html += '<button id="luna-composer-post-medium" onclick="window.lunaComposerCreatePost(\'medium\')" style="width: 100%; padding: 12px 20px; background: #000000; border: 1px solid #1f1d1a; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; text-align: left; transition: all 0.2s ease;" onmouseover="this.style.borderColor=\'#1f1d1a\';" onmouseout="this.style.borderColor=\'#5A5753\';">Medium.com</button>';
                html += '<button id="luna-composer-post-linkedin" onclick="window.lunaComposerCreatePost(\'linkedin\')" style="width: 100%; padding: 12px 20px; background: #000000; border: 1px solid #1f1d1a; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; text-align: left; transition: all 0.2s ease;" onmouseover="this.style.borderColor=\'#1f1d1a\';" onmouseout="this.style.borderColor=\'#5A5753\';">LinkedIn</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                html += '<div style="display: flex; gap: 12px; justify-content: flex-end;">';
                html += '<button onclick="window.lunaComposerCloseShareModal()" style="background: #fff4e9; border: 1px solid #fff4e9; color: #000000; font-weight:700;padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">Close</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // Add CSS for active state
                html += '<style>';
                html += '.luna-composer-share-action-btn.active { background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%) !important;color: #000 !important;border: none !important; }';
                html += '.luna-composer-share-action-btn:not(.active) { background: #2E2C2A50 !important; color: #9A9793 !important; border-color: #5A575335 !important; }';
                html += '</style>';
                
                // Find and Replace Modal
                html += '<div id="luna-composer-find-replace-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; align-items: center; justify-content: center;">';
                html += '<div style="background: #000000; border: 1px solid #2E2C2A; border-radius: 8px; padding: 24px; max-width: 500px; width: 90%;">';
                html += '<h3 style="color: #fff4e9; margin: 0 0 20px 0; font-size: 1.25rem;">Find and Replace</h3>';
                html += '<div style="margin-bottom: 16px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 8px; font-size: 0.875rem;">Find:</label>';
                html += '<input type="text" id="luna-composer-find-text" style="width: 100%; padding: 10px; background: #000; border: 1px solid #2E2C2A; border-radius: 4px; color: #fff4e9; font-size: 0.875rem; box-sizing: border-box;" />';
                html += '</div>';
                html += '<div style="margin-bottom: 20px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 8px; font-size: 0.875rem;">Replace with:</label>';
                html += '<input type="text" id="luna-composer-replace-text" style="width: 100%; padding: 10px; background: #000; border: 1px solid #2E2C2A; border-radius: 4px; color: #fff4e9; font-size: 0.875rem; box-sizing: border-box;" />';
                html += '</div>';
                html += '<div style="display: flex; gap: 12px; justify-content: flex-end;">';
                html += '<button onclick="window.lunaComposerCloseFindReplace()" style="background: #2E2C2A; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">Cancel</button>';
                html += '<button onclick="window.lunaComposerExecuteFindReplace()" style="background: #fff4e9; border: 1px solid #5A5753; color: #000; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 400;">Replace All</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    console.log('[Luna Composer] Setting innerHTML, length:', html.length);
                    pageContentEl.innerHTML = html;
                    let highlightTooltip = document.getElementById('luna-composer-highlight-tooltip');
                    if (!highlightTooltip) {
                        highlightTooltip = document.createElement('div');
                        highlightTooltip.id = 'luna-composer-highlight-tooltip';
                        highlightTooltip.style.cssText = 'display: none; position: fixed; top: 0; left: 0; transform: translate(-50%, -100%); background: rgba(0,0,0,0.92); border: 1px solid #2E2C2A; border-radius: 6px; padding: 8px 12px; z-index: 20000; align-items: center; gap: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.35);';

                        const tooltipText = document.createElement('span');
                        tooltipText.textContent = 'Reimagine selection?';
                        tooltipText.style.cssText = 'color: #fff4e9; font-size: 0.75rem;';

                        const actionButton = document.createElement('button');
                        actionButton.id = 'luna-composer-highlight-action';
                        actionButton.textContent = 'Reimagine';
                        actionButton.style.cssText = 'background: #2E2C2A; border: none; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; transition: background 0.2s ease;';
                        actionButton.addEventListener('mouseenter', () => {
                            actionButton.style.background = '#3A3836';
                        });
                        actionButton.addEventListener('mouseleave', () => {
                            actionButton.style.background = '#2E2C2A';
                        });

                        highlightTooltip.appendChild(tooltipText);
                        highlightTooltip.appendChild(actionButton);

                        pageContentEl.appendChild(highlightTooltip);
                    }
                    pageContentEl.style.display = 'block';
                    pageContentEl.style.visibility = 'visible';
                    pageContentEl.style.opacity = '1';
                    
                    // Ensure it's visible
                    console.log('[Luna Composer] Page content display:', pageContentEl.style.display);
                    console.log('[Luna Composer] Page content innerHTML length:', pageContentEl.innerHTML.length);
                    
                    // Initialize auto-save and history
                    setTimeout(() => {
                        initializeLunaComposerAutoSave();
                        loadLunaComposerHistory();
                        initializeCannedPromptsScroll();
                        initializeLunaComposerIntelligentMode();
                        // Initialize heart icon state for current document
                        window.lunaComposerUpdateHeartState();
                    }, 100);
                } else {
                    console.error('[Luna Composer] Page content element not found!');
                }
                
            } catch (error) {
                console.error('[Luna Composer] Error rendering:', error);
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load Luna Composer: ' + error.message + '</p></div>';
                }
            }
        }

        // Fetch data on load - AFTER authentication is verified
        async function initializeDashboard() {
            try {
                console.log('Initializing dashboard with license key:', licenseKey);
                
                // Check if we're on the Omniscient App Observatory page
                if (isOmniscientPage) {
                    
                    // Ensure page content container is visible BEFORE rendering
                    const pageContent = document.getElementById('vlPageContent');
                    if (pageContent) {
                        pageContent.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                    }
                    
                    await renderOmniscientAppObservatory();

                    try {
                        const observatoryConstellation = await fetchConstellationData();
                        if (observatoryConstellation) {
                            console.log('[Omniscient] Loaded constellation data for sidebar widgets:', observatoryConstellation);
                            constellationData = observatoryConstellation;
                        }
                    } catch (constellationError) {
                        console.error('[Omniscient] Failed to load constellation data for sidebar widgets:', constellationError);
                    }

                    try {
                        await updateSuperclusterSummary();
                    } catch (summaryError) {
                        console.error('[Omniscient] Unable to update Supercluster summary:', summaryError);
                    }

                    try {
                        await loadRecentActivity();
                    } catch (activityError) {
                        console.error('[Omniscient] Unable to load recent activity:', activityError);
                    }
                    
                    // Additional safeguard after rendering
                    setTimeout(() => {
                        const overlay = document.querySelector('.vl-supercluster-overlay');
                        const header = document.querySelector('.vl-header');
                        const mainMenu = document.querySelector('.vl-main-menu');
                        const rightSidebar = document.querySelector('.vl-right-sidebar');
                        const pageContentEl = document.getElementById('vlPageContent');
                        const rootContainerEl = document.getElementById('vlSuperclusterRoot');
                        
                        
                        if (overlay) {
                            overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (header) {
                            header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (mainMenu) {
                            mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (rightSidebar) {
                            rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (pageContentEl) {
                            pageContentEl.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                        }
                    }, 100);
                    
                    // Continue checking periodically
                    setTimeout(() => {
                        const pageContentEl = document.getElementById('vlPageContent');
                        const rootContainerEl = document.getElementById('vlSuperclusterRoot');
                        if (pageContentEl && (pageContentEl.style.display === 'none' || window.getComputedStyle(pageContentEl).display === 'none')) {
                            console.warn('[Omniscient] Page content was hidden, restoring');
                            pageContentEl.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                        }
                    }, 500);
                    
                    return;
                }
                
                // Check if we're on a shared Luna Composer page
                if (isSharedComposePage && sharedDocumentId) {
                    await renderSharedLunaComposer(sharedDocumentId);
                    return;
                }
                
                // Check if we're on the Luna Composer page
                if (isLunaComposePage) {
                    // Hide Luna widget overlay if it exists (from the widget JS) - but keep the container visible
                    const lunaOverlay = document.querySelector('.luna-overlay');
                    if (lunaOverlay) {
                        lunaOverlay.style.display = 'none';
                    }
                    // Ensure the Luna widget container is visible and functional
                    const lunaContainer = document.getElementById('vlLunaChatContainer');
                    if (lunaContainer) {
                        lunaContainer.style.display = 'block';
                        lunaContainer.style.visibility = 'visible';
                        lunaContainer.style.opacity = '1';
                    }
                    await renderLunaComposer();
                    // Load Luna Widget after composer is rendered
                    setTimeout(() => {
                        if (typeof checkAndLoadLunaWidget === 'function') {
                            checkAndLoadLunaWidget();
                        }
                    }, 500);
                    return;
                }
                
                // Show Supercluster root and hide page content (default state)
                // Only do this if NOT on Omniscient page
                if (!isOmniscientPage) {
                const rootContainer = document.getElementById('vlSuperclusterRoot');
                const pageContent = document.getElementById('vlPageContent');
                if (rootContainer) {
                    rootContainer.style.display = 'block';
                    // Ensure canvas is visible on main dashboard
                    const canvasElements = rootContainer.querySelectorAll('canvas');
                    canvasElements.forEach(canvas => {
                        const isThreeJSCanvas = canvas.getAttribute('data-engine') === 'three.js r180' || 
                                               canvas.getAttribute('data-engine')?.includes('three.js') ||
                                               (!canvas.getAttribute('data-engine') && canvasElements.length === 1);
                        if (isThreeJSCanvas) {
                            // Force canvas to be visible on main dashboard
                            canvas.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; z-index: auto !important;';
                        }
                    });
                    // Ensure labels are visible on main dashboard
                    hideSuperclusterLabels(); // This will ensure labels are visible on main dashboard
                }
                if (pageContent) {
                    pageContent.style.display = 'none';
                    }
                }
                
                // Check for category page URL first
                if (checkUrlForCategoryPage()) {
                    // Category page is being rendered, exit early
                    return;
                }
                
                // Check for stream data page URL - if found, render that instead of dashboard
                if (checkUrlForStreamDataPage()) {
                    // Stream data page is being rendered, exit early
                    return;
                }
                
                // On main dashboard (not a category or stream page), ensure canvas and labels are visible
                // This is a safeguard to ensure the Three.js canvas and labels display on the main Supercluster page
                setTimeout(() => {
                    const rootContainer = document.getElementById('vlSuperclusterRoot');
                    if (rootContainer) {
                        const canvasElements = rootContainer.querySelectorAll('canvas');
                        canvasElements.forEach(canvas => {
                            const isThreeJSCanvas = canvas.getAttribute('data-engine') === 'three.js r180' || 
                                                   canvas.getAttribute('data-engine')?.includes('three.js') ||
                                                   (!canvas.getAttribute('data-engine') && canvasElements.length === 1);
                            if (isThreeJSCanvas) {
                                const computedDisplay = window.getComputedStyle(canvas).display;
                                if (computedDisplay === 'none') {
                                    console.log('[Supercluster] Canvas was hidden, restoring visibility on main dashboard');
                                    canvas.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; z-index: auto !important;';
                                }
                            }
                        });
                        // Ensure labels are visible on main dashboard
                        hideSuperclusterLabels(); // This will ensure labels are visible on main dashboard
                    }
                }, 1000); // Wait 1 second to ensure Three.js has initialized
                
                // Update license key display immediately
                updateLicenseKeyDisplay();
                
                // Fetch constellation data for this client's license
                const data = await fetchConstellationData();
            console.log('Constellation data loaded:', data);
            constellationData = data;
            updateVerificationPanel(data, dataFetchError);
                
            if (data && data.clients && data.clients.length > 0) {
                    // Use the client data that matches the license (should be first/only one after filtering)
                    const clientData = data.clients[0];
                    console.log('Updating galaxy with client data:', clientData);
                    // Only update galaxy data if it's initialized (three.js scene is ready)
                    if (typeof galaxyData !== 'undefined' && galaxyData && Array.isArray(galaxyData)) {
                    updateGalaxyDataWithRealData(clientData);
                    } else {
                        console.warn('[Supercluster] galaxyData not yet initialized, will update when scene is ready');
                    }
                }
                    
                // Load supercluster summary and recent activity (always call these, even if no client data)
                    await updateSuperclusterSummary();
                    await loadRecentActivity();
                
            // Refresh client name with new data
            await refreshClientName();
                
                // Update license key display again after data is loaded
                updateLicenseKeyDisplay();
                
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
                dataFetchError = error.message;
            // Still try to refresh client name in case we have cached data
            await refreshClientName();
                // Still try to load widgets even if there's an error
                try {
                    await updateSuperclusterSummary();
                    await loadRecentActivity();
                } catch (widgetError) {
                    console.error('Failed to load widgets:', widgetError);
                }
                updateLicenseKeyDisplay();
            }
        }
        
        // Initialize dashboard after authentication (skip for shared documents)
        if (!isSharedComposePage) {
        initializeDashboard().then(() => {
            // Initialize VL Overlay after dashboard is ready
            initializeVLOverlay();
        }).catch(err => {
            console.error('Dashboard initialization failed:', err);
            // Still try to initialize overlay even if dashboard fails
            initializeVLOverlay();
        });
        }

        // Set up periodic data refresh (every 5 minutes) - only for authenticated users
        if (!isSharedComposePage) {
        setInterval(async () => {
            console.log('Refreshing constellation data...');
            const data = await fetchConstellationData();
            constellationData = data;
            updateVerificationPanel(data, dataFetchError);
            if (data && data.clients && data.clients.length > 0) {
                    // Only update galaxy data if it's initialized (three.js scene is ready)
                    if (typeof galaxyData !== 'undefined' && galaxyData && Array.isArray(galaxyData) && galaxyData.length > 0) {
                updateGalaxyDataWithRealData(data.clients[0]);
                    } else {
                        console.warn('[Supercluster] galaxyData not yet initialized, skipping update');
                    }
            }
            // Refresh client name with new data
            await refreshClientName();
        }, 5 * 60 * 1000); // 5 minutes
        }

        const rootContainer = document.getElementById("vlSuperclusterRoot") || document.body;
        const htmlElement = document.documentElement;
        const bodyElement = document.body;
        const scrollLockClass = "vl-supercluster-scroll-lock";



        function createSoftParticleTexture(size = 256) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            const half = size / 2;
            const gradient = context.createRadialGradient(half, half, 0, half, half, half);
            gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
            gradient.addColorStop(0.35, "rgba(255, 255, 255, 0.75)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        function createNebulaTexture(size = 512) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            context.clearRect(0, 0, size, size);
            const center = size / 2;
            
            // Your brand colors
            const brandColors = ['#920101', '#1f1d1a', '#974C00'];
            const selectedColor = brandColors[Math.floor(Math.random() * brandColors.length)];
            
            // Convert hex to RGB for opacity variations
            const hex = selectedColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);

            const baseGradient = context.createRadialGradient(center, center, size * 0.1, center, center, center);
            baseGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.75)`);
            baseGradient.addColorStop(0.35, `rgba(${r}, ${g}, ${b}, 0.55)`);
            baseGradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.32)`);
            baseGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            context.fillStyle = baseGradient;
            context.fillRect(0, 0, size, size);

            const shardCount = 8 + Math.floor(Math.random() * 6);
            for (let i = 0; i < shardCount; i++) {
                const shardX = center + (Math.random() - 0.5) * size * 0.55;
                const shardY = center + (Math.random() - 0.5) * size * 0.35;
                const shardRadius = size * (0.08 + Math.random() * 0.14);
                const shardGradient = context.createRadialGradient(
                    shardX,
                    shardY,
                    shardRadius * 0.2,
                    shardX,
                    shardY,
                    shardRadius
                );
                shardGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.65)`);
                shardGradient.addColorStop(0.55, `rgba(${r}, ${g}, ${b}, 0.35)`);
                shardGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
                context.fillStyle = shardGradient;
                context.beginPath();
                context.arc(shardX, shardY, shardRadius, 0, Math.PI * 2);
                context.fill();
            }

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        // Create dust-like galaxy cloud texture
        function createGalaxyCloudTexture(size = 512, baseColor, uniqueColor) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            context.clearRect(0, 0, size, size);
            const center = size / 2;
            
            // Convert colors to RGB
            const baseR = Math.floor(baseColor.r * 255);
            const baseG = Math.floor(baseColor.g * 255);
            const baseB = Math.floor(baseColor.b * 255);
            
            const uniqueR = Math.floor(uniqueColor.r * 255);
            const uniqueG = Math.floor(uniqueColor.g * 255);
            const uniqueB = Math.floor(uniqueColor.b * 255);
            
            // Create multiple overlapping dust clouds
            const cloudCount = 12 + Math.floor(Math.random() * 8);
            for (let i = 0; i < cloudCount; i++) {
                const cloudX = center + (Math.random() - 0.5) * size * 0.7;
                const cloudY = center + (Math.random() - 0.5) * size * 0.7;
                const cloudRadius = size * (0.15 + Math.random() * 0.25);
                
                // Mix base and unique colors for each cloud
                const mixFactor = Math.random();
                const r = Math.floor(baseR * (1 - mixFactor) + uniqueR * mixFactor);
                const g = Math.floor(baseG * (1 - mixFactor) + uniqueG * mixFactor);
                const b = Math.floor(baseB * (1 - mixFactor) + uniqueB * mixFactor);
                
                // Create dust-like gradient with noise
                const cloudGradient = context.createRadialGradient(
                    cloudX,
                    cloudY,
                    cloudRadius * 0.1,
                    cloudX,
                    cloudY,
                    cloudRadius
                );
                cloudGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.15 + Math.random() * 0.1})`);
                cloudGradient.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, ${0.08 + Math.random() * 0.08})`);
                cloudGradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, ${0.04 + Math.random() * 0.04})`);
                cloudGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
                
                context.fillStyle = cloudGradient;
                context.beginPath();
                context.arc(cloudX, cloudY, cloudRadius, 0, Math.PI * 2);
                context.fill();
                
                // Add finer dust particles
                const dustCount = 20 + Math.floor(Math.random() * 15);
                for (let j = 0; j < dustCount; j++) {
                    const dustX = cloudX + (Math.random() - 0.5) * cloudRadius * 1.5;
                    const dustY = cloudY + (Math.random() - 0.5) * cloudRadius * 1.5;
                    const dustRadius = cloudRadius * (0.05 + Math.random() * 0.15);
                    const dustAlpha = 0.02 + Math.random() * 0.06;
                    
                    const dustGradient = context.createRadialGradient(
                        dustX,
                        dustY,
                        0,
                        dustX,
                        dustY,
                        dustRadius
                    );
                    dustGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${dustAlpha})`);
                    dustGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
                    
                    context.fillStyle = dustGradient;
                    context.beginPath();
                    context.arc(dustX, dustY, dustRadius, 0, Math.PI * 2);
                    context.fill();
                }
            }
            
            // Add subtle noise for dust texture
            const imageData = context.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const noise = (Math.random() - 0.5) * 0.1;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise * 255));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise * 255));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise * 255));
                }
            }
            context.putImageData(imageData, 0, 0);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        // Create finer dust particle texture
        function createDustParticleTexture(size = 128) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            const half = size / 2;
            const gradient = context.createRadialGradient(half, half, 0, half, half, half);
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
            gradient.addColorStop(0.4, "rgba(255, 255, 255, 0.4)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        const baseParticleTexture = createSoftParticleTexture();
        const dustParticleTexture = createDustParticleTexture();

            // Only initialize three.js scene if NOT on Omniscient App Observatory page or Luna Composer page
            let scene, renderer, camera, controls, superclusterGroup;
            
            if (!isOmniscientPage && !isLunaComposePage) {
            scene = new THREE.Scene();
        scene.background = new THREE.Color(0x02040a);
        scene.fog = new THREE.FogExp2(0x040714, 0.00035);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.12;
            rootContainer.insertBefore(renderer.domElement, rootContainer.firstChild || null);

            camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 1500);
        camera.position.set(0, 120, 800); // Start at maximum zoom-out distance

            controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 120;
        controls.maxDistance = 800;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.18;
        controls.enablePan = false;
        
        // Set the target to center on the supercluster (0, 0, 0)
        controls.target.set(0, 0, 0);
        controls.update();

            superclusterGroup = new THREE.Group();
        superclusterGroup.name = 'superclusterGroup';
        scene.add(superclusterGroup);

        const atmosphereShell = new THREE.Mesh(
            new THREE.SphereGeometry(1400, 64, 64),
            new THREE.MeshBasicMaterial({
                color: 0x060b18,
                transparent: true,
                opacity: 0.42,
                side: THREE.BackSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            })
        );
        scene.add(atmosphereShell);

        const nebulaGroup = new THREE.Group();
        superclusterGroup.add(nebulaGroup);
        const nebulaClouds = [];

        function seedNebulaClouds() {
            nebulaGroup.clear();
            nebulaClouds.length = 0;
            const cloudCount = 7 + Math.floor(Math.random() * 3);
            for (let i = 0; i < cloudCount; i++) {
                const nebulaTexture = createNebulaTexture();
                const geometry = new THREE.PlaneGeometry(420 + Math.random() * 260, 280 + Math.random() * 180, 1, 1);
                const material = new THREE.MeshBasicMaterial({
                    map: nebulaTexture,
                    transparent: true,
                    opacity: 0.24 + Math.random() * 0.18,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: false,
                    side: THREE.DoubleSide,
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set((Math.random() - 0.5) * 420, (Math.random() - 0.5) * 260, (Math.random() - 0.5) * 420);
                mesh.rotation.set(
                    Math.PI / 2 + (Math.random() - 0.5) * 0.6,
                    (Math.random() - 0.5) * 0.9,
                    (Math.random() - 0.5) * 0.6
                );
                mesh.userData = {
                    baseOpacity: material.opacity,
                    basePosition: mesh.position.clone(),
                    drift: new THREE.Vector3((Math.random() - 0.5) * 26, (Math.random() - 0.5) * 18, (Math.random() - 0.5) * 26),
                    rotationSpeed: 0.00008 + Math.random() * 0.00018,
                    phaseOffset: Math.random() * Math.PI * 2,
                };
                nebulaGroup.add(mesh);
                nebulaClouds.push(mesh);
            }
        }

        seedNebulaClouds();

        // Declare galaxyData globally so it's accessible to updateGalaxyDataWithRealData
        if (typeof galaxyData === 'undefined') {
            var galaxyData = [];
        }
        
        galaxyData = [
            {
                name: "Website Infrastructure & Performance",
                datasetSlugs: ["infrastructure", "themes", "operations"],
                fallbackDescription:
                    "Optimize delivery, resiliency, and user experience with infrastructure telemetry spanning uptime, performance, and observability signals.",
                description: "",
                position: new THREE.Vector3(-220, 60, -140),
                color: "#6fb1ff",
                connections: ["Content Management & Structure", "Analytics & Engagement"],
            },
            {
                name: "Content Management & Structure",
                datasetSlugs: ["content", "structure"],
                fallbackDescription:
                    "Govern editorial pipelines, asset taxonomies, and omnichannel orchestration to keep experiences coherent across platforms.",
                description: "",
                position: new THREE.Vector3(-80, 20, 60),
                color: "#ff9cf0",
                connections: ["Website Infrastructure & Performance", "Search Engine Intelligence", "Marketing & Campaign Data"],
            },
            {
                name: "Search Engine Intelligence",
                datasetSlugs: ["ai", "search", "integrations"],
                fallbackDescription:
                    "Harvest crawl signals, SERP movement, and algorithmic shifts to ensure content is discoverable and performant.",
                description: "",
                position: new THREE.Vector3(40, 140, -60),
                color: "#83f3ff",
                connections: ["Content Management & Structure", "Analytics & Engagement", "Competitive & Market Data"],
            },
            {
                name: "Analytics & Engagement",
                datasetSlugs: ["sessions", "analytics", "engagement"],
                fallbackDescription:
                    "Synthesize behavioral analytics, funnel friction, and feedback loops to illuminate experience optimization opportunities.",
                description: "",
                position: new THREE.Vector3(160, 40, 120),
                color: "#ffe699",
                connections: ["Website Infrastructure & Performance", "Search Engine Intelligence", "Marketing & Campaign Data", "User & Identity Layer"],
            },
            {
                name: "Marketing & Campaign Data",
                datasetSlugs: ["integrations", "marketing", "campaigns"],
                fallbackDescription:
                    "Unify campaign performance, attribution modeling, and creative intelligence to amplify revenue-driving initiatives.",
                description: "",
                position: new THREE.Vector3(260, -20, -80),
                color: "#d9a6ff",
                connections: ["Content Management & Structure", "Analytics & Engagement", "E-Commerce & Conversion Data"],
            },
            {
                name: "E-Commerce & Conversion Data",
                datasetSlugs: ["plugins", "commerce", "ecommerce"],
                fallbackDescription:
                    "Map product analytics, merchandising flows, and conversion health to reveal revenue acceleration pathways.",
                description: "",
                position: new THREE.Vector3(-40, -120, -40),
                color: "#ff6b6b",
                connections: ["Marketing & Campaign Data", "User & Identity Layer", "Security & Compliance Data"],
            },
            {
                name: "Security & Compliance Data",
                datasetSlugs: ["security", "compliance"],
                fallbackDescription:
                    "Monitor threat detection, governance policies, and regulatory controls to keep the data supply chain secure.",
                description: "",
                position: new THREE.Vector3(-200, -40, 150),
                color: "#9dffb0",
                connections: ["CloudOps & Infrastructure Metrics", "E-Commerce & Conversion Data"],
            },
            {
                name: "CloudOps & Infrastructure Metrics",
                datasetSlugs: ["themes", "infrastructure", "cloudops"],
                fallbackDescription:
                    "Observe deployment velocity, cost efficiency, and platform reliability to ensure modern operations excellence.",
                description: "",
                position: new THREE.Vector3(100, -180, 60),
                color: "#ffc7a5",
                connections: ["Security & Compliance Data", "Website Infrastructure & Performance"],
            },
            {
                name: "User & Identity Layer",
                datasetSlugs: ["identity", "users"],
                fallbackDescription:
                    "Understand identity graphs, access journeys, and consent preferences to personalize experiences responsibly.",
                description: "",
                position: new THREE.Vector3(-280, 160, 60),
                color: "#7f9bff",
                connections: ["Analytics & Engagement", "E-Commerce & Conversion Data", "Competitive & Market Data"],
            },
            {
                name: "Competitive & Market Data",
                datasetSlugs: ["users", "market", "competitive"],
                fallbackDescription:
                    "Track competitive shifts, market momentum, and whitespace detection to guide strategic positioning.",
                description: "",
                position: new THREE.Vector3(60, -40, 220),
                color: "#9bffe7",
                connections: ["Search Engine Intelligence", "User & Identity Layer"],
            },
        ];

        galaxyData.forEach((entry) => {
            entry.slug = entry.datasetSlugs[0];
            entry.description = entry.fallbackDescription;
            entry.metrics = null;
        });

        const galaxyGroups = new Map();

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const tempWorldPosition = new THREE.Vector3();
        const projectedPosition = new THREE.Vector3();
        const cameraDirection = new THREE.Vector3();
        const panRight = new THREE.Vector3();
        const zoomOffset = new THREE.Vector3();

        // Only create labels container if NOT on Luna Composer page
        let labelsContainer = null;
        if (!isLunaComposePage) {
            labelsContainer = document.createElement("div");
        labelsContainer.className = "vl-supercluster-labels";
            rootContainer.appendChild(labelsContainer);
        }

        function createLabel(name) {
            const el = document.createElement("div");
            el.className = "floating-label";
            el.textContent = name;
            
            // Custom styling for galaxy labels
            el.style.position = "absolute"; // Required for backdropFilter
            el.style.color = "#fff4e7"; // White text
            el.style.fontSize = "14px";
            el.style.fontWeight = "600";
            el.style.letterSpacing = "0";
            el.style.textTransform = "capitalize";
            el.style.textShadow = "0 0 10px rgba(0,0,0, 0.8)"; // Blue glow
            el.style.background = "rgba(0,0,0, 0.8)"; // Dark background
            el.style.padding = "8px 12px";
            el.style.borderRadius = "50px";
            el.style.backdropFilter = "blur(8px)"; // Standard
            el.style.webkitBackdropFilter = "blur(8px)"; // Safari support
            el.style.isolation = "isolate"; // Create stacking context
            el.style.willChange = "transform"; // Optimize rendering
            
            if (labelsContainer) {
            labelsContainer.appendChild(el);
            }
            return el;
        }

        function createGalaxy({ name, position, color }) {
            const group = new THREE.Group();
            group.position.copy(position);

            const baseColor = new THREE.Color(color);
            const highlightColor = baseColor.clone().lerp(new THREE.Color(0xffffff), 0.35);
            const coreColor = baseColor.clone().lerp(new THREE.Color(0xffffcc), 0.4);

            // Central core/bulge - brighter and more defined
            const coreGeometry = new THREE.SphereGeometry(8.5, 64, 64);
            const coreMaterial = new THREE.MeshPhongMaterial({
                color: coreColor,
                emissive: baseColor.clone().multiplyScalar(0.75),
                shininess: 180,
                specular: 0xffffff,
            });
            coreMaterial.emissiveIntensity = 1.4;
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            group.add(core);

            // Extended halo around core - more subtle glow
            const haloGeometry = new THREE.SphereGeometry(32, 64, 64);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: highlightColor,
                transparent: true,
                opacity: 0.18,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            group.add(halo);

            // Additional subtle glow layers
            const halo2Geometry = new THREE.SphereGeometry(40, 64, 64);
            const halo2Material = new THREE.MeshBasicMaterial({
                color: highlightColor,
                transparent: true,
                opacity: 0.12,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const halo2 = new THREE.Mesh(halo2Geometry, halo2Material);
            group.add(halo2);
            
            const halo3Geometry = new THREE.SphereGeometry(50, 64, 64);
            const halo3Material = new THREE.MeshBasicMaterial({
                color: baseColor,
                transparent: true,
                opacity: 0.08,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const halo3 = new THREE.Mesh(halo3Geometry, halo3Material);
            group.add(halo3);

            // Replace oval discs with prominent galaxy clouds - unique colors per galaxy
            const uniqueColorHue = Math.random() * 0.3 + 0.5; // Vary hue slightly
            const uniqueColor = new THREE.Color().setHSL(uniqueColorHue, 0.4 + Math.random() * 0.3, 0.5 + Math.random() * 0.3);
            const cloudTexture1 = createGalaxyCloudTexture(512, baseColor, uniqueColor);
            
            // Main galactic cloud - more prominent and dust-like
            const cloudGeometry1 = new THREE.PlaneGeometry(90, 90, 1, 1);
            const cloudMaterial1 = new THREE.MeshBasicMaterial({
                map: cloudTexture1,
                transparent: true,
                opacity: 0.35,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const cloud1 = new THREE.Mesh(cloudGeometry1, cloudMaterial1);
            cloud1.rotation.x = Math.PI / 2;
            cloud1.rotation.z = Math.random() * Math.PI;
            cloud1.rotation.y = Math.random() * Math.PI * 0.3;
            group.add(cloud1);
            
            // Secondary cloud layer for depth
            const cloudTexture2 = createGalaxyCloudTexture(512, baseColor, uniqueColor);
            const cloudGeometry2 = new THREE.PlaneGeometry(110, 110, 1, 1);
            const cloudMaterial2 = new THREE.MeshBasicMaterial({
                map: cloudTexture2,
                transparent: true,
                opacity: 0.22,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const cloud2 = new THREE.Mesh(cloudGeometry2, cloudMaterial2);
            cloud2.rotation.x = Math.PI / 2.1;
            cloud2.rotation.z = Math.random() * Math.PI;
            cloud2.rotation.y = Math.random() * Math.PI * 0.3;
            group.add(cloud2);
            
            // Outer cloud ring
            const cloudTexture3 = createGalaxyCloudTexture(512, baseColor, uniqueColor);
            const cloudGeometry3 = new THREE.PlaneGeometry(130, 130, 1, 1);
            const cloudMaterial3 = new THREE.MeshBasicMaterial({
                map: cloudTexture3,
                transparent: true,
                opacity: 0.18,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const outerCloud = new THREE.Mesh(cloudGeometry3, cloudMaterial3);
            outerCloud.rotation.x = Math.PI / 2.15 + (Math.random() - 0.5) * 0.2;
            outerCloud.rotation.z = Math.random() * Math.PI;
            group.add(outerCloud);

            // Create realistic spiral arms - more defined and galaxy-like
            const armCount = 2 + Math.floor(Math.random() * 2); // 2-3 arms like real galaxies
            const pointsPerArm = 200;
            const swirlPositions = new Float32Array(armCount * pointsPerArm * 3);
            const swirlColors = new Float32Array(armCount * pointsPerArm * 3);
            let pointer = 0;
            let colorPointer = 0;
            
            for (let arm = 0; arm < armCount; arm++) {
                const armOffset = (Math.PI * 2 * arm) / armCount;
                const armTightness = 0.12 + Math.random() * 0.08; // Spiral tightness
                
                for (let i = 0; i < pointsPerArm; i++) {
                    const t = i / pointsPerArm;
                    // Logarithmic spiral for more realistic appearance
                    const angle = t * Math.PI * 4.2 + armOffset + Math.log(1 + t * 9) * armTightness;
                    const radius = 12 + t * 110 + Math.sin(t * Math.PI * 3) * 8; // More variation
                    const jitter = (1 - t) * 4; // Less jitter for cleaner arms
                    
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * jitter;
                    const y = (Math.random() - 0.5) * (4 + t * 18); // Flatter disc
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * jitter;
                    
                    swirlPositions[pointer++] = x;
                    swirlPositions[pointer++] = y;
                    swirlPositions[pointer++] = z;
                    
                    // Color gradient along arms (brighter near core)
                    const brightness = 0.6 + (1 - t) * 0.4;
                    const armColor = highlightColor.clone().multiplyScalar(brightness);
                    swirlColors[colorPointer++] = armColor.r;
                    swirlColors[colorPointer++] = armColor.g;
                    swirlColors[colorPointer++] = armColor.b;
                }
            }
            
            const swirlGeometry = new THREE.BufferGeometry();
            swirlGeometry.setAttribute("position", new THREE.BufferAttribute(swirlPositions, 3));
            swirlGeometry.setAttribute("color", new THREE.BufferAttribute(swirlColors, 3));
            
            const swirlMaterial = new THREE.PointsMaterial({
                map: baseParticleTexture,
                color: highlightColor,
                vertexColors: true,
                size: 12 + Math.random() * 4,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.65,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false,
                alphaTest: 0.01,
            });
            
            const swirl = new THREE.Points(swirlGeometry, swirlMaterial);
            swirl.rotation.x = Math.PI / 2.35 + (Math.random() - 0.5) * 0.12;
            swirl.userData = {
                spinSpeed: 0.00018 + Math.random() * 0.00012,
                baseOpacity: swirlMaterial.opacity,
                wobbleStrength: 0.06 + Math.random() * 0.04,
            };
            group.add(swirl);

            // More stars with varying sizes
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1400; // Increased from 720
            const positions = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);
            const starColors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                const radius = 20 + Math.random() * 130;
                const theta = Math.random() * Math.PI * 2;
                const cosPhi = Math.random() * 2 - 1;
                const phi = Math.acos(cosPhi);
                const wobble = Math.pow(Math.random(), 2.4);
                positions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
                positions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius * (0.35 + Math.random() * 0.9);
                positions[i * 3 + 2] = Math.cos(phi) * radius;
                if (Math.random() > 0.6) {
                    positions[i * 3 + 1] *= 0.45 + wobble * 0.55;
                }
                
                // Varying star sizes
                starSizes[i] = 3 + Math.random() * 8 + Math.pow(Math.random(), 3) * 5;
                
                // Varying star colors (slightly tinted)
                const starBrightness = 0.7 + Math.random() * 0.3;
                const starColor = highlightColor.clone().lerp(new THREE.Color(0xffffff), 0.3 + Math.random() * 0.2);
                starColor.multiplyScalar(starBrightness);
                starColors[i * 3] = starColor.r;
                starColors[i * 3 + 1] = starColor.g;
                starColors[i * 3 + 2] = starColor.b;
            }

            starGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute("size", new THREE.BufferAttribute(starSizes, 1));
            starGeometry.setAttribute("color", new THREE.BufferAttribute(starColors, 3));

            const starMaterial = new THREE.PointsMaterial({
                map: baseParticleTexture,
                color: highlightColor.clone().lerp(new THREE.Color(0xffffff), 0.25),
                vertexColors: true,
                size: 6.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.65,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
            });
            const stars = new THREE.Points(starGeometry, starMaterial);
            stars.userData = { type: "galaxy", name, baseCount: starCount };
            group.add(stars);
            
            // Add finer dust-like particles
            const dustGeometry = new THREE.BufferGeometry();
            const dustCount = 800;
            const dustPositions = new Float32Array(dustCount * 3);
            const dustSizes = new Float32Array(dustCount);
            const dustColors = new Float32Array(dustCount * 3);
            
            for (let i = 0; i < dustCount; i++) {
                const radius = 15 + Math.random() * 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                dustPositions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
                dustPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius * (0.3 + Math.random() * 0.7);
                dustPositions[i * 3 + 2] = Math.cos(phi) * radius;
                
                // Smaller dust particles
                dustSizes[i] = 1.5 + Math.random() * 3;
                
                // Dust particles with unique color tint
                const dustColor = baseColor.clone().lerp(uniqueColor, 0.3 + Math.random() * 0.4);
                dustColor.multiplyScalar(0.4 + Math.random() * 0.3);
                dustColors[i * 3] = dustColor.r;
                dustColors[i * 3 + 1] = dustColor.g;
                dustColors[i * 3 + 2] = dustColor.b;
            }
            
            dustGeometry.setAttribute("position", new THREE.BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute("size", new THREE.BufferAttribute(dustSizes, 1));
            dustGeometry.setAttribute("color", new THREE.BufferAttribute(dustColors, 3));
            
            const dustMaterial = new THREE.PointsMaterial({
                map: dustParticleTexture,
                vertexColors: true,
                size: 2.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.35,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            dust.userData = { spinSpeed: 0.00008 + Math.random() * 0.00006 };
            group.add(dust);

            const sparkGeometry = new THREE.BufferGeometry();
            const sparkCount = 160;
            const sparkPositions = new Float32Array(sparkCount * 3);
            for (let i = 0; i < sparkCount; i++) {
                const radius = 16 + Math.random() * 42;
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 14;
                sparkPositions[i * 3] = Math.cos(angle) * radius;
                sparkPositions[i * 3 + 1] = height;
                sparkPositions[i * 3 + 2] = Math.sin(angle) * radius;
            }
            sparkGeometry.setAttribute("position", new THREE.BufferAttribute(sparkPositions, 3));
            const sparkMaterial = new THREE.PointsMaterial({
                map: baseParticleTexture,
                color: highlightColor.clone().lerp(new THREE.Color(0xffffff), 0.5),
                size: 10,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.42,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
            });
            const sparkLayer = new THREE.Points(sparkGeometry, sparkMaterial);
            sparkLayer.rotation.x = Math.PI / 2;
            sparkLayer.userData = { spinSpeed: 0.00035 + Math.random() * 0.0002 };
            group.add(sparkLayer);

            // More realistic lighting - softer point light
            const pointLight = new THREE.PointLight(highlightColor, 2.2, 600, 2.2);
            pointLight.position.set(0, 0, 0);
            group.add(pointLight);
            
            // Additional subtle rim light
            const rimLight = new THREE.PointLight(baseColor, 0.8, 400, 1.8);
            rimLight.position.set(0, 0, 0);
            group.add(rimLight);

            const label = createLabel(name);
            label.dataset.target = name;

            galaxyGroups.set(name, {
                name,
                group,
                core,
                halo,
                halo2,
                halo3,
                stars,
                dust,
                swirl,
                sparkLayer,
                cloud1,
                cloud2,
                outerCloud,
                orbit: outerCloud, // Use outerCloud instead of orbit
                label,
                pointLight,
                rimLight,
                baseColor: baseColor.clone(),
                color: highlightColor.clone(),
                uniqueColor: uniqueColor.clone(),
                dataset: null,
                baseStarSize: starMaterial.size,
            });
            superclusterGroup.add(group);
        }

        galaxyData.forEach(createGalaxy);
        
        // After galaxyData is initialized, update it with real data if available
        if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
            const clientData = constellationData.clients[0];
            console.log('[Supercluster] Updating galaxy data with real data after initialization');
            updateGalaxyDataWithRealData(clientData);
        }

        const ambientLight = new THREE.AmbientLight(0x5f6f9f, 0.48);
        scene.add(ambientLight);

        const rimLight = new THREE.DirectionalLight(0x9fd6ff, 0.75);
        rimLight.position.set(120, 260, 180);
        scene.add(rimLight);

        const warmLight = new THREE.DirectionalLight(0xffbf80, 0.58);
        warmLight.position.set(-220, -160, -180);
        scene.add(warmLight);

        const coolFillLight = new THREE.DirectionalLight(0x3b58ff, 0.32);
        coolFillLight.position.set(-140, 120, 260);
        scene.add(coolFillLight);

        // More dense background stars but very subtle
        const starFieldGeometry = new THREE.BufferGeometry();
        const starFieldCount = 6800; // Increased from 4200
        const starFieldPositions = new Float32Array(starFieldCount * 3);
        const starFieldColors = new Float32Array(starFieldCount * 3);
        const starFieldSizes = new Float32Array(starFieldCount);

        const color = new THREE.Color();
        for (let i = 0; i < starFieldCount; i++) {
            const radius = 920 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            starFieldPositions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
            starFieldPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
            starFieldPositions[i * 3 + 2] = Math.cos(phi) * radius;

            // Subtle colors with varying brightness
            const hue = 0.55 + Math.random() * 0.12;
            const brightness = 0.4 + Math.random() * 0.3; // More subtle
            color.setHSL(hue, 0.5, brightness);
            starFieldColors[i * 3] = color.r;
            starFieldColors[i * 3 + 1] = color.g;
            starFieldColors[i * 3 + 2] = color.b;
            
            // Varying sizes
            starFieldSizes[i] = 1.5 + Math.random() * 3;
        }

        starFieldGeometry.setAttribute("position", new THREE.BufferAttribute(starFieldPositions, 3));
        starFieldGeometry.setAttribute("color", new THREE.BufferAttribute(starFieldColors, 3));
        starFieldGeometry.setAttribute("size", new THREE.BufferAttribute(starFieldSizes, 1));

        const starFieldMaterial = new THREE.PointsMaterial({
            map: baseParticleTexture,
            size: 2.8,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.35, // More subtle - reduced from 0.62
            depthWrite: false,
            depthTest: false,
            blending: THREE.AdditiveBlending,
        });

        const starField = new THREE.Points(starFieldGeometry, starFieldMaterial);
        scene.add(starField);

        // Far background stars - more dense but very subtle
        const farStarFieldGeometry = new THREE.BufferGeometry();
        const farStarFieldCount = 7200; // Increased from 5200
        const farStarFieldPositions = new Float32Array(farStarFieldCount * 3);
        const farStarFieldColors = new Float32Array(farStarFieldCount * 3);
        const farStarFieldSizes = new Float32Array(farStarFieldCount);
        
        for (let i = 0; i < farStarFieldCount; i++) {
            const radius = 1500 * Math.cbrt(Math.random());
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            farStarFieldPositions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
            farStarFieldPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
            farStarFieldPositions[i * 3 + 2] = Math.cos(phi) * radius;

            // More subtle colors
            const hue = 0.54 + Math.random() * 0.1;
            const brightness = 0.3 + Math.random() * 0.2; // More subtle
            color.setHSL(hue, 0.4, brightness);
            farStarFieldColors[i * 3] = color.r;
            farStarFieldColors[i * 3 + 1] = color.g;
            farStarFieldColors[i * 3 + 2] = color.b;
            
            // Varying sizes
            farStarFieldSizes[i] = 2 + Math.random() * 4;
        }
        farStarFieldGeometry.setAttribute("position", new THREE.BufferAttribute(farStarFieldPositions, 3));
        farStarFieldGeometry.setAttribute("color", new THREE.BufferAttribute(farStarFieldColors, 3));
        farStarFieldGeometry.setAttribute("size", new THREE.BufferAttribute(farStarFieldSizes, 1));

        const farStarFieldMaterial = new THREE.PointsMaterial({
            map: baseParticleTexture,
            size: 4.5,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.22, // More subtle - reduced from 0.38
            depthWrite: false,
            depthTest: false,
            blending: THREE.AdditiveBlending,
        });

        const farStarField = new THREE.Points(farStarFieldGeometry, farStarFieldMaterial);
        scene.add(farStarField);

        const connectionBaseColor = new THREE.Color(0x6bc8ff);
        const connectionLines = new THREE.Group();
        superclusterGroup.add(connectionLines);
        
        // Make connectionLines globally accessible
        window.connectionLines = connectionLines;
        const connectionFlowEntries = [];

        const connectionKey = (a, b) => [a, b].sort().join("::");
        const createdConnections = new Set();

        function drawConnections() {
            connectionLines.children.slice().forEach((child) => {
                if (child.geometry) {
                    child.geometry.dispose();
                }
                if (child.material) {
                    child.material.dispose();
                }
            });
            connectionLines.clear();
            connectionFlowEntries.length = 0;
            createdConnections.clear();
            for (const data of galaxyData) {
                const source = galaxyGroups.get(data.name);
                data.connections.forEach((targetName) => {
                    const key = connectionKey(data.name, targetName);
                    if (createdConnections.has(key)) return;

                    const target = galaxyGroups.get(targetName);
                    if (!target) return;

                    const points = [];
                    points.push(source.group.position.clone());
                    const control = source.group.position.clone()
                        .add(target.group.position)
                        .multiplyScalar(0.5)
                        .add(new THREE.Vector3(
                            (Math.random() - 0.5) * 120,
                            (Math.random() - 0.5) * 120,
                            (Math.random() - 0.5) * 120,
                        ));
                    points.push(control);
                    points.push(target.group.position.clone());

                    const curve = new THREE.CatmullRomCurve3(points);
                    // Thinner, more ethereal connection lines
                    const geometry = new THREE.TubeGeometry(curve, 128, 1.2, 16, false);

                    const sourceColor = source?.core?.material?.color?.clone?.() || connectionBaseColor.clone();
                    const targetColor = galaxyGroups.get(targetName)?.core?.material?.color?.clone?.() || connectionBaseColor.clone();
                    const blendedColor = sourceColor.lerp(targetColor, 0.5);

                    const baseOpacity = 0.28 + Math.random() * 0.08;
                    const flowMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            uColor: { value: blendedColor.clone() },
                            uOpacity: { value: baseOpacity },
                            uTime: { value: Math.random() },
                            uHighlight: { value: 0 },
                            uGlowIntensity: { value: 1.2 },
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            varying vec3 vNormal;
                            void main() {
                                vUv = uv;
                                vPosition = position;
                                vNormal = normal;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 uColor;
                            uniform float uOpacity;
                            uniform float uHighlight;
                            uniform float uTime;
                            uniform float uGlowIntensity;
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            varying vec3 vNormal;

                            void main() {
                                // Ethereal flow effect
                                float flow = fract(vUv.x * 1.5 - uTime * 0.8);
                                float head = smoothstep(0.0, 0.3, flow) * smoothstep(1.0, 0.7, flow);
                                
                                // Smooth tapering at ends
                                float taper = smoothstep(0.0, 0.15, vUv.x) * smoothstep(1.0, 0.85, vUv.x);
                                
                                // Pulsing glow effect
                                float pulse = sin(uTime * 2.0 + vUv.x * 3.14159) * 0.5 + 0.5;
                                pulse = smoothstep(0.3, 0.7, pulse);
                                
                                // Radial glow from center of tube
                                float radialGlow = 1.0 - abs(vUv.y - 0.5) * 2.0;
                                radialGlow = pow(radialGlow, 1.5);
                                
                                // Highlight effect
                                float highlight = uHighlight;
                                
                                // Base color with taper
                                vec3 baseColor = mix(uColor * (0.4 + 0.6 * taper), vec3(1.0), highlight * 0.4);
                                
                                // Ethereal glow - more wispy and fluid
                                vec3 glowColor = uColor * (0.5 + 0.5 * pulse) * (0.6 + 0.4 * taper) * radialGlow * uGlowIntensity;
                                
                                // Add flowing particles effect
                                float particles = smoothstep(0.0, 0.2, flow) * smoothstep(1.0, 0.8, flow);
                                glowColor += uColor * particles * 0.6;
                                
                                // Combine colors
                                vec3 color = baseColor + glowColor * (1.0 + highlight * 0.8);
                                
                                // Alpha with smooth fade
                                float alpha = uOpacity * (0.4 + 0.6 * taper) * (0.7 + 0.3 * radialGlow) * (1.0 + highlight * 0.6 + head * 0.4);
                                
                                gl_FragColor = vec4(color, alpha);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide,
                    });

                    const mesh = new THREE.Mesh(geometry, flowMaterial);
                    mesh.userData = {
                        start: data.name,
                        end: targetName,
                        baseColor: blendedColor.clone(),
                        baseOpacity,
                        targetOpacity: baseOpacity,
                        flowSpeed: 0.1 + Math.random() * 0.18,
                    };
                    connectionLines.add(mesh);
                    connectionFlowEntries.push(mesh);

                    createdConnections.add(key);
                });
            }
        }

        drawConnections();

        const infoCard = document.getElementById("infoCard");
        const infoMetricsList = document.getElementById("infoMetrics");
        const defaultSubtitle = "Select a Stream Category";
        const defaultIntroText =
            "Explore the connective tissue of Visible Light AI's intelligence streams. Click any galaxy to learn how each stream powers the constellation of insights.";

        function appendMetric(list, title, detail) {
            if (!list) return;
            const item = document.createElement("li");
            const heading = document.createElement("strong");
            heading.textContent = title;
            const value = document.createElement("span");
            value.textContent = detail;
            item.append(heading, value);
            list.appendChild(item);
        }

        function updateInfoCard(data) {
            if (!infoCard) {
                return;
            }

            if (!data) {
                infoCard.querySelector("h1").textContent = "Visible Light AI Supercluster";
                infoCard.querySelector("h2").textContent = defaultSubtitle;
                infoCard.querySelector("p").textContent = defaultIntroText;
                if (infoMetricsList) {
                    infoMetricsList.innerHTML = "";
                    if (constellationData) {
                        appendMetric(infoMetricsList, "Status", `Connected to VL Hub - ${constellationData.total_clients} clients`);
                        appendMetric(infoMetricsList, "License", licenseKey ? `${licenseKey.substring(0, 8)}...` : "No license key");
                    } else if (dataFetchError) {
                        appendMetric(infoMetricsList, "Status", `Connection failed: ${dataFetchError}`);
                        appendMetric(infoMetricsList, "Retry", "Refreshing in 30 seconds...");
                    } else {
                        appendMetric(infoMetricsList, "Status", "Connecting to VL Hub...");
                    }
                }
                infoCard.classList.remove("visible");
                requestAnimationFrame(() => infoCard.classList.add("visible"));
                return;
            }

            infoCard.querySelector("h1").textContent = data.name;
            const subtitleParts = ["Stream Category"];
            if (data.metrics?.categoryName) {
                subtitleParts.unshift(data.metrics.categoryName);
            }
            if (data.metrics?.clientName) {
                subtitleParts.push(data.metrics.clientName);
            }
            infoCard.querySelector("h2").textContent = subtitleParts.join(" • ");
            infoCard.querySelector("p").textContent = data.description;

            if (infoMetricsList) {
                infoMetricsList.innerHTML = "";
                if (data.metrics) {
                    appendMetric(
                        infoMetricsList,
                        "Signals",
                        data.metrics.nodesCount != null ? `${data.metrics.nodesCount} active` : "Awaiting telemetry"
                    );
                    const topNodes = Array.isArray(data.metrics.topNodes) ? data.metrics.topNodes : [];
                    topNodes.slice(0, 4).forEach((node) => {
                        appendMetric(infoMetricsList, node.label, node.detail);
                    });
                    if (!topNodes.length) {
                        appendMetric(infoMetricsList, "Insight", "Awaiting telemetry from VL Hub.");
                    }
                } else {
                    appendMetric(infoMetricsList, "Insight", "Awaiting telemetry from VL Hub.");
                }
            }

            infoCard.classList.add("visible");
        }

        let hoveredGalaxy = null;
        let activeGalaxy = null;

        function setGalaxyGlow(name, intensity) {
            const entry = galaxyGroups.get(name);
            if (!entry) return;
            entry.core.material.emissiveIntensity = 1.4 + intensity * 0.8;
            
            // Animate multiple halo layers
            entry.halo.material.opacity = 0.18 + intensity * 0.25;
            if (entry.halo2) {
                entry.halo2.material.opacity = 0.12 + intensity * 0.18;
            }
            if (entry.halo3) {
                entry.halo3.material.opacity = 0.08 + intensity * 0.12;
            }
            
            const baseSize = entry.baseStarSize ?? entry.stars.material.size ?? 6.5;
            entry.stars.material.size = baseSize + intensity * 4.5;
            
            if (entry.swirl?.material) {
                const baseOpacity = entry.swirl.userData?.baseOpacity ?? entry.swirl.material.opacity ?? 0.5;
                entry.swirl.material.opacity = baseOpacity + intensity * 0.3;
                entry.swirl.material.needsUpdate = true;
            }
            if (entry.sparkLayer?.material) {
                entry.sparkLayer.material.opacity = 0.32 + intensity * 0.4;
                entry.sparkLayer.material.needsUpdate = true;
            }
            if (entry.dust?.material) {
                entry.dust.material.opacity = 0.35 + intensity * 0.25;
                entry.dust.material.needsUpdate = true;
            }
            
            // Animate galaxy clouds
            if (entry.cloud1?.material) {
                entry.cloud1.material.opacity = 0.35 + intensity * 0.25;
                entry.cloud1.material.needsUpdate = true;
            }
            if (entry.cloud2?.material) {
                entry.cloud2.material.opacity = 0.22 + intensity * 0.18;
                entry.cloud2.material.needsUpdate = true;
            }
            if (entry.outerCloud?.material) {
                entry.outerCloud.material.opacity = 0.18 + intensity * 0.15;
                entry.outerCloud.material.needsUpdate = true;
            }
            
            if (entry.pointLight) {
                entry.pointLight.intensity = 2.2 + intensity * 1.8;
                entry.pointLight.distance = 600 + intensity * 100;
            }
            if (entry.rimLight) {
                entry.rimLight.intensity = 0.8 + intensity * 0.6;
                entry.rimLight.distance = 400 + intensity * 80;
            }
        }

        function onPointerMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            if (!rect.width || !rect.height) {
                return;
            }
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -(((event.clientY - rect.top) / rect.height) * 2 - 1);
        }

        function onClick() {
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(
                Array.from(galaxyGroups.values()).map((entry) => entry.core),
                false
            );

            if (intersects.length > 0) {
                const name = galaxyData.find((g) => galaxyGroups.get(g.name).core === intersects[0].object)?.name;
                if (name) {
                    if (activeGalaxy && activeGalaxy !== name) {
                        setGalaxyGlow(activeGalaxy, 0);
                    }
                    activeGalaxy = name;
                    setGalaxyGlow(name, 1);
                    updateInfoCard(galaxyData.find((g) => g.name === name));
                    highlightConnections(name);
                }
            } else if (activeGalaxy) {
                setGalaxyGlow(activeGalaxy, 0);
                activeGalaxy = null;
                updateInfoCard(null);
                highlightConnections(null);
            }
        }

        function highlightConnections(name) {
            connectionLines.children.forEach((child) => {
                const material = child.material;
                if (material?.uniforms) {
                    material.uniforms.uColor.value.copy(child.userData.baseColor ?? connectionBaseColor);
                    material.uniforms.uHighlight.value = 0;
                    child.userData.targetOpacity = child.userData.baseOpacity ?? material.uniforms.uOpacity.value;
                }
            });

            galaxyData.forEach((data) => {
                const entry = galaxyGroups.get(data.name);
                if (!entry) return;
                entry.label.classList.remove("active");
                if (data.name !== activeGalaxy && data.name !== hoveredGalaxy) {
                    setGalaxyGlow(data.name, 0);
                }
            });

            if (!name) {
                return;
            }

            const sourceData = galaxyData.find((g) => g.name === name);
            if (!sourceData) return;

            const related = new Set([name, ...sourceData.connections]);
            connectionLines.children.forEach((child) => {
                const { start, end } = child.userData;
                if (related.has(start) && related.has(end)) {
                    const highlightEntry = galaxyGroups.get(name);
                    if (highlightEntry && child.material?.uniforms) {
                        child.material.uniforms.uColor.value.copy(highlightEntry.core.material.color);
                        child.material.uniforms.uHighlight.value = 1;
                        const baseOpacity = child.userData.baseOpacity ?? 0.34;
                        child.userData.targetOpacity = Math.min(1, baseOpacity + 0.55);
                    }
                }
            });

            related.forEach((labelName) => {
                const entry = galaxyGroups.get(labelName);
                if (!entry) return;
                entry.label.classList.add("active");
                if (labelName !== name && labelName !== hoveredGalaxy) {
                    setGalaxyGlow(labelName, 0.35);
                }
            });
        }

        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("click", onClick);

        const clusterMovePercent = 0.05;
        const zoomStepPercent = 0.1;
        let customAnimationActive = false;
        let customAnimationPaused = false;
        let customAnimationPhase = 0;

        const leftControl = document.getElementById("controlLeft");
        const rightControl = document.getElementById("controlRight");
        const zoomInControl = document.getElementById("controlZoomIn");
        const zoomOutControl = document.getElementById("controlZoomOut");
        const animateControl = document.getElementById("controlAnimate");

        function panCluster(direction) {
            camera.getWorldDirection(cameraDirection);
            panRight.crossVectors(cameraDirection, camera.up);
            if (panRight.lengthSq() === 0) {
                return;
            }

            const distance = camera.position.distanceTo(controls.target);
            const delta = distance * clusterMovePercent * direction;
            panRight.normalize().multiplyScalar(delta);

            camera.position.add(panRight);
            controls.target.add(panRight);
            controls.update();
            updateLabels();
        }

        function zoomCluster(amount) {
            zoomOffset.subVectors(camera.position, controls.target);
            const currentDistance = zoomOffset.length();
            if (currentDistance === 0) {
                zoomOffset.set(0, 0, 1);
            }

            const targetDistance = THREE.MathUtils.clamp(
                zoomOffset.length() * (1 + amount),
                controls.minDistance,
                controls.maxDistance
            );

            zoomOffset.setLength(targetDistance);
            camera.position.copy(controls.target).add(zoomOffset);
            controls.update();
            updateLabels();
        }

        leftControl?.addEventListener("click", () => {
            panCluster(-1);
        });

        rightControl?.addEventListener("click", () => {
            panCluster(1);
        });

        zoomInControl?.addEventListener("click", () => {
            zoomCluster(-zoomStepPercent);
        });

        zoomOutControl?.addEventListener("click", () => {
            zoomCluster(zoomStepPercent);
        });

        function toggleCustomAnimation() {
            customAnimationActive = !customAnimationActive;
            if (!customAnimationActive) {
                customAnimationPhase = 0;
                customAnimationPaused = false;
                animateControl?.classList.remove("paused");
            }
            if (animateControl) {
                animateControl.classList.toggle("active", customAnimationActive);
                animateControl.setAttribute("aria-pressed", String(customAnimationActive));
                const label = animateControl.querySelector(".label");
                if (label) {
                    label.textContent = customAnimationActive ? "Animating" : "Animate";
                }
            }
        }

        animateControl?.addEventListener("click", () => {
            toggleCustomAnimation();
        });

        animateControl?.addEventListener("mouseenter", () => {
            if (!customAnimationActive) return;
            customAnimationPaused = true;
            animateControl.classList.add("paused");
        });

        animateControl?.addEventListener("mouseleave", () => {
            if (!customAnimationActive) return;
            customAnimationPaused = false;
            animateControl.classList.remove("paused");
        });

        function updateLabels() {
            const rect = renderer.domElement.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            if (!width || !height) {
                return;
            }

            galaxyData.forEach((data) => {
                const entry = galaxyGroups.get(data.name);
                if (!entry) return;
                entry.group.getWorldPosition(tempWorldPosition);
                projectedPosition.copy(tempWorldPosition).project(camera);
                const x = (projectedPosition.x * 0.5 + 0.5) * width;
                const y = (-projectedPosition.y * 0.5 + 0.5) * height;
                const isVisible = projectedPosition.z > -1 && projectedPosition.z < 1;
                entry.label.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                entry.label.style.opacity = isVisible
                    ? entry.label.classList.contains("active")
                        ? 1
                        : 0.7
                    : 0;
            });
        }

        let previousTime = 0;

        function animate(time) {
                if (!isOmniscientPage && !isLunaComposePage && renderer && scene && camera && controls) {
            requestAnimationFrame(animate);
            controls.update();

            const deltaMs = time - (previousTime || time);
            previousTime = time;
            const deltaSeconds = deltaMs > 0 ? deltaMs * 0.001 : 0;

            const t = time * 0.00012;

            if (customAnimationActive) {
                if (!customAnimationPaused) {
                    customAnimationPhase += 0.0045;
                }
                const swingX = Math.sin(customAnimationPhase * 0.55) * 0.18;
                const swingZ = Math.cos(customAnimationPhase * 0.45) * 0.14;
                const lift = Math.sin(customAnimationPhase) * 18;
                superclusterGroup.rotation.x = swingX;
                superclusterGroup.rotation.z = swingZ;
                superclusterGroup.position.y = lift;
            }

            const idleTilt = Math.sin(time * 0.00018) * 0.06;
            const idleLift = Math.sin(time * 0.00012) * 8;
            if (!customAnimationActive) {
                superclusterGroup.rotation.x = THREE.MathUtils.lerp(superclusterGroup.rotation.x, idleTilt, 0.04);
                superclusterGroup.rotation.z = THREE.MathUtils.lerp(superclusterGroup.rotation.z, idleTilt * 0.45, 0.04);
                superclusterGroup.position.y = THREE.MathUtils.lerp(superclusterGroup.position.y, idleLift, 0.06);
            }

            superclusterGroup.rotation.y += 0.00006 + (customAnimationActive && !customAnimationPaused ? 0.00005 : 0.00002);
            atmosphereShell.rotation.y += 0.00001;

            starField.rotation.y += 0.00005;
            starField.rotation.x = Math.sin(time * 0.00006) * 0.05;
            farStarField.rotation.y += 0.000015;
            farStarField.rotation.x = Math.sin(time * 0.00003) * 0.03;

            nebulaClouds.forEach((cloud, idx) => {
                const data = cloud.userData || {};
                const phase = time * 0.00008 + (data.phaseOffset || 0) + idx * 0.1;
                const basePosition = data.basePosition || cloud.position;
                const drift = data.drift || { x: 0, y: 0, z: 0 };
                const driftX = drift.x || 0;
                const driftY = drift.y || 0;
                const driftZ = drift.z || 0;
                cloud.position.x = basePosition.x + Math.sin(phase) * driftX;
                cloud.position.y = basePosition.y + Math.cos(phase * 0.8) * driftY;
                cloud.position.z = basePosition.z + Math.sin(phase * 1.2) * driftZ;
                cloud.rotation.z += data.rotationSpeed || 0.00008;
                const osc = Math.sin(phase * 1.6);
                const flicker = 0.55 + 0.45 * osc * osc;
                if (cloud.material) {
                    cloud.material.opacity = (data.baseOpacity || cloud.material.opacity) * flicker;
                }
            });

            galaxyData.forEach((data, idx) => {
                const entry = galaxyGroups.get(data.name);
                if (!entry) return;
                entry.stars.rotation.y += 0.00028 + idx * 0.00002;
                entry.stars.rotation.x += 0.00012;
                if (customAnimationActive && !customAnimationPaused) {
                    entry.stars.rotation.z += 0.00025;
                }
                if (entry.swirl) {
                    const swirlData = entry.swirl.userData || {};
                    entry.swirl.rotation.z += (swirlData.spinSpeed || 0.00024) + (customAnimationActive && !customAnimationPaused ? 0.00022 : 0);
                    entry.swirl.rotation.x += Math.sin(time * 0.00022 + idx) * (swirlData.wobbleStrength || 0.08) * 0.0025;
                }
                if (entry.sparkLayer) {
                    const spinSpeed = entry.sparkLayer.userData?.spinSpeed || 0.00032;
                    entry.sparkLayer.rotation.z += spinSpeed;
                }
                // Animate galaxy clouds
                if (entry.cloud1) {
                    entry.cloud1.rotation.z += 0.00008;
                    entry.cloud1.rotation.x = Math.PI / 2 + Math.sin(time * 0.00022 + idx) * 0.06;
                }
                if (entry.cloud2) {
                    entry.cloud2.rotation.z -= 0.00006;
                    entry.cloud2.rotation.x = Math.PI / 2.1 + Math.sin(time * 0.00018 + idx) * 0.08;
                }
                if (entry.outerCloud) {
                    entry.outerCloud.rotation.z -= 0.00008;
                    entry.outerCloud.rotation.x = Math.PI / 2.15 + Math.sin(time * 0.00018 + idx) * 0.12;
                }
                
                // Animate dust particles
                if (entry.dust) {
                    const dustSpeed = entry.dust.userData?.spinSpeed || 0.00008;
                    entry.dust.rotation.z += dustSpeed;
                    entry.dust.rotation.y += dustSpeed * 0.5;
                }
                const pulseScale = customAnimationActive
                    ? 1 + Math.sin(customAnimationPhase * 1.4 + idx) * 0.08
                    : 1;
                entry.core.scale.setScalar(pulseScale);
                const haloPulse = customAnimationActive
                    ? Math.sin(customAnimationPhase + idx) * 0.08
                    : 0;
                entry.halo.scale.setScalar(1.22 + Math.sin(t + idx) * 0.02 + haloPulse);
                if (entry.halo2) {
                    entry.halo2.scale.setScalar(1.15 + Math.sin(t + idx * 0.8) * 0.015 + haloPulse * 0.8);
                }
                if (entry.halo3) {
                    entry.halo3.scale.setScalar(1.12 + Math.sin(t + idx * 0.6) * 0.01 + haloPulse * 0.6);
                }
            });

            connectionFlowEntries.forEach((mesh) => {
                const material = mesh.material;
                if (!material?.uniforms) {
                    return;
                }
                const speed = mesh.userData?.flowSpeed || 0.12;
                material.uniforms.uTime.value = (material.uniforms.uTime.value + deltaSeconds * speed) % 1;
                const targetOpacity = mesh.userData?.targetOpacity ?? mesh.userData?.baseOpacity ?? material.uniforms.uOpacity.value;
                material.uniforms.uOpacity.value = THREE.MathUtils.lerp(
                    material.uniforms.uOpacity.value,
                    targetOpacity,
                    0.08
                );
            });

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(
                Array.from(galaxyGroups.values()).map((entry) => entry.core),
                false
            );

            if (intersects.length > 0) {
                const name = galaxyData.find((g) => galaxyGroups.get(g.name).core === intersects[0].object)?.name;
                if (name && name !== hoveredGalaxy) {
                    if (hoveredGalaxy && hoveredGalaxy !== activeGalaxy) {
                        setGalaxyGlow(hoveredGalaxy, 0);
                    }
                    hoveredGalaxy = name;
                    if (name !== activeGalaxy) {
                        setGalaxyGlow(name, 0.6);
                    }
                }
            } else if (hoveredGalaxy && hoveredGalaxy !== activeGalaxy) {
                const previous = hoveredGalaxy;
                setGalaxyGlow(previous, 0);
                hoveredGalaxy = null;
                if (activeGalaxy) {
                    highlightConnections(activeGalaxy);
                }
            }

            updateLabels();
            renderer.render(scene, camera);
                }
        }

        // Initialize the application
        updateInfoCard(null);
        
        // Add debugging for Three.js initialization
        console.log('Starting Supercluster initialization...');
        console.log('Root container:', rootContainer);
        console.log('License key from URL:', licenseKey);

            if (!isOmniscientPage && !isLunaComposePage) {
        animate(0);
            }

        window.addEventListener("resize", () => {
                if (!isOmniscientPage && !isLunaComposePage && camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
                    if (typeof updateLabels === 'function') {
            updateLabels();
                    }
                }
        });
        }

        setTimeout(() => {
            const infoCard = document.getElementById('infoCard');
            if (infoCard) {
                infoCard.classList.add("visible");
            }
        }, 600);

        // ============================================================
        // Luna Chat Widget Integration
        // ============================================================
        async function checkAndLoadLunaWidget() {
            console.log('[Luna Widget] Starting widget load check...');
            const container = document.getElementById('vlLunaChatContainer');
            if (!container) {
                console.error('[Luna Widget] Container not found: vlLunaChatContainer');
                return;
            }
            console.log('[Luna Widget] Container found:', container);

            try {
                // Get license key from URL or page
                let licenseKey = new URLSearchParams(window.location.search).get('license') || 
                                  document.getElementById('licenseKeyDisplay')?.textContent?.trim();
                
                // Extract just the license key (before first /) if URL contains path segments
                if (licenseKey) {
                    const licenseMatch = licenseKey.match(/^([^/]+)/);
                    if (licenseMatch) {
                        licenseKey = licenseMatch[1];
                    }
                }
                
                console.log('[Luna Widget] License key:', licenseKey);
                
                if (!licenseKey) {
                    console.warn('[Luna Widget] No license key found, skipping widget load');
                    return;
                }

                // Validate license key by checking all-connections endpoint
                console.log('[Luna Widget] Validating license key...');
                const validationUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`;
                const validationResponse = await fetch(validationUrl, {
                    method: 'GET',
                    credentials: 'include',
                    mode: 'cors'
                });
                
                if (!validationResponse.ok) {
                    console.warn('[Luna Widget] License key validation failed:', validationResponse.status);
                    return;
                }
                
                const validationData = await validationResponse.json();
                if (!validationData || !validationData.ok) {
                    console.warn('[Luna Widget] License key is not valid or active');
                    return;
                }
                
                console.log('[Luna Widget] License key validated successfully');

                // Get client profile data from VL Hub API to get the client site URL
                const profileUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/profile?license=${encodeURIComponent(licenseKey)}`;
                console.log('[Luna Widget] Fetching profile from:', profileUrl);
                
                const profileResponse = await fetch(profileUrl, {
                    method: 'GET',
                    credentials: 'include',
                    mode: 'cors'
                });
                
                console.log('[Luna Widget] Profile response status:', profileResponse.status);
                
                if (!profileResponse.ok) {
                    const errorText = await profileResponse.text();
                    console.error('[Luna Widget] Failed to fetch profile:', profileResponse.status, errorText);
                    return;
                }
                
                const profileData = await profileResponse.json();
                console.log('[Luna Widget] Profile data received:', profileData);
                
                // Check if profile data is valid
                if (!profileData || (!profileData.ok && !profileData.license_key && !profileData.site)) {
                    console.error('[Luna Widget] Invalid profile data:', profileData);
                    return;
                }

                // Get client site URL from profile - check multiple possible locations
                let clientSiteUrl = null;
                if (profileData.data?.site_info?.site) {
                    clientSiteUrl = profileData.data.site_info.site;
                } else if (profileData.site_info?.site) {
                    clientSiteUrl = profileData.site_info.site;
                } else if (profileData.site?.home_url) {
                    clientSiteUrl = profileData.site.home_url;
                } else if (profileData.home_url) {
                    clientSiteUrl = profileData.home_url;
                } else if (profileData.site) {
                    clientSiteUrl = typeof profileData.site === 'string' ? profileData.site : profileData.site.home_url;
                }
                
                console.log('[Luna Widget] Client site URL:', clientSiteUrl);
                
                if (!clientSiteUrl) {
                    console.error('[Luna Widget] No client site URL found in profile');
                    return;
                }

                // Fetch the widget HTML/CSS/JS from the client's WordPress site with vl_key parameter
                const widgetHtmlUrl = `${clientSiteUrl.replace(/\/$/, '')}/wp-json/luna_widget/v1/widget/html?vl_key=${encodeURIComponent(licenseKey)}`;
                
                console.log('[Luna Widget] Fetching widget from:', widgetHtmlUrl);
                
                try {
                    const widgetResponse = await fetch(widgetHtmlUrl, {
                        method: 'GET',
                        credentials: 'include',
                        mode: 'cors'
                    });
                    
                    console.log('[Luna Widget] Widget response status:', widgetResponse.status);
                    
                    if (widgetResponse.ok) {
                        const widgetData = await widgetResponse.json();
                        console.log('[Luna Widget] Widget data received:', widgetData);
                        
                        if (widgetData.ok && widgetData.html) {
                            console.log('[Luna Widget] Injecting widget HTML/CSS/JS...');
                            
                            // Inject CSS first
                            if (widgetData.css) {
                                const style = document.createElement('style');
                                style.id = 'luna-widget-embed-styles';
                                style.textContent = widgetData.css;
                                // Remove existing styles if present
                                const existing = document.getElementById('luna-widget-embed-styles');
                                if (existing) existing.remove();
                                document.head.appendChild(style);
                                console.log('[Luna Widget] CSS injected');
                            }
                            
                            // Inject HTML - position in bottom left corner
                            container.innerHTML = widgetData.html;
                            container.style.position = 'fixed';
                            container.style.bottom = '20px';
                            container.style.left = '20px';
                            container.style.zIndex = '2147483646';
                            console.log('[Luna Widget] HTML injected into container');
                            
                            // Inject JavaScript after a short delay to ensure DOM is ready
                            if (widgetData.js) {
                                setTimeout(function() {
                                    const script = document.createElement('script');
                                    script.id = 'luna-widget-embed-script';
                                    // Remove existing script if present
                                    const existing = document.getElementById('luna-widget-embed-script');
                                    if (existing) existing.remove();
                                    script.textContent = widgetData.js;
                                    document.body.appendChild(script);
                                    console.log('[Luna Widget] Widget loaded successfully');
                                    
                                    // After widget loads, intercept launcher click to show popup
                                    setTimeout(function() {
                                        setupLunaLauncherPopup(licenseKey);
                                    }, 500);
                                }, 100);
                            } else {
                                console.warn('[Luna Widget] Widget HTML loaded, but no JavaScript provided');
                            }
                            return;
                        } else if (widgetData.error) {
                            console.error('[Luna Widget] Widget not available:', widgetData.error);
                            return;
                        } else {
                            console.error('[Luna Widget] Widget data missing ok or html:', widgetData);
                            return;
                        }
                    } else {
                        const errorText = await widgetResponse.text();
                        console.error('[Luna Widget] Failed to fetch widget:', widgetResponse.status, errorText);
                        return;
                    }
                } catch (e) {
                    console.error('[Luna Widget] Could not fetch widget HTML:', e);
                    return;
                }
                
            } catch (error) {
                console.error('[Luna Widget] Error loading widget:', error);
            }
        }

        // Store launcher handler reference for removal
        let lunaLauncherClickHandler = null;
        
        /**
         * Setup Luna Launcher Popup - Intercepts launcher click to show popup with four buttons
         */
        function setupLunaLauncherPopup(licenseKey) {
            console.log('[Luna Widget] Setting up launcher popup...');
            
            // Remove existing handler if any
            if (lunaLauncherClickHandler) {
                document.body.removeEventListener('click', lunaLauncherClickHandler, true);
            }
            
            // Use event delegation on document body to catch launcher clicks
            // This works even if the widget sets up handlers later
            lunaLauncherClickHandler = function(e) {
                const launcher = e.target.closest('.luna-launcher');
                if (launcher && !launcher.dataset.skipPopup) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // Check if there's an active session (panel has messages)
                    const panel = document.getElementById('luna-panel');
                    const thread = panel ? panel.querySelector('.luna-thread') : null;
                    const hasActiveSession = thread && thread.children.length > 0;
                    
                    if (hasActiveSession) {
                        // Active session exists - show panel directly
                        console.log('[Luna Widget] Active session detected, opening panel directly...');
                        const overlay = document.querySelector('.luna-overlay');
                        if (panel) {
                            panel.classList.add('show');
                            panel.style.display = ''; // Remove inline style to let CSS handle it
                            if (overlay) {
                                overlay.classList.add('show');
                                overlay.style.display = ''; // Remove inline style to let CSS handle it
                            }
                            launcher.setAttribute('aria-expanded', 'true');
                        }
                    } else {
                        // No active session - show popup with four buttons
                        console.log('[Luna Widget] No active session, showing popup...');
                        showLunaActionPopup(licenseKey);
                    }
                    return false;
                }
            };
            
            // Add capture phase listener to intercept before widget's handlers
            document.body.addEventListener('click', lunaLauncherClickHandler, true);
            
            console.log('[Luna Widget] Launcher popup handler registered');
        }
        
        /**
         * Show Luna Action Popup with four buttons
         */
        function showLunaActionPopup(licenseKey) {
            console.log('[Luna Widget] Showing action popup...');
            
            // Remove existing popup if any
            const existingPopup = document.getElementById('luna-action-popup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // Create popup overlay
            const popupOverlay = document.createElement('div');
            popupOverlay.id = 'luna-action-popup';
            popupOverlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 2147483647; display: flex; align-items: center; justify-content: center;';
            
            // Create popup container (styled like luna-msg.luna-assistant)
            const popupContainer = document.createElement('div');
            popupContainer.style.cssText = 'background: rgba(0,0,0,.5); border: 1px solid #1f1d1a; border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); position: relative;backdrop-filter:blur(8px);';
            
            // Create message text (like luna-assistant)
            const messageText = document.createElement('div');
            messageText.className = 'luna-msg luna-assistant';
            messageText.style.cssText = 'color: #fff4e9; font-size: 1rem; font-weight: 500;padding-right: 10px; line-height: 1.6; margin-bottom: 16px;';
            messageText.textContent = "Hi, there! I'm Luna, your WebOps AI assistant. How would you like to continue?";
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';
            
            // Chat Button
            const chatButton = document.createElement('button');
            chatButton.className = 'luna-chat-button';
            chatButton.textContent = 'Luna Chat';
            chatButton.style.cssText = 'padding: 10px 16px; background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%); color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
            chatButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                popupOverlay.remove();
                
                // Temporarily disable our launcher handler, then trigger launcher click
                setTimeout(function() {
                    const launcher = document.querySelector('.luna-launcher');
                    if (launcher) {
                        // Mark launcher to skip popup
                        launcher.dataset.skipPopup = 'true';
                        
                        // Create and dispatch click event to trigger widget's native open logic
                        const clickEvent = new MouseEvent('click', {
                            bubbles: true,
                            cancelable: true,
                            view: window
                        });
                        launcher.dispatchEvent(clickEvent);
                        
                        // Remove the skip flag after a short delay
                        setTimeout(function() {
                            delete launcher.dataset.skipPopup;
                        }, 1000);
                        
                        // Wait for panel to open, then focus input
                        setTimeout(function() {
                            const lunaPanel = document.getElementById('luna-panel');
                            const lunaOverlay = document.querySelector('.luna-overlay');
                            if (lunaPanel) {
                                lunaPanel.classList.add('show');
                                lunaPanel.style.display = ''; // Remove inline style to let CSS handle it
                                if (lunaOverlay) {
                                    lunaOverlay.classList.add('show');
                                    lunaOverlay.style.display = ''; // Remove inline style to let CSS handle it
                                }
                            }
                            const lunaInput = document.querySelector('.luna-input');
                            if (lunaInput) {
                                lunaInput.focus();
                            }
                        }, 200);
                    } else {
                        // Fallback: manually show panel if launcher not found
                        const lunaPanel = document.getElementById('luna-panel');
                        const lunaOverlay = document.querySelector('.luna-overlay');
                        if (lunaPanel) {
                            lunaPanel.classList.add('show');
                            lunaPanel.style.display = ''; // Remove inline style to let CSS handle it
                            if (lunaOverlay) {
                                lunaOverlay.classList.add('show');
                                lunaOverlay.style.display = ''; // Remove inline style to let CSS handle it
                            }
                            setTimeout(function() {
                                const lunaInput = document.querySelector('.luna-input');
                                if (lunaInput) {
                                    lunaInput.focus();
                                }
                            }, 100);
                        }
                    }
                }, 50);
            });
            
            // Compose Button
            const composeButton = document.createElement('button');
            composeButton.className = 'luna-compose-button';
            composeButton.textContent = 'Luna Compose';
            composeButton.style.cssText = 'padding: 10px 16px; background: #000; color: #fff4e9; border: 1px solid #1f1d1a; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
            composeButton.addEventListener('click', function() {
                const composeUrl = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}/luna-compose`;
                window.location.href = composeUrl;
            });
            
            // Report Button
            const reportButton = document.createElement('button');
            reportButton.className = 'luna-report-button';
            reportButton.textContent = 'Luna Report';
            reportButton.style.cssText = 'padding: 10px 16px; background: #000; color: #fff4e9; border: 1px solid #1f1d1a; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
            reportButton.addEventListener('click', function() {
                const reportUrl = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}/luna/report`;
                window.location.href = reportUrl;
            });
            
            // Automate Button
            const automateButton = document.createElement('button');
            automateButton.className = 'luna-automate-button';
            automateButton.textContent = 'Luna Automate';
            automateButton.style.cssText = 'padding: 10px 16px; background: #000; color: #fff4e9; border: 1px solid #1f1d1a; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
            automateButton.addEventListener('click', function() {
                const automateUrl = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}/luna/automate`;
                window.location.href = automateUrl;
            });
            
            // Close button (X)
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '×';
            closeButton.style.cssText = 'position: absolute; top: 8px; right: 8px; background: transparent; border: none; color: #fff4e9; font-size: 24px; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; line-height: 1;';
            closeButton.addEventListener('click', function() {
                popupOverlay.remove();
            });
            
            // Assemble popup
            buttonContainer.appendChild(chatButton);
            buttonContainer.appendChild(composeButton);
            buttonContainer.appendChild(reportButton);
            buttonContainer.appendChild(automateButton);
            popupContainer.appendChild(messageText);
            popupContainer.appendChild(buttonContainer);
            popupContainer.appendChild(closeButton);
            popupOverlay.appendChild(popupContainer);
            
            // Close on overlay click
            popupOverlay.addEventListener('click', function(e) {
                if (e.target === popupOverlay) {
                    popupOverlay.remove();
                }
            });
            
            // Add to page
            document.body.appendChild(popupOverlay);
        }

        // Function to modify Luna greeting message and add buttons
        // NOTE: This is now handled natively in the Luna Widget plugin
        // Keeping this as a fallback for backwards compatibility, but it should not be needed
        function modifyLunaGreeting(licenseKey) {
            console.log('[Luna Widget] Modifying greeting message...');
            
            // Helper function to add buttons to a message element
            function addButtonsToMessage(messageElement) {
                // Check if buttons already added
                if (messageElement.querySelector('.luna-chat-button')) {
                    console.log('[Luna Widget] Buttons already added to this message');
                    return;
                }
                
                // Find the parent message bubble or container
                let container = messageElement;
                // Try to find a parent that looks like a message bubble
                while (container && container.parentElement) {
                    if (container.classList.contains('luna-message') || 
                        container.classList.contains('message') ||
                        container.querySelector('.luna-message')) {
                        break;
                    }
                    container = container.parentElement;
                }
                
                // If we couldn't find a specific container, use the element itself
                if (!container || container === document.body) {
                    container = messageElement;
                }
                
                // Found the greeting, add buttons
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = 'margin-top: 12px; display: flex; gap: 8px; flex-direction: column;';
                
                const chatButton = document.createElement('button');
                chatButton.className = 'luna-chat-button';
                chatButton.textContent = 'Luna Chat';
                chatButton.style.cssText = 'padding: 10px 16px; background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%); color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
                chatButton.addEventListener('click', function() {
                    const lunaInput = document.querySelector('.luna-input');
                    if (lunaInput) {
                        lunaInput.focus();
                    }
                });
                
                const composeButton = document.createElement('button');
                composeButton.className = 'luna-compose-button';
                composeButton.textContent = 'Luna Compose';
                composeButton.style.cssText = 'padding: 10px 16px; background: #000; color: #fff4e9; border: 1px solid #1f1d1a; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
                composeButton.addEventListener('click', function() {
                    const composeUrl = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}/luna-compose`;
                    window.location.href = composeUrl;
                });
                
                buttonContainer.appendChild(chatButton);
                buttonContainer.appendChild(composeButton);
                container.appendChild(buttonContainer);
                
                console.log('[Luna Widget] Buttons added to greeting message');
                return true;
            }
            
            // Try to find existing greeting message first
            function checkForExistingGreeting() {
                const lunaThread = document.querySelector('.luna-thread') || document.querySelector('.luna-panel') || document.querySelector('[class*="luna"]');
                if (!lunaThread) {
                    return false;
                }
                
                // Look for any message containing the greeting text
                const allMessages = lunaThread.querySelectorAll('*');
                for (let i = 0; i < allMessages.length; i++) {
                    const element = allMessages[i];
                    const text = element.textContent || element.innerText || '';
                    if ((text.includes("Hi, there! I'm Luna") || 
                         text.includes("I'm Luna") ||
                         text.includes("How would you like to continue")) &&
                        !element.querySelector('.luna-chat-button')) {
                        if (addButtonsToMessage(element)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Check for existing greeting immediately
            if (checkForExistingGreeting()) {
                console.log('[Luna Widget] Found existing greeting and added buttons');
                return;
            }
            
            // Find the Luna thread/panel where messages appear
            const lunaThread = document.querySelector('.luna-thread') || 
                              document.querySelector('.luna-panel') || 
                              document.querySelector('[class*="luna"]');
            
            if (!lunaThread) {
                console.warn('[Luna Widget] Luna thread not found, retrying...');
                setTimeout(function() {
                    modifyLunaGreeting(licenseKey);
                }, 1000);
                return;
            }
            
            // Use MutationObserver to watch for greeting message - don't interfere with loading
            // This passively waits for the greeting to appear without blocking it
            console.log('[Luna Widget] Setting up observer for greeting message...');
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === 1) { // Element node
                            const text = node.textContent || node.innerText || '';
                            // Check for various forms of the greeting
                            if (text.includes("Hi, there! I'm Luna") || 
                                text.includes("I'm Luna") ||
                                text.includes("How would you like to continue") ||
                                (text.includes("Luna") && text.includes("WebOps"))) {
                                if (addButtonsToMessage(node)) {
                                    observer.disconnect();
                                }
                            }
                        }
                    });
                });
            });
                
            observer.observe(lunaThread, { childList: true, subtree: true });
            
            // Also check periodically in case observer misses it
            let checkCount = 0;
            const checkInterval = setInterval(function() {
                checkCount++;
                if (checkForExistingGreeting()) {
                    observer.disconnect();
                    clearInterval(checkInterval);
                } else if (checkCount >= 20) { // Stop after 20 seconds
                    observer.disconnect();
                    clearInterval(checkInterval);
                    console.warn('[Luna Widget] Greeting message not found after 20 seconds');
                }
            }, 1000);
            
            // Disconnect observer after 20 seconds to avoid memory leaks
            setTimeout(function() {
                observer.disconnect();
                clearInterval(checkInterval);
            }, 20000);
        }

            // Load widget after page initialization - try multiple times to ensure DOM is ready
            console.log('[Luna Widget] Scheduling widget load...');
            setTimeout(checkAndLoadLunaWidget, 1000);
            setTimeout(checkAndLoadLunaWidget, 2000);
            setTimeout(checkAndLoadLunaWidget, 3000);

            // Widget hide/show toggle functionality
            function initWidgetToggle() {
            const toggleButtons = document.querySelectorAll('.vl-widget-toggle');
            
            toggleButtons.forEach(function(button) {
                // Skip if already initialized
                if (button.dataset.initialized === 'true') return;
                button.dataset.initialized = 'true';
                
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const widgetId = button.getAttribute('data-widget');
                    const widget = document.getElementById(widgetId);
                    if (!widget) return;
                    
                    const widgetBody = widget.querySelector('.vl-widget-body');
                    if (!widgetBody) return;
                    
                    const isHidden = widgetBody.classList.contains('vl-widget-body-hidden');
                    
                    // Get or create the icon element
                    let icon = button.querySelector('.vl-toggle-icon');
                    if (!icon) {
                        icon = document.createElement('img');
                        icon.className = 'vl-toggle-icon';
                        button.appendChild(icon);
                    }
                    
                    if (isHidden) {
                        // Show the widget body
                        widgetBody.classList.remove('vl-widget-body-hidden');
                        icon.src = 'https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg';
                        icon.alt = 'Hide';
                        button.setAttribute('aria-label', 'Hide widget');
                    } else {
                        // Hide the widget body
                        widgetBody.classList.add('vl-widget-body-hidden');
                        icon.src = 'https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-icon.svg';
                        icon.alt = 'Show';
                        button.setAttribute('aria-label', 'Show widget');
                    }
                });
            });
        }
        
        // Initialize on DOM ready or immediately if already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initWidgetToggle);
        } else {
            initWidgetToggle();
        }
        // ============================================================
        // Luna Composer Functions
        // ============================================================
        
        // Use a canned prompt - send to Luna and populate editor
        // Make it globally accessible
        // Scroll function for canned prompts list
        window.scrollCannedPrompts = function(button, direction) {
            const wrapper = button.closest('.canned-prompts-wrapper');
            if (!wrapper) return;
            
            const list = wrapper.querySelector('.canned-prompts-list');
            if (!list) return;
            
            // Scroll amount (adjust as needed)
            const scrollAmount = 400;
            const currentScroll = list.scrollLeft;
            const newScroll = currentScroll + (scrollAmount * direction);
            
            list.scrollTo({
                left: newScroll,
                behavior: 'smooth'
            });
            
            // Update arrow visibility after a short delay to allow scroll to complete
            setTimeout(() => {
                updateCannedPromptsArrows(list, wrapper);
            }, 100);
        };
        
        // Update arrow visibility based on scroll position
        function updateCannedPromptsArrows(list, wrapper) {
            if (!list || !wrapper) return;
            
            const leftBtn = wrapper.querySelector('.canned-prompts-scroll-left');
            const rightBtn = wrapper.querySelector('.canned-prompts-scroll-right');
            
            if (!leftBtn || !rightBtn) return;
            
            const scrollLeft = list.scrollLeft;
            const scrollWidth = list.scrollWidth;
            const clientWidth = list.clientWidth;
            const maxScroll = scrollWidth - clientWidth;
            
            // Show/hide left arrow
            if (scrollLeft > 0) {
                leftBtn.style.display = 'block';
            } else {
                leftBtn.style.display = 'none';
            }
            
            // Show/hide right arrow
            if (scrollLeft < maxScroll - 1) { // -1 for rounding issues
                rightBtn.style.display = 'block';
            } else {
                rightBtn.style.display = 'none';
            }
        }
        
        // Initialize scroll arrows when Luna Composer is rendered
        function initializeCannedPromptsScroll() {
            const list = document.querySelector('.canned-prompts-list');
            if (!list) return;
            
            const wrapper = list.closest('.canned-prompts-wrapper');
            if (!wrapper) return;
            
            // Initial check
            updateCannedPromptsArrows(list, wrapper);
            
            // Update on scroll
            list.addEventListener('scroll', () => {
                updateCannedPromptsArrows(list, wrapper);
            });
            
            // Update on resize
            window.addEventListener('resize', () => {
                updateCannedPromptsArrows(list, wrapper);
            });
        }
        
        // Toggle between Canned Prompts and Intelligent Suggestions modes
        window.lunaComposerToggleMode = function() {
            const toggle = document.getElementById('luna-composer-mode-toggle');
            const title = document.getElementById('luna-composer-section-title');
            const cannedSection = document.getElementById('luna-composer-canned-section');
            const reimagineWrapper = document.getElementById('luna-composer-reimagine-wrapper');
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            const cannedBtn = document.getElementById('luna-composer-mode-canned');
            const intelligentBtn = document.getElementById('luna-composer-mode-intelligent');
            
            if (!toggle || !title || !cannedSection || !reimagineWrapper || !reimagineBtn || !cannedBtn || !intelligentBtn) {
                console.error('[Luna Composer] Toggle elements not found');
                return;
            }
            
            const currentMode = toggle.getAttribute('data-mode');
            const newMode = currentMode === 'canned' ? 'intelligent' : 'canned';
            
            toggle.setAttribute('data-mode', newMode);
            
            if (newMode === 'intelligent') {
                // Switch to Intelligent Suggestions
                title.textContent = 'Intelligent Suggestions';
                cannedSection.style.display = 'none';
                reimagineWrapper.style.display = 'flex';
                
                // Update toggle button styles
                cannedBtn.style.background = 'transparent';
                cannedBtn.style.color = '#9A9793';
                intelligentBtn.style.background = '#2E2C2A';
                intelligentBtn.style.color = '#fff4e9';
                
                updateReimagineButtonState();
            } else {
                // Switch to Canned Prompts
                title.textContent = 'Essential Commands';
                cannedSection.style.display = 'block';
                reimagineWrapper.style.display = 'none';
                
                // Update toggle button styles
                cannedBtn.style.background = '#2E2C2A';
                cannedBtn.style.color = '#fff4e9';
                intelligentBtn.style.background = 'transparent';
                intelligentBtn.style.color = '#9A9793';

                if (window.lunaComposerReimagineState) {
                    window.lunaComposerReimagineState.currentMode = null;
                    window.lunaComposerReimagineState.highlightRange = null;
                }
                resetReimagineButton();
                hideReimagineMenu();
                hideHighlightTooltip();
            }
        };

        function resetReimagineButton() {
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            if (!reimagineBtn) return;

            reimagineBtn.style.pointerEvents = 'none';
            reimagineBtn.style.cursor = 'not-allowed';
            reimagineBtn.style.color = '#9A9793';
            reimagineBtn.style.background = '#2E2C2A50';
            reimagineBtn.disabled = true;

            const span = reimagineBtn.querySelector('span');
            if (span) {
                span.textContent = 'Reimagine with Luna';
            }

            reimagineBtn.removeAttribute('data-active-mode');
        }

        function updateReimagineButtonState() {
            const toggle = document.getElementById('luna-composer-mode-toggle');
            const editor = document.getElementById('luna-composer-editor');
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');

            if (!toggle || !editor || !reimagineBtn) {
                return;
            }

            const mode = toggle.getAttribute('data-mode');
            const text = editor.innerText || editor.textContent || '';
            const hasContent = text.trim().length > 0;
            
            if (mode === 'intelligent' && hasContent) {
                reimagineBtn.style.pointerEvents = 'auto';
                reimagineBtn.style.cursor = 'pointer';
                reimagineBtn.style.color = '#fff4e9';
                reimagineBtn.style.background = '#2E2C2A';
                reimagineBtn.disabled = false;
            } else {
                resetReimagineButton();
                hideReimagineMenu();
                if (window.lunaComposerReimagineState) {
                    window.lunaComposerReimagineState.currentMode = null;
                    window.lunaComposerReimagineState.highlightRange = null;
                }
                hideHighlightTooltip();
            }
        }

        function ensureReimagineState() {
            if (!window.lunaComposerReimagineState) {
                window.lunaComposerReimagineState = {
                    currentMode: null,
                    highlightRange: null
                };
            }
            return window.lunaComposerReimagineState;
        }

        function hideReimagineMenu() {
            const menu = document.getElementById('luna-composer-reimagine-menu');
            if (menu) {
                menu.style.display = 'none';
            }
        }

        function hideHighlightTooltip() {
            const tooltip = document.getElementById('luna-composer-highlight-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }

            const state = ensureReimagineState();
            state.highlightRange = null;
        }

        window.lunaComposerToggleReimagineMenu = function(event) {
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            const menu = document.getElementById('luna-composer-reimagine-menu');

            if (!reimagineBtn || !menu || reimagineBtn.disabled) {
                return;
            }

            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }

            const isOpen = menu.style.display === 'block';
            hideReimagineMenu();

            if (!isOpen) {
                menu.style.display = 'block';
            }
        };

        window.lunaComposerSelectReimagineMode = function(mode) {
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            const editor = document.getElementById('luna-composer-editor');
            const state = ensureReimagineState();

            hideReimagineMenu();

            if (!reimagineBtn || !editor) {
                return;
            }

            const span = reimagineBtn.querySelector('span');

            if (mode === 'highlight') {
                if (state.currentMode === 'highlight') {
                    state.currentMode = null;
                    reimagineBtn.removeAttribute('data-active-mode');
                    if (span) {
                        span.textContent = 'Reimagine with Luna';
                    }
                    hideHighlightTooltip();
                } else {
                    state.currentMode = 'highlight';
                    reimagineBtn.setAttribute('data-active-mode', 'highlight');
                    if (span) {
                        span.textContent = 'Highlight to Reimagine';
                    }
                    handleHighlightSelection();
                }
                return;
            }

            state.currentMode = null;
            reimagineBtn.removeAttribute('data-active-mode');
            if (span) {
                span.textContent = 'Reimagine with Luna';
            }

            hideHighlightTooltip();

            if (mode === 'branding' || mode === 'linguistics') {
                reimagineFullDocument(mode);
            }
        };

        function handleHighlightSelection() {
            const state = ensureReimagineState();
            if (state.currentMode !== 'highlight') {
                hideHighlightTooltip();
                return;
            }

            const editor = document.getElementById('luna-composer-editor');
            const tooltip = document.getElementById('luna-composer-highlight-tooltip');
            if (!editor || !tooltip) {
                return;
            }

            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                hideHighlightTooltip();
                return;
            }

            const range = selection.getRangeAt(0);
            if (!editor.contains(range.commonAncestorContainer)) {
                hideHighlightTooltip();
                return;
            }

            const selectedText = selection.toString();
            if (!selectedText || !selectedText.trim()) {
                hideHighlightTooltip();
                return;
            }

            const rect = range.getBoundingClientRect();
            tooltip.style.display = 'flex';
            tooltip.style.top = Math.max(16, rect.top - 12) + 'px';
            tooltip.style.left = rect.left + rect.width / 2 + 'px';
            tooltip.style.transform = 'translate(-50%, -100%)';

            state.highlightRange = range.cloneRange();
        }

        window.lunaComposerReimagineHighlightedText = async function() {
            const state = ensureReimagineState();
            const range = state.highlightRange;
            const tooltip = document.getElementById('luna-composer-highlight-tooltip');
            const actionBtn = document.getElementById('luna-composer-highlight-action');

            if (!range || !actionBtn) {
                hideHighlightTooltip();
                return;
            }

            const selectedText = range.toString();
            if (!selectedText || !selectedText.trim()) {
                hideHighlightTooltip();
                return;
            }

            const originalLabel = actionBtn.textContent;
            actionBtn.disabled = true;
            actionBtn.textContent = 'Reimagining...';

            try {
                const answer = await requestLunaReimagine('highlight', selectedText.trim());
                if (answer) {
                    replaceRangeWithContent(range, answer);
                    updateReimagineButtonState();
                    setTimeout(() => {
                        window.lunaComposerUpdateHeartState();
                    }, 100);
                }
            } catch (error) {
                console.error('[Luna Composer] Highlight reimagine failed:', error);
                alert('Failed to reimagine the highlighted text. Please try again.');
            } finally {
                actionBtn.disabled = false;
                actionBtn.textContent = originalLabel;
                hideHighlightTooltip();
            }
        };

        async function reimagineFullDocument(mode) {
            const editor = document.getElementById('luna-composer-editor');
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            if (!editor || !reimagineBtn) {
                return;
            }

            const text = editor.innerText || editor.textContent || '';
            if (!text.trim()) {
                alert('Please enter some text to reimagine.');
                return;
            }
            
            const span = reimagineBtn.querySelector('span');
            const originalLabel = span ? span.textContent : '';

            reimagineBtn.disabled = true;
            reimagineBtn.style.pointerEvents = 'none';
            reimagineBtn.style.cursor = 'wait';
            if (span) {
                span.textContent = 'Reimagining...';
            }

            const originalHtml = editor.innerHTML;
            editor.innerHTML = '<div class="luna-composer-loading-text" style="display: flex; align-items: center; justify-content: center; padding: 40px; text-align: center;"><div class="luna-composer-loading-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" stroke-dasharray="31.416" stroke-dashoffset="31.416" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="2s" values="0 31.416;15.708 15.708;0 31.416;0 31.416" repeatCount="indefinite"/><animate attributeName="stroke-dashoffset" dur="2s" values="0;-15.708;-31.416;-31.416" repeatCount="indefinite"/></circle></svg></div><span class="luna-composer-loading-text">Luna is considering all possibilities...</span></div>';

            try {
                const answer = await requestLunaReimagine(mode, text.trim());
                if (answer) {
                    editor.innerHTML = formatComposerAnswer(answer);
                    editor.scrollTop = 0;
                    editor.dispatchEvent(new Event('input', { bubbles: true }));
                    setTimeout(() => {
                        window.lunaComposerUpdateHeartState();
                    }, 100);
                    } else {
                    throw new Error('No response from Luna');
                }
            } catch (error) {
                console.error('[Luna Composer] Error reimagining document:', error);
                alert('Failed to reimagine content. Please try again.');
                editor.innerHTML = originalHtml;
            } finally {
                if (span) {
                    span.textContent = 'Reimagine with Luna';
                }
                reimagineBtn.disabled = false;
                reimagineBtn.style.pointerEvents = 'auto';
                reimagineBtn.style.cursor = 'pointer';
                reimagineBtn.style.background = '#2E2C2A';
                reimagineBtn.style.color = '#fff4e9';
                updateReimagineButtonState();
            }
        }

        async function requestLunaReimagine(mode, text) {
            const licenseKey = extractLicenseKey();
                if (!licenseKey) {
                    throw new Error('License key not found');
                }
                
            let message;
            if (mode === 'highlight') {
                message = 'Please refine and enhance the following highlighted selection using Luna\'s GPT-4o and VL Hub insights. Preserve the intent and context while improving clarity and impact.\n\n' + text;
            } else if (mode === 'branding') {
                message = 'Please rewrite the following content with a compelling brand voice that aligns with the client\'s business, leveraging VL Hub data and historical insights. Maintain key information while elevating tone and resonance.\n\n' + text;
            } else if (mode === 'linguistics') {
                message = 'Please revise the following content for grammar, linguistics, and readability using Luna\'s advanced checks while keeping the original message intact.\n\n' + text;
            } else {
                message = text;
            }

                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                    message: message,
                        license: licenseKey,
                        context: 'composer'
                    })
                });
                
                if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
                }
                
                const data = await response.json();
            if (!data || !data.answer) {
                throw new Error('No response from Luna');
            }

            return data.answer;
        }

        function extractLicenseKey() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlLicense = urlParams.get('license') || '';
            if (!urlLicense) {
                return '';
            }

            const match = urlLicense.match(/^([^/]+)/);
            if (match) {
                return match[1];
            }

            return urlLicense;
        }

        function formatComposerAnswer(answer) {
            if (!answer) {
                return '';
            }

            const trimmed = answer.trim();
            const hasHtml = /<\/?[a-z][\s\S]*>/i.test(trimmed);
            if (hasHtml) {
                return trimmed;
            }

            const normalized = trimmed.replace(/\r\n/g, '\n');
            const paragraphs = normalized.split(/\n\n+/).map(para => para.replace(/\n/g, '<br>'));
            return '<p>' + paragraphs.join('</p><p>') + '</p>';
        }

        function replaceRangeWithContent(range, content) {
            if (!range) {
                return;
            }

            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                return;
            }

            range.deleteContents();

            let insertionContent = content ? content.trim() : '';
            let nodes = [];

            if (insertionContent && /<\/?[a-z][\s\S]*>/i.test(insertionContent)) {
                const temp = document.createElement('div');
                temp.innerHTML = insertionContent;
                while (temp.firstChild) {
                    nodes.push(temp.firstChild);
                    temp.removeChild(temp.firstChild);
                }
            } else if (insertionContent) {
                nodes.push(document.createTextNode(insertionContent.replace(/\s+/g, ' ').trim()));
            }

            const fragment = document.createDocumentFragment();
            let lastNode = null;
            nodes.forEach(node => {
                lastNode = node;
                fragment.appendChild(node);
            });

            if (fragment.childNodes.length) {
                range.insertNode(fragment);
            }

            const selection = window.getSelection();
            if (selection) {
                selection.removeAllRanges();
                const newRange = document.createRange();

                if (lastNode) {
                    if (lastNode.nodeType === Node.TEXT_NODE) {
                        newRange.setStart(lastNode, lastNode.textContent.length);
                        newRange.setEnd(lastNode, lastNode.textContent.length);
                    } else {
                        newRange.selectNode(lastNode);
                        newRange.collapse(false);
                    }
                } else {
                    newRange.setStart(range.endContainer, range.endOffset);
                    newRange.collapse(true);
                }

                selection.addRange(newRange);
            }

            editor.dispatchEvent(new Event('input', { bubbles: true }));
        }

        function initializeLunaComposerIntelligentMode() {
            const editor = document.getElementById('luna-composer-editor');
            const toggle = document.getElementById('luna-composer-mode-toggle');

            if (!editor || !toggle) {
                return;
            }

            if (!window.lunaComposerIntelligentInitialized) {
                window.lunaComposerIntelligentInitialized = true;

                editor.addEventListener('input', () => {
                    updateReimagineButtonState();
                });

                editor.addEventListener('paste', () => {
                    setTimeout(() => {
                        updateReimagineButtonState();
                    }, 100);
                });

                editor.addEventListener('mouseup', () => {
                    handleHighlightSelection();
                });

                editor.addEventListener('keyup', () => {
                    handleHighlightSelection();
                });

                document.addEventListener('selectionchange', () => {
                    const state = ensureReimagineState();
                    if (state.currentMode === 'highlight') {
                        handleHighlightSelection();
                    }
                });

                document.addEventListener('click', (event) => {
                    const wrapper = document.getElementById('luna-composer-reimagine-wrapper');
                    const tooltip = document.getElementById('luna-composer-highlight-tooltip');
                    const menu = document.getElementById('luna-composer-reimagine-menu');

                    if (menu && menu.style.display === 'block' && wrapper && !wrapper.contains(event.target)) {
                        hideReimagineMenu();
                    }

                    if (tooltip && tooltip.style.display === 'flex') {
                        if (!tooltip.contains(event.target) && !editor.contains(event.target)) {
                            hideHighlightTooltip();
                        }
                    }
                });

                window.addEventListener('scroll', () => {
                    const state = ensureReimagineState();
                    if (state.currentMode === 'highlight') {
                        hideHighlightTooltip();
                    }
                }, true);

                window.addEventListener('resize', () => {
                    const state = ensureReimagineState();
                    if (state.currentMode === 'highlight') {
                        hideHighlightTooltip();
                    }
                });
            }

            const highlightAction = document.getElementById('luna-composer-highlight-action');
            if (highlightAction && !highlightAction.dataset.listenerAttached) {
                highlightAction.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    window.lunaComposerReimagineHighlightedText();
                });
                highlightAction.dataset.listenerAttached = 'true';
            }

            updateReimagineButtonState();
        }
        
        // Category filtering functions
        window.lunaComposerFilterByCategory = function(categoryName) {
            console.log('[Luna Composer] Filtering by category:', categoryName);
            window.lunaComposerSelectedCategory = categoryName;
            
            // Update button states
            const categoryButtons = document.querySelectorAll('.luna-composer-category-btn');
            categoryButtons.forEach(btn => {
                const btnCategory = btn.getAttribute('data-category');
                if (btnCategory === categoryName) {
                    btn.style.background = '#2E2C2A';
                    btn.style.borderColor = '#5A5753';
                    btn.style.color = '#fff4e9';
                } else {
                    btn.style.background = '#2E2C2A50';
                    btn.style.borderColor = '#5A575335';
                    btn.style.color = '#9A9793';
                }
            });
            
            // Show reset button
            const resetBtn = document.getElementById('luna-composer-category-reset');
            if (resetBtn) {
                resetBtn.style.display = 'flex';
                resetBtn.style.alignItems = 'center';
            }
            
            // Filter items
            const promptItems = document.querySelectorAll('.canned-prompt-item');
            let visibleCount = 0;
            promptItems.forEach(item => {
                const itemCategories = item.getAttribute('data-categories') || '';
                const categories = itemCategories.split(',').map(c => c.trim());
                if (categories.includes(categoryName)) {
                    item.style.display = 'block';
                    visibleCount++;
                } else {
                    item.style.display = 'none';
                }
            });
            
            console.log('[Luna Composer] Showing', visibleCount, 'items for category:', categoryName);
        };
        
        window.lunaComposerResetCategoryFilter = function() {
            console.log('[Luna Composer] Resetting category filter');
            window.lunaComposerSelectedCategory = null;
            
            // Reset button states
            const categoryButtons = document.querySelectorAll('.luna-composer-category-btn');
            categoryButtons.forEach(btn => {
                btn.style.background = '#2E2C2A50';
                btn.style.borderColor = '#5A575335';
                btn.style.color = '#9A9793';
            });
            
            // Hide reset button
            const resetBtn = document.getElementById('luna-composer-category-reset');
            if (resetBtn) {
                resetBtn.style.display = 'none';
            }
            
            // Show all items
            const promptItems = document.querySelectorAll('.canned-prompt-item');
            promptItems.forEach(item => {
                item.style.display = 'block';
            });
            
            console.log('[Luna Composer] Showing all', promptItems.length, 'items');
        };

        function lunaComposerNormalizeActionText(text) {
            return (text || '').replace(/\s+/g, ' ').replace(/^[^:]+:\s*/, '').trim();
        }

        function lunaComposerInferTeam(actionText) {
            const lower = (actionText || '').toLowerCase();
            if (lower.match(/security|waf|tls|ssl|firewall|vuln|patch/)) return 'Security';
            if (lower.match(/plugin|theme|code|dev|engineering|bug|fix|update/)) return 'Engineering';
            if (lower.match(/content|copy|page|post|blog|seo/)) return 'Content';
            if (lower.match(/campaign|ads?|marketing|engagement/)) return 'Marketing';
            return 'Operations';
        }

        function lunaComposerExtractActionables(answerHtml) {
            const normalizedHtml = (answerHtml || '')
                .replace(/<br\s*\/?\s*>/gi, '\n')
                .replace(/<\/(p|div|li|h[1-6]|ul|ol)\s*>/gi, '\n')
                .replace(/<[^>]+>/g, ' ');
            const rawText = (normalizedHtml || '').replace(/\u00a0/g, ' ').replace(/\s+/g, ' ').trim();
            if (!rawText) return [];

            const lines = (normalizedHtml || '')
                .split(/\n+/)
                .map(line => line.replace(/\u00a0/g, ' ').trim())
                .filter(Boolean);
            const actions = [];

            const pushAction = (value) => {
                const normalized = lunaComposerNormalizeActionText(value);
                if (normalized && !actions.includes(normalized)) {
                    actions.push(normalized);
                }
            };

            lines.forEach((line, idx) => {
                if (/^next steps?/i.test(line)) {
                    const afterColon = line.split(/:/)[1];
                    if (afterColon) {
                        pushAction(afterColon);
                    } else if (lines[idx + 1]) {
                        pushAction(lines[idx + 1]);
                    }
                    if (lines[idx + 2] && lines[idx + 2].startsWith('-')) {
                        pushAction(lines[idx + 2]);
                    }
                }

                if (/^recommendations?/i.test(line)) {
                    const afterColon = line.split(/:/)[1];
                    if (afterColon) {
                        pushAction(afterColon);
                    }
                    for (let offset = 1; offset <= 3; offset++) {
                        if (lines[idx + offset] && /^[-•]/.test(lines[idx + offset])) {
                            pushAction(lines[idx + offset]);
                        }
                    }
                }

                if (/^actionable next steps?/i.test(line)) {
                    const afterColon = line.split(/:/)[1];
                    if (afterColon) pushAction(afterColon);
                    if (lines[idx + 1]) pushAction(lines[idx + 1]);
                }
            });

            if (!actions.length) {
                const sentences = rawText.split(/(?<=[.!?])\s+/).filter(Boolean);
                sentences.forEach(sentence => {
                    if (/next step|recommend|consider/i.test(sentence)) {
                        pushAction(sentence);
                    }
                });
                if (!actions.length && sentences.length) {
                    pushAction(sentences[sentences.length - 1]);
                }
            }

            return actions.slice(0, 3);
        }

        function lunaComposerScheduleFollowup(promptText, licenseKey, type) {
            const payload = {
                prompt: lunaComposerNormalizeActionText(promptText),
                license: licenseKey || null,
                created: Date.now(),
                type: type || 'followup'
            };
            try {
                localStorage.setItem('lunaComposerFollowupPrompt', JSON.stringify(payload));
            } catch (e) {
                console.warn('[Luna Composer] Failed to cache follow-up prompt:', e);
            }

            const newWin = window.open(window.location.href, '_blank');
            if (!newWin) {
                alert('Please allow pop-ups so Luna can open the follow-up in a new tab.');
            }
        }

        function lunaComposerRenderActionables(answerHtml, promptText, licenseKey) {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;

            const existing = document.getElementById('luna-composer-actionables');
            if (existing) existing.remove();

            const actions = lunaComposerExtractActionables(answerHtml);
            if (!actions.length) return;

            const wrapper = document.createElement('div');
            wrapper.id = 'luna-composer-actionables';
            wrapper.style.cssText = 'margin-top: 16px; padding: 16px; border: 1px solid #1f1d1a; border-radius: 8px; background: #0b0b0b; display: flex; flex-direction: column; gap: 12px; color: #fff4e9;';

            const heading = document.createElement('div');
            heading.textContent = 'Make Luna\'s recommendations actionable:';
            heading.style.cssText = 'font-weight: 700; font-size: 1rem;';
            wrapper.appendChild(heading);

            actions.forEach((actionText, index) => {
                const actionRow = document.createElement('div');
                actionRow.style.cssText = 'border-top: 1px solid #1f1d1a; padding-top: 12px; margin-top: 12px; display: flex; flex-direction: column; gap: 10px;';

                const actionLabel = document.createElement('div');
                actionLabel.style.cssText = 'font-weight: 600; color: #d9d5d0;';
                actionLabel.textContent = 'Recommendation ' + (index + 1) + ': ' + actionText;
                actionRow.appendChild(actionLabel);

                const followupPrompt = 'Would you like me to save this doc and run a new prompt with this recommendation?';
                const followupBlock = document.createElement('div');
                followupBlock.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px; align-items: center;';
                const followupText = document.createElement('span');
                followupText.textContent = followupPrompt;
                followupText.style.cssText = 'flex: 1; min-width: 220px; color: #c8c4be;';
                followupBlock.appendChild(followupText);

                const yesFollow = document.createElement('button');
                yesFollow.textContent = 'Yes — open follow-up';
                yesFollow.style.cssText = 'background: #8D8C00; color: #000; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: 700;';
                yesFollow.addEventListener('click', () => {
                    lunaComposerScheduleFollowup(actionText, licenseKey, 'recommendation');
                });

                const noFollow = document.createElement('button');
                noFollow.textContent = 'No';
                noFollow.style.cssText = 'background: #2E2C2A; color: #fff4e9; border: 1px solid #1f1d1a; padding: 8px 12px; border-radius: 6px; cursor: pointer;';
                noFollow.addEventListener('click', () => {
                    noFollow.disabled = true;
                });

                followupBlock.appendChild(yesFollow);
                followupBlock.appendChild(noFollow);
                actionRow.appendChild(followupBlock);

                const team = lunaComposerInferTeam(actionText);
                const ticketText = document.createElement('span');
                ticketText.textContent = 'Would you like me to formulate a ticket summary for your ' + team + ' team?';
                ticketText.style.cssText = 'flex: 1; min-width: 220px; color: #c8c4be;';

                const ticketBlock = document.createElement('div');
                ticketBlock.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px; align-items: center;';
                ticketBlock.appendChild(ticketText);

                const yesTicket = document.createElement('button');
                yesTicket.textContent = 'Yes — draft ticket';
                yesTicket.style.cssText = 'background: #5A5753; color: #fff4e9; border: 1px solid #1f1d1a; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: 700;';
                yesTicket.addEventListener('click', () => {
                    const ticketPrompt = 'Create a hand-off ready ticket summary for the ' + team + ' team to address: ' + actionText + '. Include context, expected impact, and a concise checklist.';
                    lunaComposerScheduleFollowup(ticketPrompt, licenseKey, 'ticket');
                });

                const noTicket = document.createElement('button');
                noTicket.textContent = 'No';
                noTicket.style.cssText = 'background: #2E2C2A; color: #fff4e9; border: 1px solid #1f1d1a; padding: 8px 12px; border-radius: 6px; cursor: pointer;';
                noTicket.addEventListener('click', () => {
                    noTicket.disabled = true;
                });

                ticketBlock.appendChild(yesTicket);
                ticketBlock.appendChild(noTicket);
                actionRow.appendChild(ticketBlock);

                wrapper.appendChild(actionRow);
            });

            editor.appendChild(wrapper);
        }
        
        window.lunaComposerUsePrompt = async function(promptId, promptText, responseContent) {
            console.log('[Luna Composer] Using prompt:', promptId, promptText);
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            // Generate new document ID for this prompt
            const licenseKey = editor.getAttribute('data-license-key');
            if (!licenseKey) {
                console.error('[Luna Composer] License key not found');
                return;
            }
            
            const documentId = 'doc_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
            editor.setAttribute('data-document-id', documentId);
            editor.setAttribute('data-prompt', promptText);
            
            // Update URL with new document ID
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            if (currentLicense) {
                const baseLicense = currentLicense.split('/luna/compose/')[0];
                const newUrl = new URL(window.location.href);
                newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + documentId);
                window.history.replaceState({}, '', newUrl.toString());
            }
            
            // Show loading state with circular loading icon and gradient text
            // Create thought process display
            const thoughtProcessContainer = document.createElement('div');
            thoughtProcessContainer.id = 'luna-composer-thinking';
            thoughtProcessContainer.style.cssText = 'padding: 40px 20px; min-height: 300px; background: #000; border-radius: 8px;';
            
            const thinkingHeader = document.createElement('div');
            thinkingHeader.style.cssText = 'display: flex; align-items: center; gap: 12px; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid #1f1d1a;';
            
            const thinkingIcon = document.createElement('div');
            thinkingIcon.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="width: 24px; height: 24px;"><circle cx="12" cy="12" r="10" stroke="#fff4e9" stroke-width="2" stroke-linecap="round" stroke-dasharray="31.416" stroke-dashoffset="23.562" opacity="0.6"><animate attributeName="stroke-dashoffset" dur="1.5s" values="31.416;0" repeatCount="indefinite"/></circle></svg>';
            
            const thinkingTitle = document.createElement('span');
            thinkingTitle.style.cssText = 'color: #fff4e9; font-size: 1.1rem; font-weight: 600;';
            thinkingTitle.textContent = 'Luna is considering all possibilities...';
            
            thinkingHeader.appendChild(thinkingIcon);
            thinkingHeader.appendChild(thinkingTitle);
            
            const thoughtProcessList = document.createElement('div');
            thoughtProcessList.id = 'luna-thinking-process';
            thoughtProcessList.style.cssText = 'display: flex; flex-direction: column; gap: 16px;';
            
            thoughtProcessContainer.appendChild(thinkingHeader);
            thoughtProcessContainer.appendChild(thoughtProcessList);
            editor.innerHTML = '';
            editor.appendChild(thoughtProcessContainer);
            
            // Generate thought processes based on prompt
            const thoughtProcesses = generateThoughtProcesses(promptText);
            let currentThoughtIndex = 0;
            let thoughtInterval = null;
            
            // Display first thought immediately
            if (thoughtProcesses.length > 0) {
                addThoughtProcess(thoughtProcessList, thoughtProcesses[0], 0);
                currentThoughtIndex = 1;
            }
            
            // Update thought processes every 3 seconds
            thoughtInterval = setInterval(() => {
                if (currentThoughtIndex < thoughtProcesses.length) {
                    addThoughtProcess(thoughtProcessList, thoughtProcesses[currentThoughtIndex], currentThoughtIndex);
                    currentThoughtIndex++;
                } else {
                    // Cycle through thoughts if we've shown them all
                    currentThoughtIndex = 0;
                    thoughtProcessList.innerHTML = '';
                    if (thoughtProcesses.length > 0) {
                        addThoughtProcess(thoughtProcessList, thoughtProcesses[0], 0);
                        currentThoughtIndex = 1;
                    }
                }
            }, 3000);
            
            // Always send prompt to Luna (don't use canned response content directly)
            // Luna will use GPT-4o + VL Hub data to generate a thoughtful response
            try {
                console.log('[Luna Composer] Sending prompt to Luna API...');
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Luna-Composer': 'canned'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        prompt: promptText,
                        context: 'composer',
                        composer: '1',
                        intent: 'luna_composer_canned',
                        license: licenseKey
                    })
                });
                
                console.log('[Luna Composer] Response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[Luna Composer] Response data:', data);
                    if (data.answer) {
                        // Clear thought process interval
                        if (thoughtInterval) {
                            clearInterval(thoughtInterval);
                            thoughtInterval = null;
                        }
                        
                        // Convert newlines to <br> tags and preserve formatting
                        let formattedAnswer = data.answer.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>');
                        if (!formattedAnswer.startsWith('<p>')) {
                            formattedAnswer = '<p>' + formattedAnswer + '</p>';
                        }
                        editor.innerHTML = formattedAnswer;
                        editor.scrollTop = 0;
                        console.log('[Luna Composer] Response displayed in editor');

                        lunaComposerRenderActionables(formattedAnswer, promptText, licenseKey);
                        
                        // Show and initialize heart icon state (defaults to dislike)
                        setTimeout(() => {
                            const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                            if (heartBtn) {
                                heartBtn.style.display = 'flex';
                            }
                            window.lunaComposerUpdateHeartState();
                        }, 100);
                        
                        // Auto-save the new document
                        const documentData = {
                            id: documentId,
                            content: formattedAnswer,
                            prompt: promptText,
                            timestamp: Date.now(),
                            license: licenseKey,
                            feedback: 'dislike' // Default to dislike for new documents
                        };
                        
                        const docKey = `luna_composer_doc_${documentId}`;
                        localStorage.setItem(docKey, JSON.stringify(documentData));
                        
                        // Add to history
                        const historyKey = `luna_composer_history_${licenseKey}`;
                        let history = [];
                        try {
                            const historyStr = localStorage.getItem(historyKey);
                            if (historyStr) {
                                history = JSON.parse(historyStr);
                            }
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse history:', e);
                        }
                        
                        // Find existing entry with same document ID and update it, or add new
                        const existingIndex = history.findIndex(doc => doc.id === documentId);
                        if (existingIndex !== -1) {
                            // Update existing entry
                            history[existingIndex].prompt = promptText;
                            history[existingIndex].timestamp = Date.now();
                            history[existingIndex].feedback = 'dislike'; // Ensure feedback is set
                        } else {
                            // Add new entry to beginning of history with feedback
                            history.unshift({
                                id: documentId,
                                prompt: promptText,
                                timestamp: Date.now(),
                                feedback: 'dislike' // Default to dislike for new documents
                            });
                        }
                        
                        if (history.length > 50) {
                            history = history.slice(0, 50);
                        }
                        
                        localStorage.setItem(historyKey, JSON.stringify(history));
                        
                        // Save to WordPress via REST API
                        fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/save', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({
                                license: licenseKey,
                                document_id: documentId,
                                prompt: promptText,
                                content: formattedAnswer,
                                feedback: 'dislike' // Include feedback in save
                            })
                        }).then(response => {
                            if (response.ok) {
                                console.log('[Luna Composer] Document saved to WordPress');
                                
                                // Show "Saved to VL Cloud" message with fade-in
                                const saveMessage = document.getElementById('luna-composer-save-message');
                                if (saveMessage) {
                                    // Ensure transition is set for fade-in
                                    saveMessage.style.transition = 'opacity 0.3s ease';
                                    const now = new Date();
                                    saveMessage.textContent = 'Saved to VL Cloud • ' + now.toLocaleTimeString();
                                    saveMessage.style.color = '#fff4e9';
                                    saveMessage.style.opacity = '1';
                                    
                                    // Fade out after 5 seconds
                                    setTimeout(() => {
                                        saveMessage.style.transition = 'opacity 0.5s ease';
                                        saveMessage.style.opacity = '0';
                                        // Clear text after fade completes
                                        setTimeout(() => {
                                            saveMessage.textContent = '';
                                        }, 500);
                                    }, 5000);
                                }
                                
                                // Reload history to show new document in Disliked section
                                setTimeout(() => {
                                    if (typeof loadLunaComposerHistory === 'function') {
                                        loadLunaComposerHistory();
                                    }
                                }, 500);
                                
                                // Add activity notification to main Supercluster page (not on /luna/compose/)
                                const currentParams = new URLSearchParams(window.location.search);
                                const currentLicense = currentParams.get('license') || '';
                                const isLunaComposePage = currentLicense.includes('/luna/compose/');
                                
                                if (!isLunaComposePage) {
                                    // Add to activity stream
                                    const activityList = document.getElementById('recentActivityList');
                                    if (activityList) {
                                        const now = new Date();
                                        const activityItem = document.createElement('li');
                                        activityItem.className = 'vl-activity-item';
                                        
                                        const timeSpan = document.createElement('span');
                                        timeSpan.id = 'activityTimeStamp';
                                        timeSpan.textContent = now.toLocaleString();
                                        activityItem.appendChild(timeSpan);
                                        activityItem.appendChild(document.createElement('br'));
                                        
                                        const labelText = document.createTextNode('Luna Compose Doc was created');
                                        activityItem.appendChild(labelText);
                                        
                                        // Remove "No recent activity" if present
                                        const emptyItem = activityList.querySelector('.vl-activity-empty');
                                        if (emptyItem) {
                                            emptyItem.remove();
                                        }
                                        
                                        // Insert at the beginning
                                        activityList.insertBefore(activityItem, activityList.firstChild);
                                        
                                        // Keep only last 10 items
                                        const items = activityList.querySelectorAll('.vl-activity-item');
                                        if (items.length > 10) {
                                            for (let i = 10; i < items.length; i++) {
                                                items[i].remove();
                                            }
                                        }
                                    }
                                }
                            } else {
                                console.warn('[Luna Composer] Failed to save to WordPress:', response.status);
                            }
                        }).catch(e => {
                            console.warn('[Luna Composer] Error saving to WordPress:', e);
                        });
                        
                        // Refresh history list
                        loadLunaComposerHistory();
                    } else {
                        // Clear thought process interval on no answer
                        if (thoughtInterval) {
                            clearInterval(thoughtInterval);
                            thoughtInterval = null;
                        }
                        editor.innerHTML = '<p style="color: #d63638;">Error: No answer received from Luna</p>';
                    }
                } else {
                    // Clear thought process interval on API error
                    if (thoughtInterval) {
                        clearInterval(thoughtInterval);
                        thoughtInterval = null;
                    }
                    const errorText = await response.text();
                    console.error('[Luna Composer] API error:', response.status, errorText);
                    editor.innerHTML = '<p style="color: #d63638;">Error: Failed to get response from Luna (HTTP ' + response.status + ')</p>';
                }
            } catch (e) {
                console.error('[Luna Composer] Error sending prompt:', e);
                // Clear thought process interval on error
                if (thoughtInterval) {
                    clearInterval(thoughtInterval);
                    thoughtInterval = null;
                }
                editor.innerHTML = '<p style="color: #d63638;">Error: ' + (e.message || 'Failed to connect to Luna') + '</p>';
            }
        };

        window.lunaComposerAutoRunFollowup = function() {
            let stored = null;
            try {
                stored = JSON.parse(localStorage.getItem('lunaComposerFollowupPrompt'));
            } catch (e) {
                stored = null;
            }

            if (!stored || !stored.prompt || (Date.now() - (stored.created || 0)) > 5 * 60 * 1000) {
                return;
            }

            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                setTimeout(window.lunaComposerAutoRunFollowup, 400);
                return;
            }

            try {
                localStorage.removeItem('lunaComposerFollowupPrompt');
            } catch (e) {
                console.warn('[Luna Composer] Failed to clear follow-up prompt cache:', e);
            }

            window.lunaComposerUsePrompt('auto_followup', stored.prompt, '');
        };

        window.addEventListener('load', () => {
            setTimeout(window.lunaComposerAutoRunFollowup, 800);
        });
        
        // Generate thought processes based on prompt
        function generateThoughtProcesses(promptText) {
            const thoughts = [];
            const lowerPrompt = promptText.toLowerCase();
            
            // Analyze prompt and generate relevant thoughts
            if (lowerPrompt.includes('report') || lowerPrompt.includes('analysis') || lowerPrompt.includes('summary')) {
                thoughts.push({
                    icon: '📊',
                    text: 'Analyzing data streams from VL Hub Profile...',
                    detail: 'Reviewing performance metrics, security status, and infrastructure health'
                });
                thoughts.push({
                    icon: '🔍',
                    text: 'Cross-referencing multiple data sources...',
                    detail: 'Connecting WordPress data, analytics, and cloud service insights'
                });
                thoughts.push({
                    icon: '📈',
                    text: 'Identifying key patterns and trends...',
                    detail: 'Detecting anomalies, opportunities, and areas for optimization'
                });
                thoughts.push({
                    icon: '💡',
                    text: 'Synthesizing actionable recommendations...',
                    detail: 'Combining technical insights with strategic WebOps expertise'
                });
            } else if (lowerPrompt.includes('blog') || lowerPrompt.includes('post') || lowerPrompt.includes('article') || lowerPrompt.includes('content')) {
                thoughts.push({
                    icon: '✍️',
                    text: 'Researching topic and gathering context...',
                    detail: 'Reviewing existing content, keywords, and audience insights'
                });
                thoughts.push({
                    icon: '📚',
                    text: 'Structuring content for maximum impact...',
                    detail: 'Organizing information flow and ensuring readability'
                });
                thoughts.push({
                    icon: '🎯',
                    text: 'Optimizing for SEO and engagement...',
                    detail: 'Incorporating relevant keywords and compelling narratives'
                });
                thoughts.push({
                    icon: '✨',
                    text: 'Adding strategic insights and value...',
                    detail: 'Enhancing with data-driven examples and expert perspectives'
                });
            } else if (lowerPrompt.includes('security') || lowerPrompt.includes('vulnerability') || lowerPrompt.includes('audit')) {
                thoughts.push({
                    icon: '🔒',
                    text: 'Scanning security infrastructure...',
                    detail: 'Reviewing SSL/TLS certificates, Cloudflare settings, and firewall configurations'
                });
                thoughts.push({
                    icon: '🛡️',
                    text: 'Analyzing potential vulnerabilities...',
                    detail: 'Cross-checking against known security best practices and threats'
                });
                thoughts.push({
                    icon: '⚡',
                    text: 'Evaluating security posture...',
                    detail: 'Assessing current protections and identifying gaps'
                });
                thoughts.push({
                    icon: '🎯',
                    text: 'Formulating security recommendations...',
                    detail: 'Prioritizing critical fixes and actionable improvements'
                });
            } else {
                // Generic thought processes
                thoughts.push({
                    icon: '🧠',
                    text: 'Processing your request...',
                    detail: 'Understanding context and requirements from VL Hub data'
                });
                thoughts.push({
                    icon: '🔗',
                    text: 'Connecting to VL Hub intelligence...',
                    detail: 'Accessing real-time data streams and historical insights'
                });
                thoughts.push({
                    icon: '⚙️',
                    text: 'Analyzing relevant information...',
                    detail: 'Cross-referencing multiple data sources for accuracy'
                });
                thoughts.push({
                    icon: '💭',
                    text: 'Generating intelligent response...',
                    detail: 'Synthesizing insights with GPT-4o reasoning capabilities'
                });
                thoughts.push({
                    icon: '✨',
                    text: 'Refining and optimizing output...',
                    detail: 'Ensuring clarity, accuracy, and actionable value'
                });
            }
            
            return thoughts;
        }
        
        // Add a thought process item to the display
        function addThoughtProcess(container, thought, index) {
            const thoughtItem = document.createElement('div');
            thoughtItem.className = 'luna-thinking-item';
            thoughtItem.style.cssText = 'opacity: 0; transform: translateY(10px); transition: all 0.5s ease; padding: 16px; background: #1f1d1a; border-left: 3px solid #974C00; border-radius: 4px;';
            
            const thoughtContent = document.createElement('div');
            thoughtContent.style.cssText = 'display: flex; align-items: flex-start; gap: 12px;';
            
            const thoughtIcon = document.createElement('span');
            thoughtIcon.style.cssText = 'font-size: 1.5rem; flex-shrink: 0;';
            thoughtIcon.textContent = thought.icon;
            
            const thoughtText = document.createElement('div');
            thoughtText.style.cssText = 'flex: 1;';
            
            const thoughtMain = document.createElement('div');
            thoughtMain.style.cssText = 'color: #fff4e9; font-size: 0.95rem; font-weight: 500; margin-bottom: 4px;';
            thoughtMain.textContent = thought.text;
            
            const thoughtDetail = document.createElement('div');
            thoughtDetail.style.cssText = 'color: #9A9793; font-size: 0.85rem; line-height: 1.4;';
            thoughtDetail.textContent = thought.detail;
            
            thoughtText.appendChild(thoughtMain);
            thoughtText.appendChild(thoughtDetail);
            thoughtContent.appendChild(thoughtIcon);
            thoughtContent.appendChild(thoughtText);
            thoughtItem.appendChild(thoughtContent);
            
            container.appendChild(thoughtItem);
            
            // Animate in
            setTimeout(() => {
                thoughtItem.style.opacity = '1';
                thoughtItem.style.transform = 'translateY(0)';
            }, 50);
            
            // Keep only last 4 thoughts visible
            const items = container.querySelectorAll('.luna-thinking-item');
            if (items.length > 4) {
                items[0].style.opacity = '0';
                items[0].style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    if (items[0].parentNode) {
                        items[0].parentNode.removeChild(items[0]);
                    }
                }, 500);
            }
        }
        
        // Initialize auto-save with document ID generation
        function initializeLunaComposerAutoSave() {
            const editor = document.getElementById('luna-composer-editor');
            const statusEl = document.getElementById('luna-composer-auto-save-status');
            if (!editor) return;
            
            // Ensure auto-save status is visible
            if (statusEl) {
                statusEl.style.display = 'flex';
            }
            
            let saveTimeout = null;
            let lastSaved = null;
            const licenseKey = editor.getAttribute('data-license-key');
            let documentId = editor.getAttribute('data-document-id');
            
            // Generate document ID if not present
            if (!documentId || documentId === '') {
                documentId = 'doc_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
                editor.setAttribute('data-document-id', documentId);
                
                // Update URL with document ID
                const currentParams = new URLSearchParams(window.location.search);
                const currentLicense = currentParams.get('license') || '';
                if (currentLicense) {
                    const baseLicense = currentLicense.split('/luna/compose/')[0];
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + documentId);
                    window.history.replaceState({}, '', newUrl.toString());
                }
            }
            
            // Auto-save on input
            editor.addEventListener('input', () => {
                // Show auto-save status
                if (statusEl) {
                    statusEl.style.display = 'flex';
                }
                
                // Auto-saving state - icon remains visible, no message
                const saveMessage = document.getElementById('luna-composer-save-message');
                if (saveMessage) {
                    saveMessage.textContent = '';
                    saveMessage.style.opacity = '0';
                }
                
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    const content = editor.innerHTML;
                    const prompt = editor.getAttribute('data-prompt') || '';
                    
                    if (!licenseKey) return;
                    
                    // Get existing document data to preserve feedback
                    const docKey = `luna_composer_doc_${documentId}`;
                    let existingDocData = null;
                    try {
                        const existingDocStr = localStorage.getItem(docKey);
                        if (existingDocStr) {
                            existingDocData = JSON.parse(existingDocStr);
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse existing doc data:', e);
                    }
                    
                    // Save document with metadata, preserving feedback
                    const documentData = {
                        id: documentId,
                        content: content,
                        prompt: prompt,
                        timestamp: Date.now(),
                        license: licenseKey,
                        feedback: existingDocData?.feedback || 'dislike' // Preserve existing feedback or default to dislike
                    };
                    
                    // Save to localStorage with document ID
                    localStorage.setItem(docKey, JSON.stringify(documentData));
                    
                    // Also save to history list
                    const historyKey = `luna_composer_history_${licenseKey}`;
                    let history = [];
                    try {
                        const historyStr = localStorage.getItem(historyKey);
                        if (historyStr) {
                            history = JSON.parse(historyStr);
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse history:', e);
                    }
                    
                    // Find existing entry with same document ID and update it
                    const existingIndex = history.findIndex(doc => doc.id === documentId);
                    if (existingIndex !== -1) {
                        // Update existing entry, preserving feedback
                        history[existingIndex].prompt = prompt || 'Untitled Document';
                        history[existingIndex].timestamp = Date.now();
                        if (documentData.feedback) {
                            history[existingIndex].feedback = documentData.feedback;
                        }
                    } else {
                        // Add new entry to beginning of history
                        history.unshift({
                            id: documentId,
                            prompt: prompt || 'Untitled Document',
                            timestamp: Date.now(),
                            feedback: documentData.feedback || 'dislike'
                        });
                    }
                    
                    // Keep only last 50 documents
                    if (history.length > 50) {
                        history = history.slice(0, 50);
                    }
                    
                    localStorage.setItem(historyKey, JSON.stringify(history));
                    
                    // Save to WordPress via REST API
                    fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            license: licenseKey,
                            document_id: documentId,
                            prompt: prompt,
                            content: content,
                            feedback: documentData.feedback || 'dislike' // Include feedback in save
                        })
                    }).then(response => {
                        if (response.ok) {
                            console.log('[Luna Composer] Document saved to WordPress');
                            
                            // Show "Saved to VL Cloud" message with fade-in and timestamp
                            const saveMessage = document.getElementById('luna-composer-save-message');
                            if (saveMessage) {
                                // Ensure transition is set for fade-in
                                saveMessage.style.transition = 'opacity 0.3s ease';
                                const now = new Date();
                                saveMessage.textContent = 'Saved to VL Cloud • ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                saveMessage.style.color = '#fff4e9';
                                saveMessage.style.opacity = '1';
                                
                                // Fade out after 5 seconds
                                setTimeout(() => {
                                    saveMessage.style.transition = 'opacity 0.5s ease';
                                    saveMessage.style.opacity = '0';
                                    // Clear text after fade completes
                                    setTimeout(() => {
                                        saveMessage.textContent = '';
                                    }, 500);
                                }, 5000);
                            }
                            
                            // Reload history to show updated document
                            setTimeout(() => {
                                if (typeof loadLunaComposerHistory === 'function') {
                                    loadLunaComposerHistory();
                                }
                            }, 500);
                            
                            // Add activity notification to main Supercluster page (not on /luna/compose/)
                            const currentParams = new URLSearchParams(window.location.search);
                            const currentLicense = currentParams.get('license') || '';
                            const isLunaComposePage = currentLicense.includes('/luna/compose/');
                            
                            if (!isLunaComposePage) {
                                // Add to activity stream
                                const activityList = document.getElementById('recentActivityList');
                                if (activityList) {
                                    const now = new Date();
                                    const activityItem = document.createElement('li');
                                    activityItem.className = 'vl-activity-item';
                                    
                                    const timeSpan = document.createElement('span');
                                    timeSpan.id = 'activityTimeStamp';
                                    timeSpan.textContent = now.toLocaleString();
                                    activityItem.appendChild(timeSpan);
                                    activityItem.appendChild(document.createElement('br'));
                                    
                                    const labelText = document.createTextNode('Luna Compose Doc was created');
                                    activityItem.appendChild(labelText);
                                    
                                    // Remove "No recent activity" if present
                                    const emptyItem = activityList.querySelector('.vl-activity-empty');
                                    if (emptyItem) {
                                        emptyItem.remove();
                                    }
                                    
                                    // Insert at the beginning
                                    activityList.insertBefore(activityItem, activityList.firstChild);
                                    
                                    // Keep only last 10 items
                                    const items = activityList.querySelectorAll('.vl-activity-item');
                                    if (items.length > 10) {
                                        for (let i = 10; i < items.length; i++) {
                                            items[i].remove();
                                        }
                                    }
                                }
                            }
                        } else {
                            console.warn('[Luna Composer] Failed to save to WordPress:', response.status);
                        }
                    }).catch(e => {
                        console.warn('[Luna Composer] Error saving to WordPress:', e);
                    });
                    
                    lastSaved = new Date();
                    
                    // Refresh history list
                    loadLunaComposerHistory();
                }, 2000); // Save after 2 seconds of inactivity
            });
            
            // Load saved content on page load
            if (documentId && documentId !== '') {
                const docKey = `luna_composer_doc_${documentId}`;
                const savedDoc = localStorage.getItem(docKey);
                if (savedDoc) {
                    try {
                        const docData = JSON.parse(savedDoc);
                        if (docData.content) {
                            editor.innerHTML = docData.content;
                            if (docData.prompt) {
                                editor.setAttribute('data-prompt', docData.prompt);
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse saved document:', e);
                    }
                }
            } else if (licenseKey) {
                // Fallback: load latest document for this license
                const historyKey = `luna_composer_history_${licenseKey}`;
                const historyStr = localStorage.getItem(historyKey);
                if (historyStr) {
                    try {
                        const history = JSON.parse(historyStr);
                        if (history.length > 0) {
                            const latestDoc = history[0];
                            const docKey = `luna_composer_doc_${latestDoc.id}`;
                            const savedDoc = localStorage.getItem(docKey);
                            if (savedDoc) {
                                const docData = JSON.parse(savedDoc);
                                if (docData.content) {
                                    editor.innerHTML = docData.content;
                                    editor.setAttribute('data-document-id', latestDoc.id);
                                    if (docData.prompt) {
                                        editor.setAttribute('data-prompt', docData.prompt);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not load latest document:', e);
                    }
                }
            }
        }
        
        // Load and display history in sidebar - fetch from WordPress first
        async function loadLunaComposerHistory() {
            const historyList = document.getElementById('lunaComposerHistoryList');
            if (!historyList) return;
            
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;
            
            const licenseKey = editor.getAttribute('data-license-key');
            if (!licenseKey) return;
            
            // Try to fetch from WordPress first (last 30 days)
            // Get the client's WordPress site URL from the editor data attribute or use visiblelight.ai as fallback
            const clientSiteUrl = editor.getAttribute('data-client-site-url') || 'https://visiblelight.ai';
            try {
                const response = await fetch(`${clientSiteUrl}/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.documents && data.documents.length > 0) {
                        // Update localStorage with WordPress data
                        const history = data.documents.map(doc => ({
                            id: doc.id,
                            prompt: doc.prompt || 'Untitled Document',
                            timestamp: doc.timestamp,
                            feedback: doc.feedback || 'dislike' // Include feedback from WordPress
                        }));
                        
                        const historyKey = `luna_composer_history_${licenseKey}`;
                        localStorage.setItem(historyKey, JSON.stringify(history));
                        
                        // Cache individual documents with feedback
                        data.documents.forEach(doc => {
                            const docKey = `luna_composer_doc_${doc.id}`;
                            localStorage.setItem(docKey, JSON.stringify({
                                id: doc.id,
                                content: doc.content,
                                prompt: doc.prompt,
                                timestamp: doc.timestamp,
                                license: licenseKey,
                                feedback: doc.feedback || 'dislike' // Include feedback from WordPress
                            }));
                            
                            // Also store feedback separately for easy lookup
                            if (doc.feedback) {
                                const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                localStorage.setItem(feedbackKey, JSON.stringify({
                                    feedback: doc.feedback,
                                    timestamp: Date.now()
                                }));
                            }
                        });
                        
                        // Display history
                        displayHistory(history, historyList, editor, licenseKey);
                        return;
                    }
                }
            } catch (e) {
                console.warn('[Luna Composer] Could not fetch history from WordPress:', e);
            }
            
            // Fallback to localStorage
            const historyKey = `luna_composer_history_${licenseKey}`;
            const historyStr = localStorage.getItem(historyKey);
            
            if (!historyStr) {
                historyList.innerHTML = '<li class="vl-activity-empty">No saved documents.</li>';
                return;
            }
            
            try {
                const history = JSON.parse(historyStr);
                
                if (history.length === 0) {
                    historyList.innerHTML = '<li class="vl-activity-empty">No saved documents.</li>';
                    return;
                }
                
                displayHistory(history, historyList, editor, licenseKey);
            } catch (e) {
                console.error('[Luna Composer] Could not parse history:', e);
                historyList.innerHTML = '<li class="vl-activity-empty">Error loading history.</li>';
            }
        }
        
        // Display history list with Liked/Disliked categories
        function displayHistory(history, historyList, editor, licenseKey) {
            historyList.innerHTML = '';
            
            // Separate into liked and disliked
            const likedDocs = [];
            const dislikedDocs = [];
            
            history.forEach(doc => {
                // Check feedback from doc object first (from WordPress), then localStorage
                let feedback = doc.feedback || null;
                
                if (!feedback) {
                    // Check feedback from localStorage document data
                    const docKey = `luna_composer_doc_${doc.id}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            feedback = docData.feedback || null;
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse doc data:', e);
                        }
                    }
                }
                
                // Also check if feedback was stored separately
                if (!feedback) {
                    const feedbackKey = `luna_composer_feedback_${doc.id}`;
                    const feedbackStr = localStorage.getItem(feedbackKey);
                    if (feedbackStr) {
                        try {
                            const feedbackData = JSON.parse(feedbackStr);
                            feedback = feedbackData.feedback || null;
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse feedback:', e);
                        }
                    }
                }
                
                // Default to dislike if no feedback found
                if (!feedback) {
                    feedback = 'dislike';
                }
                
                if (feedback === 'like') {
                    likedDocs.push({...doc, feedback: 'like'});
                } else {
                    // Default to dislike for unrated documents
                    dislikedDocs.push({...doc, feedback: 'dislike'});
                }
            });
            
            // Sort liked docs by timestamp (newest first)
            likedDocs.sort((a, b) => {
                const timeA = typeof a.timestamp === 'number' ? a.timestamp : new Date(a.timestamp).getTime();
                const timeB = typeof b.timestamp === 'number' ? b.timestamp : new Date(b.timestamp).getTime();
                return (isNaN(timeB) ? 0 : timeB) - (isNaN(timeA) ? 0 : timeA);
            });
            
            // Sort disliked docs by timestamp (newest first)
            dislikedDocs.sort((a, b) => {
                const timeA = typeof a.timestamp === 'number' ? a.timestamp : new Date(a.timestamp).getTime();
                const timeB = typeof b.timestamp === 'number' ? b.timestamp : new Date(b.timestamp).getTime();
                return (isNaN(timeB) ? 0 : timeB) - (isNaN(timeA) ? 0 : timeA);
            });
            
            // Create Liked section
            if (likedDocs.length > 0) {
                const likedSection = document.createElement('div');
                likedSection.className = 'luna-composer-history-section';
                
                const likedHeader = document.createElement('div');
                likedHeader.className = 'luna-composer-history-header';
                likedHeader.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #1f1d1a; cursor: pointer; user-select: none;';
                likedHeader.onclick = function() {
                    const content = this.nextElementSibling;
                    const arrow = this.querySelector('.luna-composer-section-arrow');
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        arrow.style.transform = 'rotate(180deg)';
                    } else {
                        content.style.display = 'none';
                        arrow.style.transform = 'rotate(0deg)';
                    }
                };
                
                const likedTitle = document.createElement('span');
                likedTitle.style.cssText = 'color: #fff4e9; font-weight: 600; font-size: 0.875rem;';
                likedTitle.textContent = 'Liked';
                
                const likedArrow = document.createElement('img');
                likedArrow.className = 'luna-composer-section-arrow';
                likedArrow.src = 'https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg';
                likedArrow.style.cssText = 'width: 12px; height: 12px; transition: transform 0.2s ease; transform: rotate(180deg); filter: brightness(0) invert(1);';
                
                likedHeader.appendChild(likedTitle);
                likedHeader.appendChild(likedArrow);
                
                const likedContent = document.createElement('ul');
                likedContent.className = 'luna-composer-history-content';
                likedContent.style.cssText = 'list-style: none; padding: 0; margin: 0;';
                
                // Add liked docs (already sorted, newest first)
                likedDocs.forEach(doc => {
                    const li = createHistoryItem(doc, editor, licenseKey);
                    likedContent.appendChild(li);
                });
                
                likedSection.appendChild(likedHeader);
                likedSection.appendChild(likedContent);
                historyList.appendChild(likedSection);
            }
            
            // Create Disliked section
            if (dislikedDocs.length > 0) {
                const dislikedSection = document.createElement('div');
                dislikedSection.className = 'luna-composer-history-section';
                
                const dislikedHeader = document.createElement('div');
                dislikedHeader.className = 'luna-composer-history-header';
                dislikedHeader.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #1f1d1a; cursor: pointer; user-select: none;';
                dislikedHeader.onclick = function() {
                    const content = this.nextElementSibling;
                    const arrow = this.querySelector('.luna-composer-section-arrow');
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        arrow.style.transform = 'rotate(180deg)';
                    } else {
                        content.style.display = 'none';
                        arrow.style.transform = 'rotate(0deg)';
                    }
                };
                
                const dislikedTitle = document.createElement('span');
                dislikedTitle.style.cssText = 'color: #fff4e9; font-weight: 600; font-size: 0.875rem;';
                dislikedTitle.textContent = 'Disliked';
                
                const dislikedArrow = document.createElement('img');
                dislikedArrow.className = 'luna-composer-section-arrow';
                dislikedArrow.src = 'https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg';
                dislikedArrow.style.cssText = 'width: 12px; height: 12px; transition: transform 0.2s ease; transform: rotate(0deg); filter: brightness(0) invert(1);';
                
                dislikedHeader.appendChild(dislikedTitle);
                dislikedHeader.appendChild(dislikedArrow);
                
                const dislikedContent = document.createElement('ul');
                dislikedContent.className = 'luna-composer-history-content';
                dislikedContent.style.cssText = 'list-style: none; padding: 0; margin: 0; display: none;';
                
                dislikedDocs.forEach(doc => {
                    const li = createHistoryItem(doc, editor, licenseKey);
                    dislikedContent.appendChild(li);
                });
                
                dislikedSection.appendChild(dislikedHeader);
                dislikedSection.appendChild(dislikedContent);
                historyList.appendChild(dislikedSection);
            }
            
            if (likedDocs.length === 0 && dislikedDocs.length === 0) {
                historyList.innerHTML = '<li class="vl-activity-empty">No saved documents.</li>';
            }
        }
        
        // Create a history item
        function createHistoryItem(doc, editor, licenseKey) {
            const li = document.createElement('li');
            li.className = 'vl-activity-item';
            li.style.cssText = 'padding: 12px; border-bottom: 1px solid #1f1d1a; cursor: pointer; transition: background 0.2s ease; position: relative;';
            li.setAttribute('data-document-id', doc.id);
            
            // Delete button (x icon) - shown on hover
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'luna-composer-history-delete';
            deleteBtn.innerHTML = '×';
            deleteBtn.style.cssText = 'position: absolute; top: 8px; right: 8px; background: transparent; border: none; color: #d63638; font-size: 1.25rem; cursor: pointer; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s ease; z-index: 10; line-height: 1;';
            deleteBtn.onclick = function(e) {
                e.stopPropagation();
                window.lunaComposerShowDeleteModalForHistory(doc.id, licenseKey);
            };
            
            li.onmouseover = function() { 
                this.style.background = '#2E2C2A';
                const btn = this.querySelector('.luna-composer-history-delete');
                if (btn) btn.style.opacity = '1';
            };
            li.onmouseout = function() { 
                this.style.background = 'transparent';
                const btn = this.querySelector('.luna-composer-history-delete');
                if (btn) btn.style.opacity = '0';
            };
            
            const title = document.createElement('div');
            title.style.cssText = 'color: #fff4e9; font-weight: 600; font-size: 0.8rem; margin-bottom: 0; padding-right: 30px;';
            title.textContent = doc.prompt || 'Untitled Document';
            
            const timestamp = document.createElement('div');
            timestamp.style.cssText = 'color: #5A5753; font-size: 0.7rem;';
            // Handle timestamp - could be number (milliseconds) or date string
            let date;
            if (typeof doc.timestamp === 'number') {
                date = new Date(doc.timestamp);
            } else if (typeof doc.timestamp === 'string') {
                date = new Date(doc.timestamp);
            } else {
                // Fallback to current date if timestamp is invalid
                date = new Date();
            }
            
            // Check if date is valid
            if (isNaN(date.getTime())) {
                // If invalid, try to get from document data
                const docKey = `luna_composer_doc_${doc.id}`;
                const savedDoc = localStorage.getItem(docKey);
                if (savedDoc) {
                    try {
                        const docData = JSON.parse(savedDoc);
                        if (docData.timestamp) {
                            date = new Date(docData.timestamp);
                        }
                    } catch (e) {
                        // Use current date as fallback
                        date = new Date();
                    }
                } else {
                    date = new Date();
                }
            }
            
            // Format date properly
            const dateStr = date.toLocaleDateString();
            const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            timestamp.textContent = dateStr + ' ' + timeStr;
            
            li.appendChild(title);
            li.appendChild(timestamp);
            li.appendChild(deleteBtn);
            
            li.onclick = async function() {
                    // Try to load from WordPress first, then localStorage
                    try {
                        const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}&document_id=${encodeURIComponent(doc.id)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.documents && data.documents.length > 0) {
                                const docData = data.documents[0];
                                if (docData.content) {
                                    editor.innerHTML = docData.content;
                                    editor.setAttribute('data-document-id', doc.id);
                                    if (docData.prompt) {
                                        editor.setAttribute('data-prompt', docData.prompt);
                                    }
                                    
                                    // Show and update heart icon state
                                    setTimeout(() => {
                                        const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                                        if (heartBtn) {
                                            heartBtn.style.display = 'flex';
                                        }
                                        window.lunaComposerUpdateHeartState();
                                    }, 100);
                                    
                                    // Update URL
                                    const currentParams = new URLSearchParams(window.location.search);
                                    const currentLicense = currentParams.get('license') || '';
                                    if (currentLicense) {
                                        const baseLicense = currentLicense.split('/luna/compose/')[0];
                                        const newUrl = new URL(window.location.href);
                                        newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + doc.id);
                                        window.history.replaceState({}, '', newUrl.toString());
                                    }
                                    
                                    // Cache in localStorage with feedback
                                    const docKey = `luna_composer_doc_${doc.id}`;
                                    localStorage.setItem(docKey, JSON.stringify({
                                        id: doc.id,
                                        content: docData.content,
                                        prompt: docData.prompt,
                                        timestamp: docData.timestamp,
                                        license: licenseKey,
                                        feedback: docData.feedback || 'dislike' // Include feedback from WordPress
                                    }));
                                    
                                    // Also store feedback separately
                                    if (docData.feedback) {
                                        const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                        localStorage.setItem(feedbackKey, JSON.stringify({
                                            feedback: docData.feedback,
                                            timestamp: Date.now()
                                        }));
                                    }
                                    
                                    // Scroll editor to top
                                    editor.scrollTop = 0;
                                    return;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not fetch document from WordPress:', e);
                    }
                    
                    // Fallback to localStorage
                    const docKey = `luna_composer_doc_${doc.id}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            if (docData.content) {
                                editor.innerHTML = docData.content;
                                editor.setAttribute('data-document-id', doc.id);
                                if (docData.prompt) {
                                    editor.setAttribute('data-prompt', docData.prompt);
                                }
                                
                                // Store feedback if present
                                if (docData.feedback) {
                                    const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                    localStorage.setItem(feedbackKey, JSON.stringify({
                                        feedback: docData.feedback,
                                        timestamp: Date.now()
                                    }));
                                }
                                
                                // Show and update heart icon state
                                setTimeout(() => {
                                    const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                                    if (heartBtn) {
                                        heartBtn.style.display = 'flex';
                                    }
                                    window.lunaComposerUpdateHeartState();
                                }, 100);
                                
                                // Update URL
                                const currentParams = new URLSearchParams(window.location.search);
                                const currentLicense = currentParams.get('license') || '';
                                if (currentLicense) {
                                    const baseLicense = currentLicense.split('/luna/compose/')[0];
                                    const newUrl = new URL(window.location.href);
                                    newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + doc.id);
                                    window.history.replaceState({}, '', newUrl.toString());
                                }
                                
                                // Scroll editor to top
                                editor.scrollTop = 0;
                            }
                        } catch (e) {
                            console.error('[Luna Composer] Could not load document:', e);
                        }
                    }
                };
                
                return li;
        }
        
        // Find and Replace functions - make globally accessible
        window.lunaComposerShowFindReplace = function() {
            console.log('[Luna Composer] Showing find/replace modal');
            const modal = document.getElementById('luna-composer-find-replace-modal');
            if (modal) {
                modal.style.display = 'flex';
                const findInput = document.getElementById('luna-composer-find-text');
                if (findInput) {
                    findInput.focus();
                }
            } else {
                console.error('[Luna Composer] Find/replace modal not found');
            }
        };
        
        window.lunaComposerCloseFindReplace = function() {
            console.log('[Luna Composer] Closing find/replace modal');
            const modal = document.getElementById('luna-composer-find-replace-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.lunaComposerExecuteFindReplace = function() {
            console.log('[Luna Composer] Executing find/replace');
            const findText = document.getElementById('luna-composer-find-text');
            const replaceText = document.getElementById('luna-composer-replace-text');
            const editor = document.getElementById('luna-composer-editor');
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            if (!findText || !findText.value) {
                alert('Please enter text to find');
                return;
            }
            
            // Get plain text content from editor (not HTML)
            let content = editor.innerText || editor.textContent || '';
            const findValue = findText.value;
            const replaceValue = replaceText ? replaceText.value : '';
            
            // Replace all occurrences (case-insensitive)
            const regex = new RegExp(findValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            content = content.replace(regex, replaceValue);
            
            // Update editor with new content
            editor.innerText = content;
            editor.textContent = content;
            
            console.log('[Luna Composer] Find/replace completed');
            window.lunaComposerCloseFindReplace();
        };
        
        // Share functions - make globally accessible
        window.lunaComposerShowShareModal = async function() {
            console.log('[Luna Composer] Showing share modal');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            const content = editor.innerHTML;
            const prompt = editor.getAttribute('data-prompt') || '';
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                alert('Please save your document before sharing.');
                return;
            }
            
            // Generate unique share ID (longer for uniqueness)
            const shareId = 'lcid_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 10);
            
            // Save shared document to WordPress backend
            try {
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/share', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        document_id: documentId,
                        share_id: shareId,
                        content: content,
                        prompt: prompt
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[Luna Composer] Share link created:', data);
                } else {
                    console.warn('[Luna Composer] Failed to create share link:', response.status);
                }
            } catch (e) {
                console.error('[Luna Composer] Error creating share link:', e);
            }
            
            // Generate secure shareable URL (without license key)
            const shareUrl = `https://supercluster.visiblelight.ai/invite_from/luna/compose/${shareId}`;
            
            // Show modal and set link
            const modal = document.getElementById('luna-composer-share-modal');
            const linkInput = document.getElementById('luna-composer-share-link-input');
            if (modal && linkInput) {
                linkInput.value = shareUrl;
                modal.style.display = 'flex';
            } else {
                console.error('[Luna Composer] Share modal or input not found');
            }
        };
        
        window.lunaComposerCloseShareModal = function() {
            console.log('[Luna Composer] Closing share modal');
            const modal = document.getElementById('luna-composer-share-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.lunaComposerSelectShareAction = function(action) {
            console.log('[Luna Composer] Selecting share action:', action);
            const copyBtn = document.getElementById('luna-composer-share-action-copy');
            const postBtn = document.getElementById('luna-composer-share-action-post');
            const copySection = document.getElementById('luna-composer-share-copy-section');
            const postSection = document.getElementById('luna-composer-share-post-section');
            
            if (action === 'copy') {
                if (copyBtn) copyBtn.classList.add('active');
                if (postBtn) postBtn.classList.remove('active');
                if (copySection) copySection.style.display = 'block';
                if (postSection) postSection.style.display = 'none';
            } else if (action === 'post') {
                if (copyBtn) copyBtn.classList.remove('active');
                if (postBtn) postBtn.classList.add('active');
                if (copySection) copySection.style.display = 'none';
                if (postSection) postSection.style.display = 'block';
            }
        };
        
        window.lunaComposerCopyShareLink = function() {
            console.log('[Luna Composer] Copying share link');
            const linkInput = document.getElementById('luna-composer-share-link-input');
            if (!linkInput) {
                console.error('[Luna Composer] Share link input not found');
                return;
            }
            
            const shareUrl = linkInput.value;
            
            // Copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    const copyBtn = document.getElementById('luna-composer-share-copy-btn');
                    if (copyBtn) {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = 'Copied!';
                        copyBtn.style.background = '#1f1d1a';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.style.background = '#fff4e9';
                        }, 2000);
                    }
                    console.log('[Luna Composer] Link copied:', shareUrl);
                }).catch((err) => {
                    console.error('[Luna Composer] Clipboard error:', err);
                    // Fallback
                    linkInput.select();
                    document.execCommand('copy');
                    alert('Shareable link copied to clipboard!');
                });
            } else {
                // Fallback for older browsers
                linkInput.select();
                document.execCommand('copy');
                alert('Shareable link copied to clipboard!');
            }
        };
        
        window.lunaComposerCreatePost = async function(platform) {
            console.log('[Luna Composer] Creating post on platform:', platform);
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            let content = editor.innerHTML;
            const prompt = editor.getAttribute('data-prompt') || '';
            
            // Validate required fields
            if (!licenseKey) {
                console.error('[Luna Composer] License key not found');
                alert('License key not found. Please refresh the page and try again.');
                return;
            }
            
            // If documentId is missing, generate one or use a temporary one
            let finalDocumentId = documentId;
            if (!finalDocumentId || finalDocumentId === '') {
                finalDocumentId = 'doc_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
                editor.setAttribute('data-document-id', finalDocumentId);
                console.log('[Luna Composer] Generated new document ID:', finalDocumentId);
            }
            
            // Clean and validate content
            // Remove empty paragraphs and whitespace-only content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const textContent = tempDiv.textContent || tempDiv.innerText || '';
            const trimmedText = textContent.trim();
            
            // If content is empty or only whitespace, use a default message
            if (!trimmedText || trimmedText === '') {
                console.warn('[Luna Composer] Content is empty, using default content');
                content = '<p>New post from Luna Composer</p>';
            }
            
            // Strip HTML tags for plain text content (for Medium and LinkedIn)
            const plainText = trimmedText || 'New post from Luna Composer';
            
            console.log('[Luna Composer] Post data:', {
                license: licenseKey ? 'present' : 'missing',
                document_id: finalDocumentId,
                title: prompt || 'New Post from Luna Composer',
                content_length: content.length,
                has_content: content.length > 0
            });
            
            if (platform === 'wp') {
                // Create WordPress post as draft
                try {
                    const postData = {
                        license: licenseKey,
                        document_id: finalDocumentId,
                        title: prompt || 'New Post from Luna Composer',
                        content: content,
                        status: 'draft'
                    };
                    
                    console.log('[Luna Composer] Sending post data:', postData);
                    
                    const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/create-post', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify(postData)
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('[Luna Composer] WordPress post created:', data);
                        if (data.post_id && data.edit_url) {
                            // Open WordPress admin edit page in new tab
                            window.open(data.edit_url, '_blank');
                            alert('WordPress post created as draft! Opening in WP Admin...');
                            window.lunaComposerCloseShareModal();
                        } else {
                            alert('Post created successfully! Post ID: ' + (data.post_id || 'N/A'));
                        }
                    } else {
                        const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
                        console.error('[Luna Composer] Failed to create WordPress post:', response.status, errorData);
                        alert('Failed to create WordPress post: ' + (errorData.message || 'Unknown error'));
                    }
                } catch (e) {
                    console.error('[Luna Composer] Error creating WordPress post:', e);
                    alert('Error creating WordPress post. Please try again.');
                }
            } else if (platform === 'medium') {
                // Open Medium.com in new tab
                // Medium doesn't have a direct API for creating posts, so we'll open the new post page
                const mediumUrl = 'https://medium.com/new-story';
                window.open(mediumUrl, '_blank');
                
                // Copy content to clipboard so user can paste it
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(plainText).then(() => {
                        alert('Content copied to clipboard! Opening Medium.com... Paste your content when ready.');
                    }).catch(() => {
                        alert('Opening Medium.com... Please copy your content manually.');
                    });
                } else {
                    alert('Opening Medium.com... Please copy your content manually.');
                }
                window.lunaComposerCloseShareModal();
            } else if (platform === 'linkedin') {
                // Open LinkedIn post composer
                // LinkedIn doesn't have a public API for creating posts, so we'll open the post composer
                const linkedinUrl = 'https://www.linkedin.com/feed/';
                window.open(linkedinUrl, '_blank');
                
                // Copy content to clipboard so user can paste it
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(plainText).then(() => {
                        alert('Content copied to clipboard! Opening LinkedIn... Paste your content when ready.');
                    }).catch(() => {
                        alert('Opening LinkedIn... Please copy your content manually.');
                    });
                } else {
                    alert('Opening LinkedIn... Please copy your content manually.');
                }
                window.lunaComposerCloseShareModal();
            }
        };
        
        window.lunaComposerEmail = function() {
            console.log('[Luna Composer] Opening email client');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const content = editor.innerText || editor.textContent || '';
            const subject = encodeURIComponent('Luna Composer Document');
            const body = encodeURIComponent(content);
            const mailtoLink = `mailto:?subject=${subject}&body=${body}`;
            
            window.location.href = mailtoLink;
            window.lunaComposerToggleShareMenu();
        };
        
        // Export functions - make globally accessible
        window.lunaComposerToggleExportMenu = function() {
            console.log('[Luna Composer] Toggling export menu');
            const menu = document.getElementById('luna-composer-export-menu');
            const btn = document.getElementById('luna-composer-export-btn');
            if (menu && btn) {
                const isVisible = menu.style.display === 'block' || menu.style.display === '';
                if (isVisible) {
                    menu.style.display = 'none';
                } else {
                    // Calculate position relative to button
                    const btnRect = btn.getBoundingClientRect();
                    menu.style.position = 'fixed';
                    menu.style.display = 'block';
                    // Force backdrop-filter styles
                    menu.style.setProperty('background', 'rgba(0,0,0,0.85)', 'important');
                    menu.style.setProperty('backdrop-filter', 'blur(12px)', 'important');
                    menu.style.setProperty('-webkit-backdrop-filter', 'blur(12px)', 'important');
                    menu.style.setProperty('z-index', '10000', 'important');
                }
            } else {
                console.error('[Luna Composer] Export menu or button not found');
            }
        };
        
        window.lunaComposerExportTo = function(format) {
            console.log('[Luna Composer] Exporting to:', format);
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const content = editor.innerText || editor.textContent || '';
            const htmlContent = editor.innerHTML;
            
            if (format === 'google-docs') {
                // Open Google Docs in new tab
                const url = 'https://docs.google.com/document/create?usp=sharing';
                window.open(url, '_blank');
                // Note: Google Docs doesn't support direct content injection via URL
                // User will need to paste content manually
                alert('Google Docs opened in a new tab. Please paste your content manually.');
            } else if (format === 'csv') {
                // Export as CSV
                const csvContent = '"Content"\n"' + content.replace(/"/g, '""') + '"';
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'luna-composer-' + Date.now() + '.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('[Luna Composer] CSV exported');
            } else if (format === 'pdf') {
                // Export as PDF with exact formatting using browser print
                const printWindow = window.open('', '_blank');
                if (!printWindow) {
                    alert('Please allow popups to export as PDF');
                    return;
                }
                
                // Create a styled document that preserves formatting
                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <title>Luna Composer Export</title>
                            <meta charset="utf-8">
                            <style>
                                body { 
                                    font-family: Arial, sans-serif; 
                                    padding: 40px; 
                                    color: #000; 
                                    background: #fff;
                                    line-height: 1.6;
                                }
                                .content { 
                                    white-space: pre-wrap;
                                    word-wrap: break-word;
                                }
                                p { margin: 1em 0; }
                                strong { font-weight: bold; }
                                em { font-style: italic; }
                                u { text-decoration: underline; }
                                s { text-decoration: line-through; }
                                ul, ol { margin: 1em 0; padding-left: 2em; }
                            </style>
                        </head>
                        <body>
                            <div class="content">${htmlContent}</div>
                        </body>
                    </html>
                `);
                printWindow.document.close();
                
                // Wait for content to load, then print
                setTimeout(() => {
                    printWindow.print();
                }, 250);
                console.log('[Luna Composer] PDF export initiated');
            } else if (format === 'mp3') {
                // Export as MP3 audio file
                if (!content.trim()) {
                    alert('No text to convert to audio.');
                    return;
                }
                
                // Show loading message
                const exportBtn = document.getElementById('luna-composer-export-btn');
                if (exportBtn) {
                    const originalText = exportBtn.textContent;
                    exportBtn.textContent = 'Generating audio...';
                    exportBtn.disabled = true;
                    
                    try {
                        // Use Web Speech API to generate audio
                        const synth = window.speechSynthesis;
                        if (!synth) {
                            throw new Error('Speech synthesis not supported');
                        }
                        
                        // Create utterance
                        const utterance = new SpeechSynthesisUtterance(content);
                        utterance.lang = 'en-US';
                        utterance.rate = 1.0;
                        utterance.pitch = 1.0;
                        utterance.volume = 1.0;
                        
                        // Use MediaRecorder API to record the speech
                        // Note: This requires a MediaStream, which we'll create from the audio context
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const destination = audioContext.createMediaStreamDestination();
                        
                        // Create a MediaRecorder to capture the audio
                        const mediaRecorder = new MediaRecorder(destination.stream);
                        const chunks = [];
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                chunks.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const blob = new Blob(chunks, { type: 'audio/webm' });
                            
                            // Convert WebM to MP3 using a library or service
                            // For now, we'll download as WebM and note that MP3 conversion requires server-side processing
                            // In a production environment, you'd send this to a server to convert to MP3
                            
                            // For client-side conversion, we can use a library like lamejs
                            // But for simplicity, we'll download as WebM and note the limitation
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'luna-composer-' + Date.now() + '.webm';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            // Note: WebM to MP3 conversion typically requires server-side processing
                            // For now, downloading as WebM. To get MP3, you'd need to:
                            // 1. Send the WebM blob to a server endpoint
                            // 2. Convert using ffmpeg or similar tool
                            // 3. Return the MP3 file
                            
                            alert('Audio exported as WebM. Note: MP3 conversion requires server-side processing. The file can be converted using online tools or server-side conversion.');
                            
                            if (exportBtn) {
                                exportBtn.textContent = originalText;
                                exportBtn.disabled = false;
                            }
                        };
                        
                        // Start recording
                        mediaRecorder.start();
                        
                        // Speak the text
                        utterance.onend = () => {
                            setTimeout(() => {
                                mediaRecorder.stop();
                            }, 500); // Small delay to ensure all audio is captured
                        };
                        
                        synth.speak(utterance);
                        
                    } catch (error) {
                        console.error('[Luna Composer] Error generating audio:', error);
                        alert('Error generating audio file. Please try again or use a different browser.');
                        if (exportBtn) {
                            exportBtn.textContent = originalText;
                            exportBtn.disabled = false;
                        }
                    }
                }
            }
            
            window.lunaComposerToggleExportMenu();
        };
        
        // Dictate functionality
        let recognition = null;
        let isDictating = false;
        
        window.lunaComposerToggleDictate = function() {
            const editor = document.getElementById('luna-composer-editor');
            const dictateBtn = document.getElementById('luna-composer-dictate-btn');
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            // Check if browser supports Speech Recognition
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                alert('Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari.');
                return;
            }
            
            if (!isDictating) {
                // Start dictation
                if (!recognition) {
                    recognition = new SpeechRecognition();
                    recognition.continuous = true;
                    recognition.interimResults = true;
                    recognition.lang = 'en-US';
                    
                    recognition.onresult = function(event) {
                        let interimTranscript = '';
                        let finalTranscript = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript + ' ';
                            } else {
                                interimTranscript += transcript;
                            }
                        }
                        
                        if (finalTranscript) {
                            // Insert final transcript at cursor position
                            const selection = window.getSelection();
                            if (selection.rangeCount > 0) {
                                const range = selection.getRangeAt(0);
                                range.deleteContents();
                                const textNode = document.createTextNode(finalTranscript);
                                range.insertNode(textNode);
                                range.setStartAfter(textNode);
                                range.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(range);
                            } else {
                                // Append to end if no selection
                                editor.textContent += finalTranscript;
                            }
                        }
                    };
                    
                    recognition.onerror = function(event) {
                        console.error('[Luna Composer] Speech recognition error:', event.error);
                        if (event.error === 'no-speech') {
                            alert('No speech detected. Please try again.');
                        } else if (event.error === 'not-allowed') {
                            alert('Microphone permission denied. Please allow microphone access.');
                        }
                        isDictating = false;
                        if (dictateBtn) {
                            dictateBtn.textContent = 'Dictate';
                            dictateBtn.style.background = '#2E2C2A50';
                        }
                    };
                    
                    recognition.onend = function() {
                        isDictating = false;
                        if (dictateBtn) {
                            dictateBtn.textContent = 'Dictate';
                            dictateBtn.style.background = '#2E2C2A50';
                        }
                    };
                }
                
                try {
                    recognition.start();
                    isDictating = true;
                    if (dictateBtn) {
                        dictateBtn.textContent = 'Stop Dictating';
                        dictateBtn.style.background = '#d63638';
                    }
                } catch (e) {
                    console.error('[Luna Composer] Error starting recognition:', e);
                    alert('Error starting speech recognition. Please try again.');
                }
            } else {
                // Stop dictation
                if (recognition) {
                    recognition.stop();
                    isDictating = false;
                    if (dictateBtn) {
                        dictateBtn.textContent = 'Dictate';
                        dictateBtn.style.background = '#2E2C2A50';
                    }
                }
            }
        };
        
        // Audio readback functionality
        let synth = window.speechSynthesis;
        let isReading = false;
        let currentUtterance = null;
        
        window.lunaComposerToggleReadback = function() {
            const editor = document.getElementById('luna-composer-editor');
            const readbackBtn = document.getElementById('luna-composer-readback-btn');
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            if (!synth) {
                alert('Speech synthesis is not supported in your browser.');
                return;
            }
            
            if (isReading) {
                // Stop reading
                synth.cancel();
                isReading = false;
                if (readbackBtn) {
                    readbackBtn.textContent = 'Read Aloud';
                    readbackBtn.style.background = '#2E2C2A50';
                }
            } else {
                // Start reading
                const text = editor.innerText || editor.textContent || '';
                if (!text.trim()) {
                    alert('No text to read.');
                    return;
                }
                
                // Cancel any ongoing speech
                synth.cancel();
                
                currentUtterance = new SpeechSynthesisUtterance(text);
                currentUtterance.lang = 'en-US';
                currentUtterance.rate = 1.0;
                currentUtterance.pitch = 1.0;
                currentUtterance.volume = 1.0;
                
                currentUtterance.onend = function() {
                    isReading = false;
                    if (readbackBtn) {
                        readbackBtn.textContent = 'Read Aloud';
                        readbackBtn.style.background = '#2E2C2A50';
                    }
                };
                
                currentUtterance.onerror = function(event) {
                    console.error('[Luna Composer] Speech synthesis error:', event.error);
                    isReading = false;
                    if (readbackBtn) {
                        readbackBtn.textContent = 'Read Aloud';
                        readbackBtn.style.background = '#2E2C2A50';
                    }
                };
                
                synth.speak(currentUtterance);
                isReading = true;
                if (readbackBtn) {
                    readbackBtn.textContent = 'Stop Reading';
                    readbackBtn.style.background = '#d63638';
                }
            }
        };
        
        // Delete functions - make globally accessible
        window.lunaComposerShowDeleteModal = function() {
            console.log('[Luna Composer] Showing delete modal');
            const modal = document.getElementById('luna-composer-delete-modal');
            if (modal) {
                modal.style.display = 'flex';
                // Reset delete button state
                const deleteBtn = document.getElementById('luna-composer-delete-confirm');
                if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.style.opacity = '0.5';
                    deleteBtn.style.cursor = 'not-allowed';
                }
            } else {
                console.error('[Luna Composer] Delete modal not found');
            }
        };
        
        window.lunaComposerCloseDeleteModal = function() {
            console.log('[Luna Composer] Closing delete modal');
            const modal = document.getElementById('luna-composer-delete-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.lunaComposerDownloadBackup = function() {
            console.log('[Luna Composer] Downloading backup');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const content = editor.innerText || editor.textContent || '';
            const htmlContent = editor.innerHTML;
            
            // Export as PDF with exact formatting using browser print
            const printWindow = window.open('', '_blank');
            if (!printWindow) {
                alert('Please allow popups to download backup');
                return;
            }
            
            // Create a styled document that preserves formatting
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                    <head>
                        <title>Luna Composer Backup</title>
                        <meta charset="utf-8">
                        <style>
                            body { 
                                font-family: Arial, sans-serif; 
                                padding: 40px; 
                                color: #000; 
                                background: #fff;
                                line-height: 1.6;
                            }
                            .content { 
                                white-space: pre-wrap;
                                word-wrap: break-word;
                            }
                            p { margin: 1em 0; }
                            strong { font-weight: bold; }
                            em { font-style: italic; }
                            u { text-decoration: underline; }
                            s { text-decoration: line-through; }
                            ul, ol { margin: 1em 0; padding-left: 2em; }
                        </style>
                    </head>
                    <body>
                        <div class="content">${htmlContent}</div>
                    </body>
                </html>
            `);
            printWindow.document.close();
            
            // Wait for content to load, then print
            setTimeout(() => {
                printWindow.print();
            }, 250);
            
            // Enable delete button after download
            const deleteBtn = document.getElementById('luna-composer-delete-confirm');
            if (deleteBtn) {
                deleteBtn.disabled = false;
                deleteBtn.style.opacity = '1';
                deleteBtn.style.cursor = 'pointer';
            }
        };
        
        window.lunaComposerDeleteDocument = async function() {
            console.log('[Luna Composer] Deleting document');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                return;
            }
            
            try {
                // Delete from WordPress
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        document_id: documentId
                    })
                });
                
                if (response.ok) {
                    console.log('[Luna Composer] Document deleted from WordPress');
                } else {
                    console.warn('[Luna Composer] Failed to delete from WordPress:', response.status);
                }
            } catch (e) {
                console.warn('[Luna Composer] Error deleting from WordPress:', e);
            }
            
            // Delete from localStorage
            const docKey = `luna_composer_doc_${documentId}`;
            localStorage.removeItem(docKey);
            
            // Remove from history
            const historyKey = `luna_composer_history_${licenseKey}`;
            const historyStr = localStorage.getItem(historyKey);
            if (historyStr) {
                try {
                    const history = JSON.parse(historyStr);
                    const filteredHistory = history.filter(doc => doc.id !== documentId);
                    localStorage.setItem(historyKey, JSON.stringify(filteredHistory));
                } catch (e) {
                    console.warn('[Luna Composer] Could not update history:', e);
                }
            }
            
            // Add activity notification to main Supercluster page (not on /luna/compose/)
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            const isLunaComposePage = currentLicense.includes('/luna/compose/');
            
            if (!isLunaComposePage) {
                // Add to activity stream
                const activityList = document.getElementById('recentActivityList');
                if (activityList) {
                    const now = new Date();
                    const activityItem = document.createElement('li');
                    activityItem.className = 'vl-activity-item';
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.id = 'activityTimeStamp';
                    timeSpan.textContent = now.toLocaleString();
                    activityItem.appendChild(timeSpan);
                    activityItem.appendChild(document.createElement('br'));
                    
                    const labelText = document.createTextNode('Luna Compose Document was deleted');
                    activityItem.appendChild(labelText);
                    
                    // Remove "No recent activity" if present
                    const emptyItem = activityList.querySelector('.vl-activity-empty');
                    if (emptyItem) {
                        emptyItem.remove();
                    }
                    
                    // Insert at the beginning
                    activityList.insertBefore(activityItem, activityList.firstChild);
                    
                    // Keep only last 10 items
                    const items = activityList.querySelectorAll('.vl-activity-item');
                    if (items.length > 10) {
                        for (let i = 10; i < items.length; i++) {
                            items[i].remove();
                        }
                    }
                }
            }
            
            // Close modal
            window.lunaComposerCloseDeleteModal();
            
            // Reload composer screen
            const baseLicense = currentLicense.split('/luna/compose/')[0];
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('license', baseLicense + '/luna/compose/');
            window.location.href = newUrl.toString();
        };
        
        // Toggle heart icon (like/dislike)
        window.lunaComposerToggleHeart = async function() {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                return;
            }
            
            // Check current state
            const heartIcon = document.getElementById('luna-composer-heart-icon');
            const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
            
            if (!heartIcon || !heartBtn) {
                console.error('[Luna Composer] Heart icon or button not found');
                return;
            }
            
            // Determine current state from icon src
            const currentSrc = heartIcon.getAttribute('src');
            const isLiked = currentSrc.includes('heart-solid-full.svg');
            const newFeedbackType = isLiked ? 'dislike' : 'like';
            
            // Call the main feedback function (which will update state)
            await window.lunaComposerSubmitFeedback(newFeedbackType);
            
            // Update icon based on new state immediately
            if (newFeedbackType === 'like') {
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-solid-full.svg');
                heartBtn.style.background = '#000000';
                heartBtn.style.borderColor = '#1f1d1a';
            } else {
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg');
                heartBtn.style.background = '#2E2C2A50';
                heartBtn.style.borderColor = '#1f1d1a';
            }
            
            // Reload history to reflect changes
            setTimeout(() => {
                if (typeof loadLunaComposerHistory === 'function') {
                loadLunaComposerHistory();
                }
            }, 500);
        };
        
        // Initialize heart icon state when document loads
        window.lunaComposerUpdateHeartState = async function() {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            
            if (!documentId || !licenseKey) return;
            
            const heartIcon = document.getElementById('luna-composer-heart-icon');
            const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
            
            if (!heartIcon || !heartBtn) return;
            
            // First, try to fetch feedback from WordPress (most reliable - survives cache clears)
            let isLiked = false;
            try {
                const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}&document_id=${encodeURIComponent(documentId)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.documents && data.documents.length > 0) {
                        const docData = data.documents[0];
                        if (docData.feedback === 'like') {
                            isLiked = true;
                            // Update localStorage with WordPress data
                            const feedbackKey = `luna_composer_feedback_${documentId}`;
                            localStorage.setItem(feedbackKey, JSON.stringify({
                                feedback: 'like',
                                timestamp: Date.now()
                            }));
                            const docKey = `luna_composer_doc_${documentId}`;
                            const savedDoc = localStorage.getItem(docKey);
                            if (savedDoc) {
                                try {
                                    const docDataLocal = JSON.parse(savedDoc);
                                    docDataLocal.feedback = 'like';
                                    localStorage.setItem(docKey, JSON.stringify(docDataLocal));
                                } catch (e) {
                                    console.warn('[Luna Composer] Could not update doc data:', e);
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn('[Luna Composer] Could not fetch feedback from WordPress:', e);
            }
            
            // Fallback to localStorage if WordPress fetch failed
            if (!isLiked) {
                const feedbackKey = `luna_composer_feedback_${documentId}`;
                const feedbackStr = localStorage.getItem(feedbackKey);
                
                if (feedbackStr) {
                    try {
                        const feedbackData = JSON.parse(feedbackStr);
                        isLiked = feedbackData.feedback === 'like';
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse feedback:', e);
                    }
                }
                
                // Also check document data
                if (!isLiked) {
                    const docKey = `luna_composer_doc_${documentId}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            isLiked = docData.feedback === 'like';
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse doc data:', e);
                        }
                    }
                }
            }
            
            // Update icon and button state
            if (isLiked) {
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-solid-full.svg');
                heartBtn.style.background = '#000000';
                heartBtn.style.borderColor = '#1f1d1a';
            } else {
                // Default to dislike state
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg');
                heartBtn.style.background = '#2E2C2A50';
                heartBtn.style.borderColor = '#1f1d1a';
            }
        };
        
        // Show delete modal for history item
        window.lunaComposerShowDeleteModalForHistory = function(documentId, licenseKey) {
            console.log('[Luna Composer] Showing delete modal for history item:', documentId);
            
            // Store document ID and license key for deletion
            window.lunaComposerPendingDelete = {
                documentId: documentId,
                licenseKey: licenseKey
            };
            
            const modal = document.getElementById('luna-composer-delete-modal');
            if (modal) {
                modal.style.display = 'flex';
                // Reset delete button state
                const deleteBtn = document.getElementById('luna-composer-delete-confirm');
                if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.style.opacity = '0.5';
                    deleteBtn.style.cursor = 'not-allowed';
                }
            } else {
                console.error('[Luna Composer] Delete modal not found');
            }
        };
        
        // Override download backup for history items
        const originalDownloadBackup = window.lunaComposerDownloadBackup;
        window.lunaComposerDownloadBackup = function() {
            // If we have a pending delete from history, load that document first
            if (window.lunaComposerPendingDelete) {
                const { documentId, licenseKey } = window.lunaComposerPendingDelete;
                
                // Try to load document content
                const docKey = `luna_composer_doc_${documentId}`;
                const savedDoc = localStorage.getItem(docKey);
                
                if (savedDoc) {
                    try {
                        const docData = JSON.parse(savedDoc);
                        if (docData.content) {
                            // Temporarily set editor content for backup
                            const editor = document.getElementById('luna-composer-editor');
                            if (editor) {
                                const originalContent = editor.innerHTML;
                                editor.innerHTML = docData.content;
                                
                                // Call original function
                                if (originalDownloadBackup) {
                                    originalDownloadBackup();
                                }
                                
                                // Restore original content after a delay
                                setTimeout(() => {
                                    editor.innerHTML = originalContent;
                                }, 1000);
                                
                                return;
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse doc data for backup:', e);
                    }
                }
            }
            
            // Otherwise, use original function
            if (originalDownloadBackup) {
                return originalDownloadBackup();
            }
        };
        
        // Override delete document function to handle history items
        const originalDeleteDocument = window.lunaComposerDeleteDocument;
        window.lunaComposerDeleteDocument = async function() {
            // Check if we're deleting from history
            if (window.lunaComposerPendingDelete) {
                const { documentId, licenseKey } = window.lunaComposerPendingDelete;
                
                try {
                    // Delete from WordPress
                    const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/delete', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            license: licenseKey,
                            document_id: documentId
                        })
                    });
                    
                    if (response.ok) {
                        console.log('[Luna Composer] Document deleted from WordPress');
                    } else {
                        console.warn('[Luna Composer] Failed to delete from WordPress:', response.status);
                    }
                } catch (e) {
                    console.warn('[Luna Composer] Error deleting from WordPress:', e);
                }
                
                // Delete from localStorage
                const docKey = `luna_composer_doc_${documentId}`;
                localStorage.removeItem(docKey);
                
                // Remove feedback
                const feedbackKey = `luna_composer_feedback_${documentId}`;
                localStorage.removeItem(feedbackKey);
                
                // Remove from history
                const historyKey = `luna_composer_history_${licenseKey}`;
                const historyStr = localStorage.getItem(historyKey);
                if (historyStr) {
                    try {
                        const history = JSON.parse(historyStr);
                        const filteredHistory = history.filter(doc => doc.id !== documentId);
                        localStorage.setItem(historyKey, JSON.stringify(filteredHistory));
                    } catch (e) {
                        console.warn('[Luna Composer] Could not update history:', e);
                    }
                }
                
                // Close modal
                window.lunaComposerCloseDeleteModal();
                
                // Clear pending delete
                window.lunaComposerPendingDelete = null;
                
                // Reload history
                setTimeout(() => {
                    loadLunaComposerHistory();
                }, 300);
                
                return;
            }
            
            // Otherwise, use original function
            if (originalDeleteDocument) {
                return originalDeleteDocument();
            }
        };
        
        window.lunaComposerSubmitFeedback = async function(feedbackType) {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            const content = editor.innerHTML || editor.innerText || editor.textContent || '';
            const prompt = editor.getAttribute('data-prompt') || '';
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                return;
            }
            
            try {
                // Save feedback to WordPress
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/feedback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        document_id: documentId,
                        feedback_type: feedbackType,
                        prompt: prompt,
                        content: content.substring(0, 500) // First 500 chars for context
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[Luna Composer] Feedback saved:', data);
                    
                    // Store feedback in localStorage for history categorization
                    const feedbackKey = `luna_composer_feedback_${documentId}`;
                    localStorage.setItem(feedbackKey, JSON.stringify({
                        feedback: feedbackType,
                        timestamp: Date.now()
                    }));
                    
                    // Also update document data if it exists
                    const docKey = `luna_composer_doc_${documentId}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            docData.feedback = feedbackType;
                            localStorage.setItem(docKey, JSON.stringify(docData));
                        } catch (e) {
                            console.warn('[Luna Composer] Could not update doc data:', e);
                        }
                    }
                    
                    // Feedback saved successfully (heart button will update its state)
                    
                    // Update history immediately to include current document if not already present
                    const currentDocId = documentId;
                    const currentLicense = licenseKey;
                    const currentPrompt = prompt || 'Untitled Document';
                    const currentContent = content;
                    
                    if (currentDocId && currentLicense) {
                        // Add/update document in history
                        const historyKey = `luna_composer_history_${currentLicense}`;
                        let history = [];
                        try {
                            const historyStr = localStorage.getItem(historyKey);
                            if (historyStr) {
                                history = JSON.parse(historyStr);
                            }
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse history:', e);
                        }
                        
                        // Find or add current document
                        const existingIndex = history.findIndex(doc => doc.id === currentDocId);
                        if (existingIndex !== -1) {
                            history[existingIndex].prompt = currentPrompt;
                            history[existingIndex].timestamp = Date.now();
                            history[existingIndex].feedback = feedbackType;
                } else {
                            history.unshift({
                                id: currentDocId,
                                prompt: currentPrompt,
                                timestamp: Date.now(),
                                feedback: feedbackType
                            });
                        }
                        
                        // Update document data with feedback, preserving existing content
                        const docKey = `luna_composer_doc_${currentDocId}`;
                        let docData = {
                            id: currentDocId,
                            content: currentContent,
                            prompt: currentPrompt,
                            timestamp: Date.now(),
                            license: currentLicense,
                            feedback: feedbackType
                        };
                        
                        // Preserve existing content if document already exists
                        const existingDoc = localStorage.getItem(docKey);
                        if (existingDoc) {
                            try {
                                const existingData = JSON.parse(existingDoc);
                                // Preserve HTML content if it exists, otherwise use text content
                                docData.content = existingData.content || currentContent;
                            } catch (e) {
                                // Use new content if parse fails
                            }
                        }
                        
                        localStorage.setItem(docKey, JSON.stringify(docData));
                        localStorage.setItem(historyKey, JSON.stringify(history));
                        
                        // Update heart icon state immediately
                        window.lunaComposerUpdateHeartState();
                        
                        // Reload history immediately to move document from Disliked to Liked section
                        setTimeout(() => {
                            if (typeof loadLunaComposerHistory === 'function') {
                                loadLunaComposerHistory();
                            }
                        }, 300);
                    }
                } else {
                    console.warn('[Luna Composer] Failed to save feedback:', response.status);
                }
            } catch (e) {
                console.error('[Luna Composer] Error saving feedback:', e);
            }
        };
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            const shareMenu = document.getElementById('luna-composer-share-menu');
            const exportMenu = document.getElementById('luna-composer-export-menu');
            const shareBtn = document.getElementById('luna-composer-share-btn');
            const exportBtn = document.getElementById('luna-composer-export-btn');
            
            if (shareMenu && shareBtn && !shareMenu.contains(e.target) && !shareBtn.contains(e.target)) {
                shareMenu.style.display = 'none';
            }
            
            if (exportMenu && exportBtn && !exportMenu.contains(e.target) && !exportBtn.contains(e.target)) {
                exportMenu.style.display = 'none';
            }
        });
        
        } // Close the else block from authentication check
        
    </script>
</body>
